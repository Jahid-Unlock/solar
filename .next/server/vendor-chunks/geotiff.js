"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/geotiff";
exports.ids = ["vendor-chunks/geotiff"];
exports.modules = {

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/basedecoder.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BaseDecoder)\n/* harmony export */ });\n/* harmony import */ var _predictor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../predictor.js */ \"(ssr)/./node_modules/geotiff/dist-module/predictor.js\");\n\n\nclass BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return (0,_predictor_js__WEBPACK_IMPORTED_MODULE_0__.applyPredictor)(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9iYXNlZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRDs7QUFFbEM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZEQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2NvbXByZXNzaW9uL2Jhc2VkZWNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwcGx5UHJlZGljdG9yIH0gZnJvbSAnLi4vcHJlZGljdG9yLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZURlY29kZXIge1xuICBhc3luYyBkZWNvZGUoZmlsZURpcmVjdG9yeSwgYnVmZmVyKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGF3YWl0IHRoaXMuZGVjb2RlQmxvY2soYnVmZmVyKTtcbiAgICBjb25zdCBwcmVkaWN0b3IgPSBmaWxlRGlyZWN0b3J5LlByZWRpY3RvciB8fCAxO1xuICAgIGlmIChwcmVkaWN0b3IgIT09IDEpIHtcbiAgICAgIGNvbnN0IGlzVGlsZWQgPSAhZmlsZURpcmVjdG9yeS5TdHJpcE9mZnNldHM7XG4gICAgICBjb25zdCB0aWxlV2lkdGggPSBpc1RpbGVkID8gZmlsZURpcmVjdG9yeS5UaWxlV2lkdGggOiBmaWxlRGlyZWN0b3J5LkltYWdlV2lkdGg7XG4gICAgICBjb25zdCB0aWxlSGVpZ2h0ID0gaXNUaWxlZCA/IGZpbGVEaXJlY3RvcnkuVGlsZUxlbmd0aCA6IChcbiAgICAgICAgZmlsZURpcmVjdG9yeS5Sb3dzUGVyU3RyaXAgfHwgZmlsZURpcmVjdG9yeS5JbWFnZUxlbmd0aFxuICAgICAgKTtcbiAgICAgIHJldHVybiBhcHBseVByZWRpY3RvcihcbiAgICAgICAgZGVjb2RlZCwgcHJlZGljdG9yLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQsIGZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZSxcbiAgICAgICAgZmlsZURpcmVjdG9yeS5QbGFuYXJDb25maWd1cmF0aW9uLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/deflate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/deflate.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DeflateDecoder)\n/* harmony export */ });\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n\n\n\nclass DeflateDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  decodeBlock(buffer) {\n    return (0,pako__WEBPACK_IMPORTED_MODULE_0__.inflate)(new Uint8Array(buffer)).buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9kZWZsYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNZOztBQUU1Qiw2QkFBNkIsdURBQVc7QUFDdkQ7QUFDQSxXQUFXLDZDQUFPO0FBQ2xCO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvY29tcHJlc3Npb24vZGVmbGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbmZsYXRlIH0gZnJvbSAncGFrbyc7XG5pbXBvcnQgQmFzZURlY29kZXIgZnJvbSAnLi9iYXNlZGVjb2Rlci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmxhdGVEZWNvZGVyIGV4dGVuZHMgQmFzZURlY29kZXIge1xuICBkZWNvZGVCbG9jayhidWZmZXIpIHtcbiAgICByZXR1cm4gaW5mbGF0ZShuZXcgVWludDhBcnJheShidWZmZXIpKS5idWZmZXI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/deflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDecoder: () => (/* binding */ addDecoder),\n/* harmony export */   getDecoder: () => (/* binding */ getDecoder)\n/* harmony export */ });\nconst registry = new Map();\n\nfunction addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nasync function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => __webpack_require__.e(/*! import() */ \"vendor-chunks/geotiff\").then(__webpack_require__.bind(__webpack_require__, /*! ./raw.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/raw.js\")).then((m) => m.default));\naddDecoder(5, () => __webpack_require__.e(/*! import() */ \"vendor-chunks/geotiff\").then(__webpack_require__.bind(__webpack_require__, /*! ./lzw.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/lzw.js\")).then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => __webpack_require__.e(/*! import() */ \"vendor-chunks/geotiff\").then(__webpack_require__.bind(__webpack_require__, /*! ./jpeg.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/jpeg.js\")).then((m) => m.default));\naddDecoder([8, 32946], () => Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/geotiff\"), __webpack_require__.e(\"vendor-chunks/pako\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./deflate.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/deflate.js\")).then((m) => m.default));\naddDecoder(32773, () => __webpack_require__.e(/*! import() */ \"vendor-chunks/geotiff\").then(__webpack_require__.bind(__webpack_require__, /*! ./packbits.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/packbits.js\")).then((m) => m.default));\naddDecoder(34887, () => Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/geotiff\"), __webpack_require__.e(\"vendor-chunks/pako\"), __webpack_require__.e(\"vendor-chunks/zstddec\"), __webpack_require__.e(\"vendor-chunks/lerc\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./lerc.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/lerc.js\"))\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => __webpack_require__.e(/*! import() */ \"vendor-chunks/geotiff\").then(__webpack_require__.bind(__webpack_require__, /*! ./webimage.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/webimage.js\")).then((m) => m.default));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUVPO0FBQ1A7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLDhEQUE4RCwwQkFBMEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsaU1BQWtCO0FBQ25ELG9CQUFvQixpTUFBa0I7QUFDdEM7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0IsbU1BQW1CO0FBQ3ZDLDZCQUE2QixvUUFBc0I7QUFDbkQsd0JBQXdCLDJNQUF1QjtBQUMvQyx3QkFBd0IsMlZBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0JBQXdCLDJNQUF1QiIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByZWdpc3RyeSA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZERlY29kZXIoY2FzZXMsIGltcG9ydEZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShjYXNlcykpIHtcbiAgICBjYXNlcyA9IFtjYXNlc107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgfVxuICBjYXNlcy5mb3JFYWNoKChjKSA9PiByZWdpc3RyeS5zZXQoYywgaW1wb3J0Rm4pKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERlY29kZXIoZmlsZURpcmVjdG9yeSkge1xuICBjb25zdCBpbXBvcnRGbiA9IHJlZ2lzdHJ5LmdldChmaWxlRGlyZWN0b3J5LkNvbXByZXNzaW9uKTtcbiAgaWYgKCFpbXBvcnRGbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QgaWRlbnRpZmllcjogJHtmaWxlRGlyZWN0b3J5LkNvbXByZXNzaW9ufWApO1xuICB9XG4gIGNvbnN0IERlY29kZXIgPSBhd2FpdCBpbXBvcnRGbigpO1xuICByZXR1cm4gbmV3IERlY29kZXIoZmlsZURpcmVjdG9yeSk7XG59XG5cbi8vIEFkZCBkZWZhdWx0IGRlY29kZXJzIHRvIHJlZ2lzdHJ5IChlbmQtdXNlciBtYXkgb3ZlcnJpZGUgd2l0aCBvdGhlciBpbXBsZW1lbnRhdGlvbnMpXG5hZGREZWNvZGVyKFt1bmRlZmluZWQsIDFdLCAoKSA9PiBpbXBvcnQoJy4vcmF3LmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG5hZGREZWNvZGVyKDUsICgpID0+IGltcG9ydCgnLi9sencuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbmFkZERlY29kZXIoNiwgKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ29sZCBzdHlsZSBKUEVHIGNvbXByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG59KTtcbmFkZERlY29kZXIoNywgKCkgPT4gaW1wb3J0KCcuL2pwZWcuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbmFkZERlY29kZXIoWzgsIDMyOTQ2XSwgKCkgPT4gaW1wb3J0KCcuL2RlZmxhdGUuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbmFkZERlY29kZXIoMzI3NzMsICgpID0+IGltcG9ydCgnLi9wYWNrYml0cy5qcycpLnRoZW4oKG0pID0+IG0uZGVmYXVsdCkpO1xuYWRkRGVjb2RlcigzNDg4NywgKCkgPT4gaW1wb3J0KCcuL2xlcmMuanMnKVxuICAudGhlbihhc3luYyAobSkgPT4ge1xuICAgIGF3YWl0IG0uenN0ZC5pbml0KCk7XG4gICAgcmV0dXJuIG07XG4gIH0pXG4gIC50aGVuKChtKSA9PiBtLmRlZmF1bHQpLFxuKTtcbmFkZERlY29kZXIoNTAwMDEsICgpID0+IGltcG9ydCgnLi93ZWJpbWFnZS5qcycpLnRoZW4oKG0pID0+IG0uZGVmYXVsdCkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/jpeg.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/jpeg.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ JpegDecoder)\n/* harmony export */ });\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n\n\n/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n       http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\nconst dctZigZag = new Int32Array([\n  0,\n  1, 8,\n  16, 9, 2,\n  3, 10, 17, 24,\n  32, 25, 18, 11, 4,\n  5, 12, 19, 26, 33, 40,\n  48, 41, 34, 27, 20, 13, 6,\n  7, 14, 21, 28, 35, 42, 49, 56,\n  57, 50, 43, 36, 29, 22, 15,\n  23, 30, 37, 44, 51, 58,\n  59, 52, 45, 38, 31,\n  39, 46, 53, 60,\n  61, 54, 47,\n  55, 62,\n  63,\n]);\n\nconst dctCos1 = 4017; // cos(pi/16)\nconst dctSin1 = 799; // sin(pi/16)\nconst dctCos3 = 3406; // cos(3*pi/16)\nconst dctSin3 = 2276; // sin(3*pi/16)\nconst dctCos6 = 1567; // cos(6*pi/16)\nconst dctSin6 = 3784; // sin(6*pi/16)\nconst dctSqrt2 = 5793; // sqrt(2)\nconst dctSqrt1d2 = 2896;// sqrt(2) / 2\n\nfunction buildHuffmanTable(codeLengths, values) {\n  let k = 0;\n  const code = [];\n  let length = 16;\n  while (length > 0 && !codeLengths[length - 1]) {\n    --length;\n  }\n  code.push({ children: [], index: 0 });\n\n  let p = code[0];\n  let q;\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < codeLengths[i]; j++) {\n      p = code.pop();\n      p.children[p.index] = values[k];\n      while (p.index > 0) {\n        p = code.pop();\n      }\n      p.index++;\n      code.push(p);\n      while (code.length <= i) {\n        code.push(q = { children: [], index: 0 });\n        p.children[p.index] = q.children;\n        p = q;\n      }\n      k++;\n    }\n    if (i + 1 < length) {\n      // p here points to last code\n      code.push(q = { children: [], index: 0 });\n      p.children[p.index] = q.children;\n      p = q;\n    }\n  }\n  return code[0].children;\n}\n\nfunction decodeScan(data, initialOffset,\n  frame, components, resetInterval,\n  spectralStart, spectralEnd,\n  successivePrev, successive) {\n  const { mcusPerLine, progressive } = frame;\n\n  const startOffset = initialOffset;\n  let offset = initialOffset;\n  let bitsData = 0;\n  let bitsCount = 0;\n  function readBit() {\n    if (bitsCount > 0) {\n      bitsCount--;\n      return (bitsData >> bitsCount) & 1;\n    }\n    bitsData = data[offset++];\n    if (bitsData === 0xFF) {\n      const nextByte = data[offset++];\n      if (nextByte) {\n        throw new Error(`unexpected marker: ${((bitsData << 8) | nextByte).toString(16)}`);\n      }\n      // unstuff 0\n    }\n    bitsCount = 7;\n    return bitsData >>> 7;\n  }\n  function decodeHuffman(tree) {\n    let node = tree;\n    let bit;\n    while ((bit = readBit()) !== null) { // eslint-disable-line no-cond-assign\n      node = node[bit];\n      if (typeof node === 'number') {\n        return node;\n      }\n      if (typeof node !== 'object') {\n        throw new Error('invalid huffman sequence');\n      }\n    }\n    return null;\n  }\n  function receive(initialLength) {\n    let length = initialLength;\n    let n = 0;\n    while (length > 0) {\n      const bit = readBit();\n      if (bit === null) {\n        return undefined;\n      }\n      n = (n << 1) | bit;\n      --length;\n    }\n    return n;\n  }\n  function receiveAndExtend(length) {\n    const n = receive(length);\n    if (n >= 1 << (length - 1)) {\n      return n;\n    }\n    return n + (-1 << length) + 1;\n  }\n  function decodeBaseline(component, zz) {\n    const t = decodeHuffman(component.huffmanTableDC);\n    const diff = t === 0 ? 0 : receiveAndExtend(t);\n    component.pred += diff;\n    zz[0] = component.pred;\n    let k = 1;\n    while (k < 64) {\n      const rs = decodeHuffman(component.huffmanTableAC);\n      const s = rs & 15;\n      const r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          break;\n        }\n        k += 16;\n      } else {\n        k += r;\n        const z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n  }\n  function decodeDCFirst(component, zz) {\n    const t = decodeHuffman(component.huffmanTableDC);\n    const diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n    component.pred += diff;\n    zz[0] = component.pred;\n  }\n  function decodeDCSuccessive(component, zz) {\n    zz[0] |= readBit() << successive;\n  }\n  let eobrun = 0;\n  function decodeACFirst(component, zz) {\n    if (eobrun > 0) {\n      eobrun--;\n      return;\n    }\n    let k = spectralStart;\n    const e = spectralEnd;\n    while (k <= e) {\n      const rs = decodeHuffman(component.huffmanTableAC);\n      const s = rs & 15;\n      const r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          eobrun = receive(r) + (1 << r) - 1;\n          break;\n        }\n        k += 16;\n      } else {\n        k += r;\n        const z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n  }\n  let successiveACState = 0;\n  let successiveACNextValue;\n  function decodeACSuccessive(component, zz) {\n    let k = spectralStart;\n    const e = spectralEnd;\n    let r = 0;\n    while (k <= e) {\n      const z = dctZigZag[k];\n      const direction = zz[z] < 0 ? -1 : 1;\n      switch (successiveACState) {\n        case 0: { // initial state\n          const rs = decodeHuffman(component.huffmanTableAC);\n          const s = rs & 15;\n          r = rs >> 4;\n          if (s === 0) {\n            if (r < 15) {\n              eobrun = receive(r) + (1 << r);\n              successiveACState = 4;\n            } else {\n              r = 16;\n              successiveACState = 1;\n            }\n          } else {\n            if (s !== 1) {\n              throw new Error('invalid ACn encoding');\n            }\n            successiveACNextValue = receiveAndExtend(s);\n            successiveACState = r ? 2 : 3;\n          }\n          continue; // eslint-disable-line no-continue\n        }\n        case 1: // skipping r zero items\n        case 2:\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          } else {\n            r--;\n            if (r === 0) {\n              successiveACState = successiveACState === 2 ? 3 : 0;\n            }\n          }\n          break;\n        case 3: // set value for a zero item\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          } else {\n            zz[z] = successiveACNextValue << successive;\n            successiveACState = 0;\n          }\n          break;\n        case 4: // eob\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          }\n          break;\n        default:\n          break;\n      }\n      k++;\n    }\n    if (successiveACState === 4) {\n      eobrun--;\n      if (eobrun === 0) {\n        successiveACState = 0;\n      }\n    }\n  }\n  function decodeMcu(component, decodeFunction, mcu, row, col) {\n    const mcuRow = (mcu / mcusPerLine) | 0;\n    const mcuCol = mcu % mcusPerLine;\n    const blockRow = (mcuRow * component.v) + row;\n    const blockCol = (mcuCol * component.h) + col;\n    decodeFunction(component, component.blocks[blockRow][blockCol]);\n  }\n  function decodeBlock(component, decodeFunction, mcu) {\n    const blockRow = (mcu / component.blocksPerLine) | 0;\n    const blockCol = mcu % component.blocksPerLine;\n    decodeFunction(component, component.blocks[blockRow][blockCol]);\n  }\n\n  const componentsLength = components.length;\n  let component;\n  let i;\n  let j;\n  let k;\n  let n;\n  let decodeFn;\n  if (progressive) {\n    if (spectralStart === 0) {\n      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n    } else {\n      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    }\n  } else {\n    decodeFn = decodeBaseline;\n  }\n\n  let mcu = 0;\n  let marker;\n  let mcuExpected;\n  if (componentsLength === 1) {\n    mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n  } else {\n    mcuExpected = mcusPerLine * frame.mcusPerColumn;\n  }\n\n  const usedResetInterval = resetInterval || mcuExpected;\n\n  while (mcu < mcuExpected) {\n    // reset interval stuff\n    for (i = 0; i < componentsLength; i++) {\n      components[i].pred = 0;\n    }\n    eobrun = 0;\n\n    if (componentsLength === 1) {\n      component = components[0];\n      for (n = 0; n < usedResetInterval; n++) {\n        decodeBlock(component, decodeFn, mcu);\n        mcu++;\n      }\n    } else {\n      for (n = 0; n < usedResetInterval; n++) {\n        for (i = 0; i < componentsLength; i++) {\n          component = components[i];\n          const { h, v } = component;\n          for (j = 0; j < v; j++) {\n            for (k = 0; k < h; k++) {\n              decodeMcu(component, decodeFn, mcu, j, k);\n            }\n          }\n        }\n        mcu++;\n\n        // If we've reached our expected MCU's, stop decoding\n        if (mcu === mcuExpected) {\n          break;\n        }\n      }\n    }\n\n    // find marker\n    bitsCount = 0;\n    marker = (data[offset] << 8) | data[offset + 1];\n    if (marker < 0xFF00) {\n      throw new Error('marker was not found');\n    }\n\n    if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n      offset += 2;\n    } else {\n      break;\n    }\n  }\n\n  return offset - startOffset;\n}\n\nfunction buildComponentData(frame, component) {\n  const lines = [];\n  const { blocksPerLine, blocksPerColumn } = component;\n  const samplesPerLine = blocksPerLine << 3;\n  const R = new Int32Array(64);\n  const r = new Uint8Array(64);\n\n  // A port of poppler's IDCT method which in turn is taken from:\n  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n  //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n  //   988-991.\n  function quantizeAndInverse(zz, dataOut, dataIn) {\n    const qt = component.quantizationTable;\n    let v0;\n    let v1;\n    let v2;\n    let v3;\n    let v4;\n    let v5;\n    let v6;\n    let v7;\n    let t;\n    const p = dataIn;\n    let i;\n\n    // dequant\n    for (i = 0; i < 64; i++) {\n      p[i] = zz[i] * qt[i];\n    }\n\n    // inverse DCT on rows\n    for (i = 0; i < 8; ++i) {\n      const row = 8 * i;\n\n      // check for all-zero AC coefficients\n      if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0\n        && p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0\n        && p[7 + row] === 0) {\n        t = ((dctSqrt2 * p[0 + row]) + 512) >> 10;\n        p[0 + row] = t;\n        p[1 + row] = t;\n        p[2 + row] = t;\n        p[3 + row] = t;\n        p[4 + row] = t;\n        p[5 + row] = t;\n        p[6 + row] = t;\n        p[7 + row] = t;\n        continue; // eslint-disable-line no-continue\n      }\n\n      // stage 4\n      v0 = ((dctSqrt2 * p[0 + row]) + 128) >> 8;\n      v1 = ((dctSqrt2 * p[4 + row]) + 128) >> 8;\n      v2 = p[2 + row];\n      v3 = p[6 + row];\n      v4 = ((dctSqrt1d2 * (p[1 + row] - p[7 + row])) + 128) >> 8;\n      v7 = ((dctSqrt1d2 * (p[1 + row] + p[7 + row])) + 128) >> 8;\n      v5 = p[3 + row] << 4;\n      v6 = p[5 + row] << 4;\n\n      // stage 3\n      t = (v0 - v1 + 1) >> 1;\n      v0 = (v0 + v1 + 1) >> 1;\n      v1 = t;\n      t = ((v2 * dctSin6) + (v3 * dctCos6) + 128) >> 8;\n      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 128) >> 8;\n      v3 = t;\n      t = (v4 - v6 + 1) >> 1;\n      v4 = (v4 + v6 + 1) >> 1;\n      v6 = t;\n      t = (v7 + v5 + 1) >> 1;\n      v5 = (v7 - v5 + 1) >> 1;\n      v7 = t;\n\n      // stage 2\n      t = (v0 - v3 + 1) >> 1;\n      v0 = (v0 + v3 + 1) >> 1;\n      v3 = t;\n      t = (v1 - v2 + 1) >> 1;\n      v1 = (v1 + v2 + 1) >> 1;\n      v2 = t;\n      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\n      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\n      v7 = t;\n      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\n      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\n      v6 = t;\n\n      // stage 1\n      p[0 + row] = v0 + v7;\n      p[7 + row] = v0 - v7;\n      p[1 + row] = v1 + v6;\n      p[6 + row] = v1 - v6;\n      p[2 + row] = v2 + v5;\n      p[5 + row] = v2 - v5;\n      p[3 + row] = v3 + v4;\n      p[4 + row] = v3 - v4;\n    }\n\n    // inverse DCT on columns\n    for (i = 0; i < 8; ++i) {\n      const col = i;\n\n      // check for all-zero AC coefficients\n      if (p[(1 * 8) + col] === 0 && p[(2 * 8) + col] === 0 && p[(3 * 8) + col] === 0\n        && p[(4 * 8) + col] === 0 && p[(5 * 8) + col] === 0 && p[(6 * 8) + col] === 0\n        && p[(7 * 8) + col] === 0) {\n        t = ((dctSqrt2 * dataIn[i + 0]) + 8192) >> 14;\n        p[(0 * 8) + col] = t;\n        p[(1 * 8) + col] = t;\n        p[(2 * 8) + col] = t;\n        p[(3 * 8) + col] = t;\n        p[(4 * 8) + col] = t;\n        p[(5 * 8) + col] = t;\n        p[(6 * 8) + col] = t;\n        p[(7 * 8) + col] = t;\n        continue; // eslint-disable-line no-continue\n      }\n\n      // stage 4\n      v0 = ((dctSqrt2 * p[(0 * 8) + col]) + 2048) >> 12;\n      v1 = ((dctSqrt2 * p[(4 * 8) + col]) + 2048) >> 12;\n      v2 = p[(2 * 8) + col];\n      v3 = p[(6 * 8) + col];\n      v4 = ((dctSqrt1d2 * (p[(1 * 8) + col] - p[(7 * 8) + col])) + 2048) >> 12;\n      v7 = ((dctSqrt1d2 * (p[(1 * 8) + col] + p[(7 * 8) + col])) + 2048) >> 12;\n      v5 = p[(3 * 8) + col];\n      v6 = p[(5 * 8) + col];\n\n      // stage 3\n      t = (v0 - v1 + 1) >> 1;\n      v0 = (v0 + v1 + 1) >> 1;\n      v1 = t;\n      t = ((v2 * dctSin6) + (v3 * dctCos6) + 2048) >> 12;\n      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 2048) >> 12;\n      v3 = t;\n      t = (v4 - v6 + 1) >> 1;\n      v4 = (v4 + v6 + 1) >> 1;\n      v6 = t;\n      t = (v7 + v5 + 1) >> 1;\n      v5 = (v7 - v5 + 1) >> 1;\n      v7 = t;\n\n      // stage 2\n      t = (v0 - v3 + 1) >> 1;\n      v0 = (v0 + v3 + 1) >> 1;\n      v3 = t;\n      t = (v1 - v2 + 1) >> 1;\n      v1 = (v1 + v2 + 1) >> 1;\n      v2 = t;\n      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\n      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\n      v7 = t;\n      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\n      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\n      v6 = t;\n\n      // stage 1\n      p[(0 * 8) + col] = v0 + v7;\n      p[(7 * 8) + col] = v0 - v7;\n      p[(1 * 8) + col] = v1 + v6;\n      p[(6 * 8) + col] = v1 - v6;\n      p[(2 * 8) + col] = v2 + v5;\n      p[(5 * 8) + col] = v2 - v5;\n      p[(3 * 8) + col] = v3 + v4;\n      p[(4 * 8) + col] = v3 - v4;\n    }\n\n    // convert to 8-bit integers\n    for (i = 0; i < 64; ++i) {\n      const sample = 128 + ((p[i] + 8) >> 4);\n      if (sample < 0) {\n        dataOut[i] = 0;\n      } else if (sample > 0XFF) {\n        dataOut[i] = 0xFF;\n      } else {\n        dataOut[i] = sample;\n      }\n    }\n  }\n\n  for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n    const scanLine = blockRow << 3;\n    for (let i = 0; i < 8; i++) {\n      lines.push(new Uint8Array(samplesPerLine));\n    }\n    for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n      quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n\n      let offset = 0;\n      const sample = blockCol << 3;\n      for (let j = 0; j < 8; j++) {\n        const line = lines[scanLine + j];\n        for (let i = 0; i < 8; i++) {\n          line[sample + i] = r[offset++];\n        }\n      }\n    }\n  }\n  return lines;\n}\n\nclass JpegStreamReader {\n  constructor() {\n    this.jfif = null;\n    this.adobe = null;\n\n    this.quantizationTables = [];\n    this.huffmanTablesAC = [];\n    this.huffmanTablesDC = [];\n    this.resetFrames();\n  }\n\n  resetFrames() {\n    this.frames = [];\n  }\n\n  parse(data) {\n    let offset = 0;\n    // const { length } = data;\n    function readUint16() {\n      const value = (data[offset] << 8) | data[offset + 1];\n      offset += 2;\n      return value;\n    }\n    function readDataBlock() {\n      const length = readUint16();\n      const array = data.subarray(offset, offset + length - 2);\n      offset += array.length;\n      return array;\n    }\n    function prepareComponents(frame) {\n      let maxH = 0;\n      let maxV = 0;\n      let component;\n      let componentId;\n      for (componentId in frame.components) {\n        if (frame.components.hasOwnProperty(componentId)) {\n          component = frame.components[componentId];\n          if (maxH < component.h) {\n            maxH = component.h;\n          }\n          if (maxV < component.v) {\n            maxV = component.v;\n          }\n        }\n      }\n      const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n      const mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n      for (componentId in frame.components) {\n        if (frame.components.hasOwnProperty(componentId)) {\n          component = frame.components[componentId];\n          const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n          const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);\n          const blocksPerLineForMcu = mcusPerLine * component.h;\n          const blocksPerColumnForMcu = mcusPerColumn * component.v;\n          const blocks = [];\n          for (let i = 0; i < blocksPerColumnForMcu; i++) {\n            const row = [];\n            for (let j = 0; j < blocksPerLineForMcu; j++) {\n              row.push(new Int32Array(64));\n            }\n            blocks.push(row);\n          }\n          component.blocksPerLine = blocksPerLine;\n          component.blocksPerColumn = blocksPerColumn;\n          component.blocks = blocks;\n        }\n      }\n      frame.maxH = maxH;\n      frame.maxV = maxV;\n      frame.mcusPerLine = mcusPerLine;\n      frame.mcusPerColumn = mcusPerColumn;\n    }\n\n    let fileMarker = readUint16();\n    if (fileMarker !== 0xFFD8) { // SOI (Start of Image)\n      throw new Error('SOI not found');\n    }\n\n    fileMarker = readUint16();\n    while (fileMarker !== 0xFFD9) { // EOI (End of image)\n      switch (fileMarker) {\n        case 0xFF00: break;\n        case 0xFFE0: // APP0 (Application Specific)\n        case 0xFFE1: // APP1\n        case 0xFFE2: // APP2\n        case 0xFFE3: // APP3\n        case 0xFFE4: // APP4\n        case 0xFFE5: // APP5\n        case 0xFFE6: // APP6\n        case 0xFFE7: // APP7\n        case 0xFFE8: // APP8\n        case 0xFFE9: // APP9\n        case 0xFFEA: // APP10\n        case 0xFFEB: // APP11\n        case 0xFFEC: // APP12\n        case 0xFFED: // APP13\n        case 0xFFEE: // APP14\n        case 0xFFEF: // APP15\n        case 0xFFFE: { // COM (Comment)\n          const appData = readDataBlock();\n\n          if (fileMarker === 0xFFE0) {\n            if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49\n              && appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n              this.jfif = {\n                version: { major: appData[5], minor: appData[6] },\n                densityUnits: appData[7],\n                xDensity: (appData[8] << 8) | appData[9],\n                yDensity: (appData[10] << 8) | appData[11],\n                thumbWidth: appData[12],\n                thumbHeight: appData[13],\n                thumbData: appData.subarray(14, 14 + (3 * appData[12] * appData[13])),\n              };\n            }\n          }\n          // TODO APP1 - Exif\n          if (fileMarker === 0xFFEE) {\n            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F\n              && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n              this.adobe = {\n                version: appData[6],\n                flags0: (appData[7] << 8) | appData[8],\n                flags1: (appData[9] << 8) | appData[10],\n                transformCode: appData[11],\n              };\n            }\n          }\n          break;\n        }\n\n        case 0xFFDB: { // DQT (Define Quantization Tables)\n          const quantizationTablesLength = readUint16();\n          const quantizationTablesEnd = quantizationTablesLength + offset - 2;\n          while (offset < quantizationTablesEnd) {\n            const quantizationTableSpec = data[offset++];\n            const tableData = new Int32Array(64);\n            if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n              for (let j = 0; j < 64; j++) {\n                const z = dctZigZag[j];\n                tableData[z] = data[offset++];\n              }\n            } else if ((quantizationTableSpec >> 4) === 1) { // 16 bit\n              for (let j = 0; j < 64; j++) {\n                const z = dctZigZag[j];\n                tableData[z] = readUint16();\n              }\n            } else {\n              throw new Error('DQT: invalid table spec');\n            }\n            this.quantizationTables[quantizationTableSpec & 15] = tableData;\n          }\n          break;\n        }\n\n        case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n        case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n        case 0xFFC2: { // SOF2 (Start of Frame, Progressive DCT)\n          readUint16(); // skip data length\n          const frame = {\n            extended: (fileMarker === 0xFFC1),\n            progressive: (fileMarker === 0xFFC2),\n            precision: data[offset++],\n            scanLines: readUint16(),\n            samplesPerLine: readUint16(),\n            components: {},\n            componentsOrder: [],\n          };\n\n          const componentsCount = data[offset++];\n          let componentId;\n          // let maxH = 0;\n          // let maxV = 0;\n          for (let i = 0; i < componentsCount; i++) {\n            componentId = data[offset];\n            const h = data[offset + 1] >> 4;\n            const v = data[offset + 1] & 15;\n            const qId = data[offset + 2];\n            frame.componentsOrder.push(componentId);\n            frame.components[componentId] = {\n              h,\n              v,\n              quantizationIdx: qId,\n            };\n            offset += 3;\n          }\n          prepareComponents(frame);\n          this.frames.push(frame);\n          break;\n        }\n\n        case 0xFFC4: { // DHT (Define Huffman Tables)\n          const huffmanLength = readUint16();\n          for (let i = 2; i < huffmanLength;) {\n            const huffmanTableSpec = data[offset++];\n            const codeLengths = new Uint8Array(16);\n            let codeLengthSum = 0;\n            for (let j = 0; j < 16; j++, offset++) {\n              codeLengths[j] = data[offset];\n              codeLengthSum += codeLengths[j];\n            }\n            const huffmanValues = new Uint8Array(codeLengthSum);\n            for (let j = 0; j < codeLengthSum; j++, offset++) {\n              huffmanValues[j] = data[offset];\n            }\n            i += 17 + codeLengthSum;\n\n            if ((huffmanTableSpec >> 4) === 0) {\n              this.huffmanTablesDC[huffmanTableSpec & 15] = buildHuffmanTable(\n                codeLengths, huffmanValues,\n              );\n            } else {\n              this.huffmanTablesAC[huffmanTableSpec & 15] = buildHuffmanTable(\n                codeLengths, huffmanValues,\n              );\n            }\n          }\n          break;\n        }\n\n        case 0xFFDD: // DRI (Define Restart Interval)\n          readUint16(); // skip data length\n          this.resetInterval = readUint16();\n          break;\n\n        case 0xFFDA: { // SOS (Start of Scan)\n          readUint16(); // skip length\n          const selectorsCount = data[offset++];\n          const components = [];\n          const frame = this.frames[0];\n          for (let i = 0; i < selectorsCount; i++) {\n            const component = frame.components[data[offset++]];\n            const tableSpec = data[offset++];\n            component.huffmanTableDC = this.huffmanTablesDC[tableSpec >> 4];\n            component.huffmanTableAC = this.huffmanTablesAC[tableSpec & 15];\n            components.push(component);\n          }\n          const spectralStart = data[offset++];\n          const spectralEnd = data[offset++];\n          const successiveApproximation = data[offset++];\n          const processed = decodeScan(data, offset,\n            frame, components, this.resetInterval,\n            spectralStart, spectralEnd,\n            successiveApproximation >> 4, successiveApproximation & 15);\n          offset += processed;\n          break;\n        }\n\n        case 0xFFFF: // Fill bytes\n          if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\n            offset--;\n          }\n          break;\n\n        default:\n          if (data[offset - 3] === 0xFF\n            && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n            // could be incorrect encoding -- last 0xFF byte of the previous\n            // block was eaten by the encoder\n            offset -= 3;\n            break;\n          }\n          throw new Error(`unknown JPEG marker ${fileMarker.toString(16)}`);\n      }\n      fileMarker = readUint16();\n    }\n  }\n\n  getResult() {\n    const { frames } = this;\n    if (this.frames.length === 0) {\n      throw new Error('no frames were decoded');\n    } else if (this.frames.length > 1) {\n      console.warn('more than one frame is not supported');\n    }\n\n    // set each frame's components quantization table\n    for (let i = 0; i < this.frames.length; i++) {\n      const cp = this.frames[i].components;\n      for (const j of Object.keys(cp)) {\n        cp[j].quantizationTable = this.quantizationTables[cp[j].quantizationIdx];\n        delete cp[j].quantizationIdx;\n      }\n    }\n\n    const frame = frames[0];\n    const { components, componentsOrder } = frame;\n    const outComponents = [];\n    const width = frame.samplesPerLine;\n    const height = frame.scanLines;\n\n    for (let i = 0; i < componentsOrder.length; i++) {\n      const component = components[componentsOrder[i]];\n      outComponents.push({\n        lines: buildComponentData(frame, component),\n        scaleX: component.h / frame.maxH,\n        scaleY: component.v / frame.maxV,\n      });\n    }\n\n    const out = new Uint8Array(width * height * outComponents.length);\n    let oi = 0;\n    for (let y = 0; y < height; ++y) {\n      for (let x = 0; x < width; ++x) {\n        for (let i = 0; i < outComponents.length; ++i) {\n          const component = outComponents[i];\n          out[oi] = component.lines[0 | y * component.scaleY][0 | x * component.scaleX];\n          ++oi;\n        }\n      }\n    }\n    return out;\n  }\n}\n\nclass JpegDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(fileDirectory) {\n    super();\n    this.reader = new JpegStreamReader();\n    if (fileDirectory.JPEGTables) {\n      this.reader.parse(fileDirectory.JPEGTables);\n    }\n  }\n\n  decodeBlock(buffer) {\n    this.reader.resetFrames();\n    this.reader.parse(new Uint8Array(buffer));\n    return this.reader.getResult().buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9qcGVnLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJDOztBQUUzQyxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3Qjs7QUFFdEM7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwQ0FBMEM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrQkFBa0IsdUJBQXVCO0FBQ3pDLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixzQkFBc0IsT0FBTztBQUM3Qix3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdEO0FBQ2hEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLDJCQUEyQixzQ0FBc0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQStDO0FBQzdELDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx3QkFBd0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQyxzQkFBc0IsV0FBVztBQUNqQyx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSwwQkFBMEIsdURBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2NvbXByZXNzaW9uL2pwZWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VEZWNvZGVyIGZyb20gJy4vYmFzZWRlY29kZXIuanMnO1xuXG4vKiAtKi0gdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGMtYmFzaWMtb2Zmc2V0OiAyIC0qLSAvXG4vKiB2aW06IHNldCBzaGlmdHdpZHRoPTIgdGFic3RvcD0yIGF1dG9pbmRlbnQgY2luZGVudCBleHBhbmR0YWI6ICovXG4vKlxuICAgQ29weXJpZ2h0IDIwMTEgbm90bWFzdGVyeWV0XG4gICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuLy8gLSBUaGUgSlBFRyBzcGVjaWZpY2F0aW9uIGNhbiBiZSBmb3VuZCBpbiB0aGUgSVRVIENDSVRUIFJlY29tbWVuZGF0aW9uIFQuODFcbi8vICAgKHd3dy53My5vcmcvR3JhcGhpY3MvSlBFRy9pdHUtdDgxLnBkZilcbi8vIC0gVGhlIEpGSUYgc3BlY2lmaWNhdGlvbiBjYW4gYmUgZm91bmQgaW4gdGhlIEpQRUcgRmlsZSBJbnRlcmNoYW5nZSBGb3JtYXRcbi8vICAgKHd3dy53My5vcmcvR3JhcGhpY3MvSlBFRy9qZmlmMy5wZGYpXG4vLyAtIFRoZSBBZG9iZSBBcHBsaWNhdGlvbi1TcGVjaWZpYyBKUEVHIG1hcmtlcnMgaW4gdGhlIFN1cHBvcnRpbmcgdGhlIERDVCBGaWx0ZXJzXG4vLyAgIGluIFBvc3RTY3JpcHQgTGV2ZWwgMiwgVGVjaG5pY2FsIE5vdGUgIzUxMTZcbi8vICAgKHBhcnRuZXJzLmFkb2JlLmNvbS9wdWJsaWMvZGV2ZWxvcGVyL2VuL3BzL3Nkay81MTE2LkRDVF9GaWx0ZXIucGRmKVxuXG5jb25zdCBkY3RaaWdaYWcgPSBuZXcgSW50MzJBcnJheShbXG4gIDAsXG4gIDEsIDgsXG4gIDE2LCA5LCAyLFxuICAzLCAxMCwgMTcsIDI0LFxuICAzMiwgMjUsIDE4LCAxMSwgNCxcbiAgNSwgMTIsIDE5LCAyNiwgMzMsIDQwLFxuICA0OCwgNDEsIDM0LCAyNywgMjAsIDEzLCA2LFxuICA3LCAxNCwgMjEsIDI4LCAzNSwgNDIsIDQ5LCA1NixcbiAgNTcsIDUwLCA0MywgMzYsIDI5LCAyMiwgMTUsXG4gIDIzLCAzMCwgMzcsIDQ0LCA1MSwgNTgsXG4gIDU5LCA1MiwgNDUsIDM4LCAzMSxcbiAgMzksIDQ2LCA1MywgNjAsXG4gIDYxLCA1NCwgNDcsXG4gIDU1LCA2MixcbiAgNjMsXG5dKTtcblxuY29uc3QgZGN0Q29zMSA9IDQwMTc7IC8vIGNvcyhwaS8xNilcbmNvbnN0IGRjdFNpbjEgPSA3OTk7IC8vIHNpbihwaS8xNilcbmNvbnN0IGRjdENvczMgPSAzNDA2OyAvLyBjb3MoMypwaS8xNilcbmNvbnN0IGRjdFNpbjMgPSAyMjc2OyAvLyBzaW4oMypwaS8xNilcbmNvbnN0IGRjdENvczYgPSAxNTY3OyAvLyBjb3MoNipwaS8xNilcbmNvbnN0IGRjdFNpbjYgPSAzNzg0OyAvLyBzaW4oNipwaS8xNilcbmNvbnN0IGRjdFNxcnQyID0gNTc5MzsgLy8gc3FydCgyKVxuY29uc3QgZGN0U3FydDFkMiA9IDI4OTY7Ly8gc3FydCgyKSAvIDJcblxuZnVuY3Rpb24gYnVpbGRIdWZmbWFuVGFibGUoY29kZUxlbmd0aHMsIHZhbHVlcykge1xuICBsZXQgayA9IDA7XG4gIGNvbnN0IGNvZGUgPSBbXTtcbiAgbGV0IGxlbmd0aCA9IDE2O1xuICB3aGlsZSAobGVuZ3RoID4gMCAmJiAhY29kZUxlbmd0aHNbbGVuZ3RoIC0gMV0pIHtcbiAgICAtLWxlbmd0aDtcbiAgfVxuICBjb2RlLnB1c2goeyBjaGlsZHJlbjogW10sIGluZGV4OiAwIH0pO1xuXG4gIGxldCBwID0gY29kZVswXTtcbiAgbGV0IHE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvZGVMZW5ndGhzW2ldOyBqKyspIHtcbiAgICAgIHAgPSBjb2RlLnBvcCgpO1xuICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHZhbHVlc1trXTtcbiAgICAgIHdoaWxlIChwLmluZGV4ID4gMCkge1xuICAgICAgICBwID0gY29kZS5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHAuaW5kZXgrKztcbiAgICAgIGNvZGUucHVzaChwKTtcbiAgICAgIHdoaWxlIChjb2RlLmxlbmd0aCA8PSBpKSB7XG4gICAgICAgIGNvZGUucHVzaChxID0geyBjaGlsZHJlbjogW10sIGluZGV4OiAwIH0pO1xuICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gcS5jaGlsZHJlbjtcbiAgICAgICAgcCA9IHE7XG4gICAgICB9XG4gICAgICBrKys7XG4gICAgfVxuICAgIGlmIChpICsgMSA8IGxlbmd0aCkge1xuICAgICAgLy8gcCBoZXJlIHBvaW50cyB0byBsYXN0IGNvZGVcbiAgICAgIGNvZGUucHVzaChxID0geyBjaGlsZHJlbjogW10sIGluZGV4OiAwIH0pO1xuICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHEuY2hpbGRyZW47XG4gICAgICBwID0gcTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvZGVbMF0uY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGRlY29kZVNjYW4oZGF0YSwgaW5pdGlhbE9mZnNldCxcbiAgZnJhbWUsIGNvbXBvbmVudHMsIHJlc2V0SW50ZXJ2YWwsXG4gIHNwZWN0cmFsU3RhcnQsIHNwZWN0cmFsRW5kLFxuICBzdWNjZXNzaXZlUHJldiwgc3VjY2Vzc2l2ZSkge1xuICBjb25zdCB7IG1jdXNQZXJMaW5lLCBwcm9ncmVzc2l2ZSB9ID0gZnJhbWU7XG5cbiAgY29uc3Qgc3RhcnRPZmZzZXQgPSBpbml0aWFsT2Zmc2V0O1xuICBsZXQgb2Zmc2V0ID0gaW5pdGlhbE9mZnNldDtcbiAgbGV0IGJpdHNEYXRhID0gMDtcbiAgbGV0IGJpdHNDb3VudCA9IDA7XG4gIGZ1bmN0aW9uIHJlYWRCaXQoKSB7XG4gICAgaWYgKGJpdHNDb3VudCA+IDApIHtcbiAgICAgIGJpdHNDb3VudC0tO1xuICAgICAgcmV0dXJuIChiaXRzRGF0YSA+PiBiaXRzQ291bnQpICYgMTtcbiAgICB9XG4gICAgYml0c0RhdGEgPSBkYXRhW29mZnNldCsrXTtcbiAgICBpZiAoYml0c0RhdGEgPT09IDB4RkYpIHtcbiAgICAgIGNvbnN0IG5leHRCeXRlID0gZGF0YVtvZmZzZXQrK107XG4gICAgICBpZiAobmV4dEJ5dGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIG1hcmtlcjogJHsoKGJpdHNEYXRhIDw8IDgpIHwgbmV4dEJ5dGUpLnRvU3RyaW5nKDE2KX1gKTtcbiAgICAgIH1cbiAgICAgIC8vIHVuc3R1ZmYgMFxuICAgIH1cbiAgICBiaXRzQ291bnQgPSA3O1xuICAgIHJldHVybiBiaXRzRGF0YSA+Pj4gNztcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVIdWZmbWFuKHRyZWUpIHtcbiAgICBsZXQgbm9kZSA9IHRyZWU7XG4gICAgbGV0IGJpdDtcbiAgICB3aGlsZSAoKGJpdCA9IHJlYWRCaXQoKSkgIT09IG51bGwpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgbm9kZSA9IG5vZGVbYml0XTtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBodWZmbWFuIHNlcXVlbmNlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHJlY2VpdmUoaW5pdGlhbExlbmd0aCkge1xuICAgIGxldCBsZW5ndGggPSBpbml0aWFsTGVuZ3RoO1xuICAgIGxldCBuID0gMDtcbiAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYml0ID0gcmVhZEJpdCgpO1xuICAgICAgaWYgKGJpdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbiA9IChuIDw8IDEpIHwgYml0O1xuICAgICAgLS1sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIGZ1bmN0aW9uIHJlY2VpdmVBbmRFeHRlbmQobGVuZ3RoKSB7XG4gICAgY29uc3QgbiA9IHJlY2VpdmUobGVuZ3RoKTtcbiAgICBpZiAobiA+PSAxIDw8IChsZW5ndGggLSAxKSkge1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIHJldHVybiBuICsgKC0xIDw8IGxlbmd0aCkgKyAxO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUJhc2VsaW5lKGNvbXBvbmVudCwgenopIHtcbiAgICBjb25zdCB0ID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlREMpO1xuICAgIGNvbnN0IGRpZmYgPSB0ID09PSAwID8gMCA6IHJlY2VpdmVBbmRFeHRlbmQodCk7XG4gICAgY29tcG9uZW50LnByZWQgKz0gZGlmZjtcbiAgICB6elswXSA9IGNvbXBvbmVudC5wcmVkO1xuICAgIGxldCBrID0gMTtcbiAgICB3aGlsZSAoayA8IDY0KSB7XG4gICAgICBjb25zdCBycyA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDKTtcbiAgICAgIGNvbnN0IHMgPSBycyAmIDE1O1xuICAgICAgY29uc3QgciA9IHJzID4+IDQ7XG4gICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICBpZiAociA8IDE1KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgayArPSAxNjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsgKz0gcjtcbiAgICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1trXTtcbiAgICAgICAgenpbel0gPSByZWNlaXZlQW5kRXh0ZW5kKHMpO1xuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZURDRmlyc3QoY29tcG9uZW50LCB6eikge1xuICAgIGNvbnN0IHQgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyk7XG4gICAgY29uc3QgZGlmZiA9IHQgPT09IDAgPyAwIDogKHJlY2VpdmVBbmRFeHRlbmQodCkgPDwgc3VjY2Vzc2l2ZSk7XG4gICAgY29tcG9uZW50LnByZWQgKz0gZGlmZjtcbiAgICB6elswXSA9IGNvbXBvbmVudC5wcmVkO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZURDU3VjY2Vzc2l2ZShjb21wb25lbnQsIHp6KSB7XG4gICAgenpbMF0gfD0gcmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmU7XG4gIH1cbiAgbGV0IGVvYnJ1biA9IDA7XG4gIGZ1bmN0aW9uIGRlY29kZUFDRmlyc3QoY29tcG9uZW50LCB6eikge1xuICAgIGlmIChlb2JydW4gPiAwKSB7XG4gICAgICBlb2JydW4tLTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGsgPSBzcGVjdHJhbFN0YXJ0O1xuICAgIGNvbnN0IGUgPSBzcGVjdHJhbEVuZDtcbiAgICB3aGlsZSAoayA8PSBlKSB7XG4gICAgICBjb25zdCBycyA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDKTtcbiAgICAgIGNvbnN0IHMgPSBycyAmIDE1O1xuICAgICAgY29uc3QgciA9IHJzID4+IDQ7XG4gICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICBpZiAociA8IDE1KSB7XG4gICAgICAgICAgZW9icnVuID0gcmVjZWl2ZShyKSArICgxIDw8IHIpIC0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBrICs9IDE2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayArPSByO1xuICAgICAgICBjb25zdCB6ID0gZGN0WmlnWmFnW2tdO1xuICAgICAgICB6elt6XSA9IHJlY2VpdmVBbmRFeHRlbmQocykgKiAoMSA8PCBzdWNjZXNzaXZlKTtcbiAgICAgICAgaysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwO1xuICBsZXQgc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlO1xuICBmdW5jdGlvbiBkZWNvZGVBQ1N1Y2Nlc3NpdmUoY29tcG9uZW50LCB6eikge1xuICAgIGxldCBrID0gc3BlY3RyYWxTdGFydDtcbiAgICBjb25zdCBlID0gc3BlY3RyYWxFbmQ7XG4gICAgbGV0IHIgPSAwO1xuICAgIHdoaWxlIChrIDw9IGUpIHtcbiAgICAgIGNvbnN0IHogPSBkY3RaaWdaYWdba107XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSB6elt6XSA8IDAgPyAtMSA6IDE7XG4gICAgICBzd2l0Y2ggKHN1Y2Nlc3NpdmVBQ1N0YXRlKSB7XG4gICAgICAgIGNhc2UgMDogeyAvLyBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgY29uc3QgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XG4gICAgICAgICAgY29uc3QgcyA9IHJzICYgMTU7XG4gICAgICAgICAgciA9IHJzID4+IDQ7XG4gICAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChyIDwgMTUpIHtcbiAgICAgICAgICAgICAgZW9icnVuID0gcmVjZWl2ZShyKSArICgxIDw8IHIpO1xuICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByID0gMTY7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHMgIT09IDEpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEFDbiBlbmNvZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlID0gcmVjZWl2ZUFuZEV4dGVuZChzKTtcbiAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gciA/IDIgOiAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTogLy8gc2tpcHBpbmcgciB6ZXJvIGl0ZW1zXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpZiAoenpbel0pIHtcbiAgICAgICAgICAgIHp6W3pdICs9IChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSkgKiBkaXJlY3Rpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHItLTtcbiAgICAgICAgICAgIGlmIChyID09PSAwKSB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gc3VjY2Vzc2l2ZUFDU3RhdGUgPT09IDIgPyAzIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogLy8gc2V0IHZhbHVlIGZvciBhIHplcm8gaXRlbVxuICAgICAgICAgIGlmICh6elt6XSkge1xuICAgICAgICAgICAgenpbel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKSAqIGRpcmVjdGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgenpbel0gPSBzdWNjZXNzaXZlQUNOZXh0VmFsdWUgPDwgc3VjY2Vzc2l2ZTtcbiAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogLy8gZW9iXG4gICAgICAgICAgaWYgKHp6W3pdKSB7XG4gICAgICAgICAgICB6elt6XSArPSAocmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmUpICogZGlyZWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGsrKztcbiAgICB9XG4gICAgaWYgKHN1Y2Nlc3NpdmVBQ1N0YXRlID09PSA0KSB7XG4gICAgICBlb2JydW4tLTtcbiAgICAgIGlmIChlb2JydW4gPT09IDApIHtcbiAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVNY3UoY29tcG9uZW50LCBkZWNvZGVGdW5jdGlvbiwgbWN1LCByb3csIGNvbCkge1xuICAgIGNvbnN0IG1jdVJvdyA9IChtY3UgLyBtY3VzUGVyTGluZSkgfCAwO1xuICAgIGNvbnN0IG1jdUNvbCA9IG1jdSAlIG1jdXNQZXJMaW5lO1xuICAgIGNvbnN0IGJsb2NrUm93ID0gKG1jdVJvdyAqIGNvbXBvbmVudC52KSArIHJvdztcbiAgICBjb25zdCBibG9ja0NvbCA9IChtY3VDb2wgKiBjb21wb25lbnQuaCkgKyBjb2w7XG4gICAgZGVjb2RlRnVuY3Rpb24oY29tcG9uZW50LCBjb21wb25lbnQuYmxvY2tzW2Jsb2NrUm93XVtibG9ja0NvbF0pO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUJsb2NrKGNvbXBvbmVudCwgZGVjb2RlRnVuY3Rpb24sIG1jdSkge1xuICAgIGNvbnN0IGJsb2NrUm93ID0gKG1jdSAvIGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lKSB8IDA7XG4gICAgY29uc3QgYmxvY2tDb2wgPSBtY3UgJSBjb21wb25lbnQuYmxvY2tzUGVyTGluZTtcbiAgICBkZWNvZGVGdW5jdGlvbihjb21wb25lbnQsIGNvbXBvbmVudC5ibG9ja3NbYmxvY2tSb3ddW2Jsb2NrQ29sXSk7XG4gIH1cblxuICBjb25zdCBjb21wb25lbnRzTGVuZ3RoID0gY29tcG9uZW50cy5sZW5ndGg7XG4gIGxldCBjb21wb25lbnQ7XG4gIGxldCBpO1xuICBsZXQgajtcbiAgbGV0IGs7XG4gIGxldCBuO1xuICBsZXQgZGVjb2RlRm47XG4gIGlmIChwcm9ncmVzc2l2ZSkge1xuICAgIGlmIChzcGVjdHJhbFN0YXJ0ID09PSAwKSB7XG4gICAgICBkZWNvZGVGbiA9IHN1Y2Nlc3NpdmVQcmV2ID09PSAwID8gZGVjb2RlRENGaXJzdCA6IGRlY29kZURDU3VjY2Vzc2l2ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjb2RlRm4gPSBzdWNjZXNzaXZlUHJldiA9PT0gMCA/IGRlY29kZUFDRmlyc3QgOiBkZWNvZGVBQ1N1Y2Nlc3NpdmU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlY29kZUZuID0gZGVjb2RlQmFzZWxpbmU7XG4gIH1cblxuICBsZXQgbWN1ID0gMDtcbiAgbGV0IG1hcmtlcjtcbiAgbGV0IG1jdUV4cGVjdGVkO1xuICBpZiAoY29tcG9uZW50c0xlbmd0aCA9PT0gMSkge1xuICAgIG1jdUV4cGVjdGVkID0gY29tcG9uZW50c1swXS5ibG9ja3NQZXJMaW5lICogY29tcG9uZW50c1swXS5ibG9ja3NQZXJDb2x1bW47XG4gIH0gZWxzZSB7XG4gICAgbWN1RXhwZWN0ZWQgPSBtY3VzUGVyTGluZSAqIGZyYW1lLm1jdXNQZXJDb2x1bW47XG4gIH1cblxuICBjb25zdCB1c2VkUmVzZXRJbnRlcnZhbCA9IHJlc2V0SW50ZXJ2YWwgfHwgbWN1RXhwZWN0ZWQ7XG5cbiAgd2hpbGUgKG1jdSA8IG1jdUV4cGVjdGVkKSB7XG4gICAgLy8gcmVzZXQgaW50ZXJ2YWwgc3R1ZmZcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29tcG9uZW50c0xlbmd0aDsgaSsrKSB7XG4gICAgICBjb21wb25lbnRzW2ldLnByZWQgPSAwO1xuICAgIH1cbiAgICBlb2JydW4gPSAwO1xuXG4gICAgaWYgKGNvbXBvbmVudHNMZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbMF07XG4gICAgICBmb3IgKG4gPSAwOyBuIDwgdXNlZFJlc2V0SW50ZXJ2YWw7IG4rKykge1xuICAgICAgICBkZWNvZGVCbG9jayhjb21wb25lbnQsIGRlY29kZUZuLCBtY3UpO1xuICAgICAgICBtY3UrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChuID0gMDsgbiA8IHVzZWRSZXNldEludGVydmFsOyBuKyspIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBvbmVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgY29uc3QgeyBoLCB2IH0gPSBjb21wb25lbnQ7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IHY7IGorKykge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGg7IGsrKykge1xuICAgICAgICAgICAgICBkZWNvZGVNY3UoY29tcG9uZW50LCBkZWNvZGVGbiwgbWN1LCBqLCBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWN1Kys7XG5cbiAgICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCBvdXIgZXhwZWN0ZWQgTUNVJ3MsIHN0b3AgZGVjb2RpbmdcbiAgICAgICAgaWYgKG1jdSA9PT0gbWN1RXhwZWN0ZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbmQgbWFya2VyXG4gICAgYml0c0NvdW50ID0gMDtcbiAgICBtYXJrZXIgPSAoZGF0YVtvZmZzZXRdIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAxXTtcbiAgICBpZiAobWFya2VyIDwgMHhGRjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlciB3YXMgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlciA+PSAweEZGRDAgJiYgbWFya2VyIDw9IDB4RkZENykgeyAvLyBSU1R4XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBidWlsZENvbXBvbmVudERhdGEoZnJhbWUsIGNvbXBvbmVudCkge1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICBjb25zdCB7IGJsb2Nrc1BlckxpbmUsIGJsb2Nrc1BlckNvbHVtbiB9ID0gY29tcG9uZW50O1xuICBjb25zdCBzYW1wbGVzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmUgPDwgMztcbiAgY29uc3QgUiA9IG5ldyBJbnQzMkFycmF5KDY0KTtcbiAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KDY0KTtcblxuICAvLyBBIHBvcnQgb2YgcG9wcGxlcidzIElEQ1QgbWV0aG9kIHdoaWNoIGluIHR1cm4gaXMgdGFrZW4gZnJvbTpcbiAgLy8gICBDaHJpc3RvcGggTG9lZmZsZXIsIEFkcmlhYW4gTGlndGVuYmVyZywgR2VvcmdlIFMuIE1vc2NoeXR6LFxuICAvLyAgIFwiUHJhY3RpY2FsIEZhc3QgMS1EIERDVCBBbGdvcml0aG1zIHdpdGggMTEgTXVsdGlwbGljYXRpb25zXCIsXG4gIC8vICAgSUVFRSBJbnRsLiBDb25mLiBvbiBBY291c3RpY3MsIFNwZWVjaCAmIFNpZ25hbCBQcm9jZXNzaW5nLCAxOTg5LFxuICAvLyAgIDk4OC05OTEuXG4gIGZ1bmN0aW9uIHF1YW50aXplQW5kSW52ZXJzZSh6eiwgZGF0YU91dCwgZGF0YUluKSB7XG4gICAgY29uc3QgcXQgPSBjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGU7XG4gICAgbGV0IHYwO1xuICAgIGxldCB2MTtcbiAgICBsZXQgdjI7XG4gICAgbGV0IHYzO1xuICAgIGxldCB2NDtcbiAgICBsZXQgdjU7XG4gICAgbGV0IHY2O1xuICAgIGxldCB2NztcbiAgICBsZXQgdDtcbiAgICBjb25zdCBwID0gZGF0YUluO1xuICAgIGxldCBpO1xuXG4gICAgLy8gZGVxdWFudFxuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICBwW2ldID0genpbaV0gKiBxdFtpXTtcbiAgICB9XG5cbiAgICAvLyBpbnZlcnNlIERDVCBvbiByb3dzXG4gICAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgY29uc3Qgcm93ID0gOCAqIGk7XG5cbiAgICAgIC8vIGNoZWNrIGZvciBhbGwtemVybyBBQyBjb2VmZmljaWVudHNcbiAgICAgIGlmIChwWzEgKyByb3ddID09PSAwICYmIHBbMiArIHJvd10gPT09IDAgJiYgcFszICsgcm93XSA9PT0gMFxuICAgICAgICAmJiBwWzQgKyByb3ddID09PSAwICYmIHBbNSArIHJvd10gPT09IDAgJiYgcFs2ICsgcm93XSA9PT0gMFxuICAgICAgICAmJiBwWzcgKyByb3ddID09PSAwKSB7XG4gICAgICAgIHQgPSAoKGRjdFNxcnQyICogcFswICsgcm93XSkgKyA1MTIpID4+IDEwO1xuICAgICAgICBwWzAgKyByb3ddID0gdDtcbiAgICAgICAgcFsxICsgcm93XSA9IHQ7XG4gICAgICAgIHBbMiArIHJvd10gPSB0O1xuICAgICAgICBwWzMgKyByb3ddID0gdDtcbiAgICAgICAgcFs0ICsgcm93XSA9IHQ7XG4gICAgICAgIHBbNSArIHJvd10gPSB0O1xuICAgICAgICBwWzYgKyByb3ddID0gdDtcbiAgICAgICAgcFs3ICsgcm93XSA9IHQ7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHN0YWdlIDRcbiAgICAgIHYwID0gKChkY3RTcXJ0MiAqIHBbMCArIHJvd10pICsgMTI4KSA+PiA4O1xuICAgICAgdjEgPSAoKGRjdFNxcnQyICogcFs0ICsgcm93XSkgKyAxMjgpID4+IDg7XG4gICAgICB2MiA9IHBbMiArIHJvd107XG4gICAgICB2MyA9IHBbNiArIHJvd107XG4gICAgICB2NCA9ICgoZGN0U3FydDFkMiAqIChwWzEgKyByb3ddIC0gcFs3ICsgcm93XSkpICsgMTI4KSA+PiA4O1xuICAgICAgdjcgPSAoKGRjdFNxcnQxZDIgKiAocFsxICsgcm93XSArIHBbNyArIHJvd10pKSArIDEyOCkgPj4gODtcbiAgICAgIHY1ID0gcFszICsgcm93XSA8PCA0O1xuICAgICAgdjYgPSBwWzUgKyByb3ddIDw8IDQ7XG5cbiAgICAgIC8vIHN0YWdlIDNcbiAgICAgIHQgPSAodjAgLSB2MSArIDEpID4+IDE7XG4gICAgICB2MCA9ICh2MCArIHYxICsgMSkgPj4gMTtcbiAgICAgIHYxID0gdDtcbiAgICAgIHQgPSAoKHYyICogZGN0U2luNikgKyAodjMgKiBkY3RDb3M2KSArIDEyOCkgPj4gODtcbiAgICAgIHYyID0gKCh2MiAqIGRjdENvczYpIC0gKHYzICogZGN0U2luNikgKyAxMjgpID4+IDg7XG4gICAgICB2MyA9IHQ7XG4gICAgICB0ID0gKHY0IC0gdjYgKyAxKSA+PiAxO1xuICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7XG4gICAgICB2NiA9IHQ7XG4gICAgICB0ID0gKHY3ICsgdjUgKyAxKSA+PiAxO1xuICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7XG4gICAgICB2NyA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDJcbiAgICAgIHQgPSAodjAgLSB2MyArIDEpID4+IDE7XG4gICAgICB2MCA9ICh2MCArIHYzICsgMSkgPj4gMTtcbiAgICAgIHYzID0gdDtcbiAgICAgIHQgPSAodjEgLSB2MiArIDEpID4+IDE7XG4gICAgICB2MSA9ICh2MSArIHYyICsgMSkgPj4gMTtcbiAgICAgIHYyID0gdDtcbiAgICAgIHQgPSAoKHY0ICogZGN0U2luMykgKyAodjcgKiBkY3RDb3MzKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjQgPSAoKHY0ICogZGN0Q29zMykgLSAodjcgKiBkY3RTaW4zKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjcgPSB0O1xuICAgICAgdCA9ICgodjUgKiBkY3RTaW4xKSArICh2NiAqIGRjdENvczEpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NSA9ICgodjUgKiBkY3RDb3MxKSAtICh2NiAqIGRjdFNpbjEpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NiA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDFcbiAgICAgIHBbMCArIHJvd10gPSB2MCArIHY3O1xuICAgICAgcFs3ICsgcm93XSA9IHYwIC0gdjc7XG4gICAgICBwWzEgKyByb3ddID0gdjEgKyB2NjtcbiAgICAgIHBbNiArIHJvd10gPSB2MSAtIHY2O1xuICAgICAgcFsyICsgcm93XSA9IHYyICsgdjU7XG4gICAgICBwWzUgKyByb3ddID0gdjIgLSB2NTtcbiAgICAgIHBbMyArIHJvd10gPSB2MyArIHY0O1xuICAgICAgcFs0ICsgcm93XSA9IHYzIC0gdjQ7XG4gICAgfVxuXG4gICAgLy8gaW52ZXJzZSBEQ1Qgb24gY29sdW1uc1xuICAgIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICAgIGNvbnN0IGNvbCA9IGk7XG5cbiAgICAgIC8vIGNoZWNrIGZvciBhbGwtemVybyBBQyBjb2VmZmljaWVudHNcbiAgICAgIGlmIChwWygxICogOCkgKyBjb2xdID09PSAwICYmIHBbKDIgKiA4KSArIGNvbF0gPT09IDAgJiYgcFsoMyAqIDgpICsgY29sXSA9PT0gMFxuICAgICAgICAmJiBwWyg0ICogOCkgKyBjb2xdID09PSAwICYmIHBbKDUgKiA4KSArIGNvbF0gPT09IDAgJiYgcFsoNiAqIDgpICsgY29sXSA9PT0gMFxuICAgICAgICAmJiBwWyg3ICogOCkgKyBjb2xdID09PSAwKSB7XG4gICAgICAgIHQgPSAoKGRjdFNxcnQyICogZGF0YUluW2kgKyAwXSkgKyA4MTkyKSA+PiAxNDtcbiAgICAgICAgcFsoMCAqIDgpICsgY29sXSA9IHQ7XG4gICAgICAgIHBbKDEgKiA4KSArIGNvbF0gPSB0O1xuICAgICAgICBwWygyICogOCkgKyBjb2xdID0gdDtcbiAgICAgICAgcFsoMyAqIDgpICsgY29sXSA9IHQ7XG4gICAgICAgIHBbKDQgKiA4KSArIGNvbF0gPSB0O1xuICAgICAgICBwWyg1ICogOCkgKyBjb2xdID0gdDtcbiAgICAgICAgcFsoNiAqIDgpICsgY29sXSA9IHQ7XG4gICAgICAgIHBbKDcgKiA4KSArIGNvbF0gPSB0O1xuICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyBzdGFnZSA0XG4gICAgICB2MCA9ICgoZGN0U3FydDIgKiBwWygwICogOCkgKyBjb2xdKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjEgPSAoKGRjdFNxcnQyICogcFsoNCAqIDgpICsgY29sXSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHYyID0gcFsoMiAqIDgpICsgY29sXTtcbiAgICAgIHYzID0gcFsoNiAqIDgpICsgY29sXTtcbiAgICAgIHY0ID0gKChkY3RTcXJ0MWQyICogKHBbKDEgKiA4KSArIGNvbF0gLSBwWyg3ICogOCkgKyBjb2xdKSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY3ID0gKChkY3RTcXJ0MWQyICogKHBbKDEgKiA4KSArIGNvbF0gKyBwWyg3ICogOCkgKyBjb2xdKSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY1ID0gcFsoMyAqIDgpICsgY29sXTtcbiAgICAgIHY2ID0gcFsoNSAqIDgpICsgY29sXTtcblxuICAgICAgLy8gc3RhZ2UgM1xuICAgICAgdCA9ICh2MCAtIHYxICsgMSkgPj4gMTtcbiAgICAgIHYwID0gKHYwICsgdjEgKyAxKSA+PiAxO1xuICAgICAgdjEgPSB0O1xuICAgICAgdCA9ICgodjIgKiBkY3RTaW42KSArICh2MyAqIGRjdENvczYpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2MiA9ICgodjIgKiBkY3RDb3M2KSAtICh2MyAqIGRjdFNpbjYpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2MyA9IHQ7XG4gICAgICB0ID0gKHY0IC0gdjYgKyAxKSA+PiAxO1xuICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7XG4gICAgICB2NiA9IHQ7XG4gICAgICB0ID0gKHY3ICsgdjUgKyAxKSA+PiAxO1xuICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7XG4gICAgICB2NyA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDJcbiAgICAgIHQgPSAodjAgLSB2MyArIDEpID4+IDE7XG4gICAgICB2MCA9ICh2MCArIHYzICsgMSkgPj4gMTtcbiAgICAgIHYzID0gdDtcbiAgICAgIHQgPSAodjEgLSB2MiArIDEpID4+IDE7XG4gICAgICB2MSA9ICh2MSArIHYyICsgMSkgPj4gMTtcbiAgICAgIHYyID0gdDtcbiAgICAgIHQgPSAoKHY0ICogZGN0U2luMykgKyAodjcgKiBkY3RDb3MzKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjQgPSAoKHY0ICogZGN0Q29zMykgLSAodjcgKiBkY3RTaW4zKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjcgPSB0O1xuICAgICAgdCA9ICgodjUgKiBkY3RTaW4xKSArICh2NiAqIGRjdENvczEpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NSA9ICgodjUgKiBkY3RDb3MxKSAtICh2NiAqIGRjdFNpbjEpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NiA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDFcbiAgICAgIHBbKDAgKiA4KSArIGNvbF0gPSB2MCArIHY3O1xuICAgICAgcFsoNyAqIDgpICsgY29sXSA9IHYwIC0gdjc7XG4gICAgICBwWygxICogOCkgKyBjb2xdID0gdjEgKyB2NjtcbiAgICAgIHBbKDYgKiA4KSArIGNvbF0gPSB2MSAtIHY2O1xuICAgICAgcFsoMiAqIDgpICsgY29sXSA9IHYyICsgdjU7XG4gICAgICBwWyg1ICogOCkgKyBjb2xdID0gdjIgLSB2NTtcbiAgICAgIHBbKDMgKiA4KSArIGNvbF0gPSB2MyArIHY0O1xuICAgICAgcFsoNCAqIDgpICsgY29sXSA9IHYzIC0gdjQ7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCB0byA4LWJpdCBpbnRlZ2Vyc1xuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICBjb25zdCBzYW1wbGUgPSAxMjggKyAoKHBbaV0gKyA4KSA+PiA0KTtcbiAgICAgIGlmIChzYW1wbGUgPCAwKSB7XG4gICAgICAgIGRhdGFPdXRbaV0gPSAwO1xuICAgICAgfSBlbHNlIGlmIChzYW1wbGUgPiAwWEZGKSB7XG4gICAgICAgIGRhdGFPdXRbaV0gPSAweEZGO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YU91dFtpXSA9IHNhbXBsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBibG9ja1JvdyA9IDA7IGJsb2NrUm93IDwgYmxvY2tzUGVyQ29sdW1uOyBibG9ja1JvdysrKSB7XG4gICAgY29uc3Qgc2NhbkxpbmUgPSBibG9ja1JvdyA8PCAzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBsaW5lcy5wdXNoKG5ldyBVaW50OEFycmF5KHNhbXBsZXNQZXJMaW5lKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGJsb2NrQ29sID0gMDsgYmxvY2tDb2wgPCBibG9ja3NQZXJMaW5lOyBibG9ja0NvbCsrKSB7XG4gICAgICBxdWFudGl6ZUFuZEludmVyc2UoY29tcG9uZW50LmJsb2Nrc1tibG9ja1Jvd11bYmxvY2tDb2xdLCByLCBSKTtcblxuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBjb25zdCBzYW1wbGUgPSBibG9ja0NvbCA8PCAzO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW3NjYW5MaW5lICsgal07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgbGluZVtzYW1wbGUgKyBpXSA9IHJbb2Zmc2V0KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBsaW5lcztcbn1cblxuY2xhc3MgSnBlZ1N0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuamZpZiA9IG51bGw7XG4gICAgdGhpcy5hZG9iZSA9IG51bGw7XG5cbiAgICB0aGlzLnF1YW50aXphdGlvblRhYmxlcyA9IFtdO1xuICAgIHRoaXMuaHVmZm1hblRhYmxlc0FDID0gW107XG4gICAgdGhpcy5odWZmbWFuVGFibGVzREMgPSBbXTtcbiAgICB0aGlzLnJlc2V0RnJhbWVzKCk7XG4gIH1cblxuICByZXNldEZyYW1lcygpIHtcbiAgICB0aGlzLmZyYW1lcyA9IFtdO1xuICB9XG5cbiAgcGFyc2UoZGF0YSkge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIC8vIGNvbnN0IHsgbGVuZ3RoIH0gPSBkYXRhO1xuICAgIGZ1bmN0aW9uIHJlYWRVaW50MTYoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IChkYXRhW29mZnNldF0gPDwgOCkgfCBkYXRhW29mZnNldCArIDFdO1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWREYXRhQmxvY2soKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSByZWFkVWludDE2KCk7XG4gICAgICBjb25zdCBhcnJheSA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGggLSAyKTtcbiAgICAgIG9mZnNldCArPSBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb21wb25lbnRzKGZyYW1lKSB7XG4gICAgICBsZXQgbWF4SCA9IDA7XG4gICAgICBsZXQgbWF4ViA9IDA7XG4gICAgICBsZXQgY29tcG9uZW50O1xuICAgICAgbGV0IGNvbXBvbmVudElkO1xuICAgICAgZm9yIChjb21wb25lbnRJZCBpbiBmcmFtZS5jb21wb25lbnRzKSB7XG4gICAgICAgIGlmIChmcmFtZS5jb21wb25lbnRzLmhhc093blByb3BlcnR5KGNvbXBvbmVudElkKSkge1xuICAgICAgICAgIGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbY29tcG9uZW50SWRdO1xuICAgICAgICAgIGlmIChtYXhIIDwgY29tcG9uZW50LmgpIHtcbiAgICAgICAgICAgIG1heEggPSBjb21wb25lbnQuaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heFYgPCBjb21wb25lbnQudikge1xuICAgICAgICAgICAgbWF4ViA9IGNvbXBvbmVudC52O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbWN1c1BlckxpbmUgPSBNYXRoLmNlaWwoZnJhbWUuc2FtcGxlc1BlckxpbmUgLyA4IC8gbWF4SCk7XG4gICAgICBjb25zdCBtY3VzUGVyQ29sdW1uID0gTWF0aC5jZWlsKGZyYW1lLnNjYW5MaW5lcyAvIDggLyBtYXhWKTtcbiAgICAgIGZvciAoY29tcG9uZW50SWQgaW4gZnJhbWUuY29tcG9uZW50cykge1xuICAgICAgICBpZiAoZnJhbWUuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnRJZCkpIHtcbiAgICAgICAgICBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2NvbXBvbmVudElkXTtcbiAgICAgICAgICBjb25zdCBibG9ja3NQZXJMaW5lID0gTWF0aC5jZWlsKE1hdGguY2VpbChmcmFtZS5zYW1wbGVzUGVyTGluZSAvIDgpICogY29tcG9uZW50LmggLyBtYXhIKTtcbiAgICAgICAgICBjb25zdCBibG9ja3NQZXJDb2x1bW4gPSBNYXRoLmNlaWwoTWF0aC5jZWlsKGZyYW1lLnNjYW5MaW5lcyAvIDgpICogY29tcG9uZW50LnYgLyBtYXhWKTtcbiAgICAgICAgICBjb25zdCBibG9ja3NQZXJMaW5lRm9yTWN1ID0gbWN1c1BlckxpbmUgKiBjb21wb25lbnQuaDtcbiAgICAgICAgICBjb25zdCBibG9ja3NQZXJDb2x1bW5Gb3JNY3UgPSBtY3VzUGVyQ29sdW1uICogY29tcG9uZW50LnY7XG4gICAgICAgICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3NQZXJDb2x1bW5Gb3JNY3U7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2Nrc1BlckxpbmVGb3JNY3U7IGorKykge1xuICAgICAgICAgICAgICByb3cucHVzaChuZXcgSW50MzJBcnJheSg2NCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2tzLnB1c2gocm93KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcG9uZW50LmJsb2Nrc1BlckxpbmUgPSBibG9ja3NQZXJMaW5lO1xuICAgICAgICAgIGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW4gPSBibG9ja3NQZXJDb2x1bW47XG4gICAgICAgICAgY29tcG9uZW50LmJsb2NrcyA9IGJsb2NrcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnJhbWUubWF4SCA9IG1heEg7XG4gICAgICBmcmFtZS5tYXhWID0gbWF4VjtcbiAgICAgIGZyYW1lLm1jdXNQZXJMaW5lID0gbWN1c1BlckxpbmU7XG4gICAgICBmcmFtZS5tY3VzUGVyQ29sdW1uID0gbWN1c1BlckNvbHVtbjtcbiAgICB9XG5cbiAgICBsZXQgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTtcbiAgICBpZiAoZmlsZU1hcmtlciAhPT0gMHhGRkQ4KSB7IC8vIFNPSSAoU3RhcnQgb2YgSW1hZ2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NPSSBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBmaWxlTWFya2VyID0gcmVhZFVpbnQxNigpO1xuICAgIHdoaWxlIChmaWxlTWFya2VyICE9PSAweEZGRDkpIHsgLy8gRU9JIChFbmQgb2YgaW1hZ2UpXG4gICAgICBzd2l0Y2ggKGZpbGVNYXJrZXIpIHtcbiAgICAgICAgY2FzZSAweEZGMDA6IGJyZWFrO1xuICAgICAgICBjYXNlIDB4RkZFMDogLy8gQVBQMCAoQXBwbGljYXRpb24gU3BlY2lmaWMpXG4gICAgICAgIGNhc2UgMHhGRkUxOiAvLyBBUFAxXG4gICAgICAgIGNhc2UgMHhGRkUyOiAvLyBBUFAyXG4gICAgICAgIGNhc2UgMHhGRkUzOiAvLyBBUFAzXG4gICAgICAgIGNhc2UgMHhGRkU0OiAvLyBBUFA0XG4gICAgICAgIGNhc2UgMHhGRkU1OiAvLyBBUFA1XG4gICAgICAgIGNhc2UgMHhGRkU2OiAvLyBBUFA2XG4gICAgICAgIGNhc2UgMHhGRkU3OiAvLyBBUFA3XG4gICAgICAgIGNhc2UgMHhGRkU4OiAvLyBBUFA4XG4gICAgICAgIGNhc2UgMHhGRkU5OiAvLyBBUFA5XG4gICAgICAgIGNhc2UgMHhGRkVBOiAvLyBBUFAxMFxuICAgICAgICBjYXNlIDB4RkZFQjogLy8gQVBQMTFcbiAgICAgICAgY2FzZSAweEZGRUM6IC8vIEFQUDEyXG4gICAgICAgIGNhc2UgMHhGRkVEOiAvLyBBUFAxM1xuICAgICAgICBjYXNlIDB4RkZFRTogLy8gQVBQMTRcbiAgICAgICAgY2FzZSAweEZGRUY6IC8vIEFQUDE1XG4gICAgICAgIGNhc2UgMHhGRkZFOiB7IC8vIENPTSAoQ29tbWVudClcbiAgICAgICAgICBjb25zdCBhcHBEYXRhID0gcmVhZERhdGFCbG9jaygpO1xuXG4gICAgICAgICAgaWYgKGZpbGVNYXJrZXIgPT09IDB4RkZFMCkge1xuICAgICAgICAgICAgaWYgKGFwcERhdGFbMF0gPT09IDB4NEEgJiYgYXBwRGF0YVsxXSA9PT0gMHg0NiAmJiBhcHBEYXRhWzJdID09PSAweDQ5XG4gICAgICAgICAgICAgICYmIGFwcERhdGFbM10gPT09IDB4NDYgJiYgYXBwRGF0YVs0XSA9PT0gMCkgeyAvLyAnSkZJRlxceDAwJ1xuICAgICAgICAgICAgICB0aGlzLmpmaWYgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogeyBtYWpvcjogYXBwRGF0YVs1XSwgbWlub3I6IGFwcERhdGFbNl0gfSxcbiAgICAgICAgICAgICAgICBkZW5zaXR5VW5pdHM6IGFwcERhdGFbN10sXG4gICAgICAgICAgICAgICAgeERlbnNpdHk6IChhcHBEYXRhWzhdIDw8IDgpIHwgYXBwRGF0YVs5XSxcbiAgICAgICAgICAgICAgICB5RGVuc2l0eTogKGFwcERhdGFbMTBdIDw8IDgpIHwgYXBwRGF0YVsxMV0sXG4gICAgICAgICAgICAgICAgdGh1bWJXaWR0aDogYXBwRGF0YVsxMl0sXG4gICAgICAgICAgICAgICAgdGh1bWJIZWlnaHQ6IGFwcERhdGFbMTNdLFxuICAgICAgICAgICAgICAgIHRodW1iRGF0YTogYXBwRGF0YS5zdWJhcnJheSgxNCwgMTQgKyAoMyAqIGFwcERhdGFbMTJdICogYXBwRGF0YVsxM10pKSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVE9ETyBBUFAxIC0gRXhpZlxuICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRUUpIHtcbiAgICAgICAgICAgIGlmIChhcHBEYXRhWzBdID09PSAweDQxICYmIGFwcERhdGFbMV0gPT09IDB4NjQgJiYgYXBwRGF0YVsyXSA9PT0gMHg2RlxuICAgICAgICAgICAgICAmJiBhcHBEYXRhWzNdID09PSAweDYyICYmIGFwcERhdGFbNF0gPT09IDB4NjUgJiYgYXBwRGF0YVs1XSA9PT0gMCkgeyAvLyAnQWRvYmVcXHgwMCdcbiAgICAgICAgICAgICAgdGhpcy5hZG9iZSA9IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBhcHBEYXRhWzZdLFxuICAgICAgICAgICAgICAgIGZsYWdzMDogKGFwcERhdGFbN10gPDwgOCkgfCBhcHBEYXRhWzhdLFxuICAgICAgICAgICAgICAgIGZsYWdzMTogKGFwcERhdGFbOV0gPDwgOCkgfCBhcHBEYXRhWzEwXSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Db2RlOiBhcHBEYXRhWzExXSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIDB4RkZEQjogeyAvLyBEUVQgKERlZmluZSBRdWFudGl6YXRpb24gVGFibGVzKVxuICAgICAgICAgIGNvbnN0IHF1YW50aXphdGlvblRhYmxlc0xlbmd0aCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICBjb25zdCBxdWFudGl6YXRpb25UYWJsZXNFbmQgPSBxdWFudGl6YXRpb25UYWJsZXNMZW5ndGggKyBvZmZzZXQgLSAyO1xuICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBxdWFudGl6YXRpb25UYWJsZXNFbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXphdGlvblRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgY29uc3QgdGFibGVEYXRhID0gbmV3IEludDMyQXJyYXkoNjQpO1xuICAgICAgICAgICAgaWYgKChxdWFudGl6YXRpb25UYWJsZVNwZWMgPj4gNCkgPT09IDApIHsgLy8gOCBiaXQgdmFsdWVzXG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBkY3RaaWdaYWdbal07XG4gICAgICAgICAgICAgICAgdGFibGVEYXRhW3pdID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHF1YW50aXphdGlvblRhYmxlU3BlYyA+PiA0KSA9PT0gMSkgeyAvLyAxNiBiaXRcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1tqXTtcbiAgICAgICAgICAgICAgICB0YWJsZURhdGFbel0gPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRFFUOiBpbnZhbGlkIHRhYmxlIHNwZWMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucXVhbnRpemF0aW9uVGFibGVzW3F1YW50aXphdGlvblRhYmxlU3BlYyAmIDE1XSA9IHRhYmxlRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIDB4RkZDMDogLy8gU09GMCAoU3RhcnQgb2YgRnJhbWUsIEJhc2VsaW5lIERDVClcbiAgICAgICAgY2FzZSAweEZGQzE6IC8vIFNPRjEgKFN0YXJ0IG9mIEZyYW1lLCBFeHRlbmRlZCBEQ1QpXG4gICAgICAgIGNhc2UgMHhGRkMyOiB7IC8vIFNPRjIgKFN0YXJ0IG9mIEZyYW1lLCBQcm9ncmVzc2l2ZSBEQ1QpXG4gICAgICAgICAgcmVhZFVpbnQxNigpOyAvLyBza2lwIGRhdGEgbGVuZ3RoXG4gICAgICAgICAgY29uc3QgZnJhbWUgPSB7XG4gICAgICAgICAgICBleHRlbmRlZDogKGZpbGVNYXJrZXIgPT09IDB4RkZDMSksXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZTogKGZpbGVNYXJrZXIgPT09IDB4RkZDMiksXG4gICAgICAgICAgICBwcmVjaXNpb246IGRhdGFbb2Zmc2V0KytdLFxuICAgICAgICAgICAgc2NhbkxpbmVzOiByZWFkVWludDE2KCksXG4gICAgICAgICAgICBzYW1wbGVzUGVyTGluZTogcmVhZFVpbnQxNigpLFxuICAgICAgICAgICAgY29tcG9uZW50czoge30sXG4gICAgICAgICAgICBjb21wb25lbnRzT3JkZXI6IFtdLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBjb21wb25lbnRzQ291bnQgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50SWQ7XG4gICAgICAgICAgLy8gbGV0IG1heEggPSAwO1xuICAgICAgICAgIC8vIGxldCBtYXhWID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb21wb25lbnRJZCA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgIGNvbnN0IGggPSBkYXRhW29mZnNldCArIDFdID4+IDQ7XG4gICAgICAgICAgICBjb25zdCB2ID0gZGF0YVtvZmZzZXQgKyAxXSAmIDE1O1xuICAgICAgICAgICAgY29uc3QgcUlkID0gZGF0YVtvZmZzZXQgKyAyXTtcbiAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudHNPcmRlci5wdXNoKGNvbXBvbmVudElkKTtcbiAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudHNbY29tcG9uZW50SWRdID0ge1xuICAgICAgICAgICAgICBoLFxuICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICBxdWFudGl6YXRpb25JZHg6IHFJZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvZmZzZXQgKz0gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJlcGFyZUNvbXBvbmVudHMoZnJhbWUpO1xuICAgICAgICAgIHRoaXMuZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAweEZGQzQ6IHsgLy8gREhUIChEZWZpbmUgSHVmZm1hbiBUYWJsZXMpXG4gICAgICAgICAgY29uc3QgaHVmZm1hbkxlbmd0aCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGh1ZmZtYW5MZW5ndGg7KSB7XG4gICAgICAgICAgICBjb25zdCBodWZmbWFuVGFibGVTcGVjID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICBjb25zdCBjb2RlTGVuZ3RocyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgICAgIGxldCBjb2RlTGVuZ3RoU3VtID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7IGorKywgb2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgY29kZUxlbmd0aHNbal0gPSBkYXRhW29mZnNldF07XG4gICAgICAgICAgICAgIGNvZGVMZW5ndGhTdW0gKz0gY29kZUxlbmd0aHNbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBodWZmbWFuVmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoY29kZUxlbmd0aFN1bSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvZGVMZW5ndGhTdW07IGorKywgb2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgaHVmZm1hblZhbHVlc1tqXSA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gMTcgKyBjb2RlTGVuZ3RoU3VtO1xuXG4gICAgICAgICAgICBpZiAoKGh1ZmZtYW5UYWJsZVNwZWMgPj4gNCkgPT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5odWZmbWFuVGFibGVzRENbaHVmZm1hblRhYmxlU3BlYyAmIDE1XSA9IGJ1aWxkSHVmZm1hblRhYmxlKFxuICAgICAgICAgICAgICAgIGNvZGVMZW5ndGhzLCBodWZmbWFuVmFsdWVzLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5odWZmbWFuVGFibGVzQUNbaHVmZm1hblRhYmxlU3BlYyAmIDE1XSA9IGJ1aWxkSHVmZm1hblRhYmxlKFxuICAgICAgICAgICAgICAgIGNvZGVMZW5ndGhzLCBodWZmbWFuVmFsdWVzLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgMHhGRkREOiAvLyBEUkkgKERlZmluZSBSZXN0YXJ0IEludGVydmFsKVxuICAgICAgICAgIHJlYWRVaW50MTYoKTsgLy8gc2tpcCBkYXRhIGxlbmd0aFxuICAgICAgICAgIHRoaXMucmVzZXRJbnRlcnZhbCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDB4RkZEQTogeyAvLyBTT1MgKFN0YXJ0IG9mIFNjYW4pXG4gICAgICAgICAgcmVhZFVpbnQxNigpOyAvLyBza2lwIGxlbmd0aFxuICAgICAgICAgIGNvbnN0IHNlbGVjdG9yc0NvdW50ID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5mcmFtZXNbMF07XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RvcnNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2RhdGFbb2Zmc2V0KytdXTtcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgY29tcG9uZW50Lmh1ZmZtYW5UYWJsZURDID0gdGhpcy5odWZmbWFuVGFibGVzRENbdGFibGVTcGVjID4+IDRdO1xuICAgICAgICAgICAgY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDID0gdGhpcy5odWZmbWFuVGFibGVzQUNbdGFibGVTcGVjICYgMTVdO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNwZWN0cmFsU3RhcnQgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICBjb25zdCBzcGVjdHJhbEVuZCA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NpdmVBcHByb3hpbWF0aW9uID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZGVjb2RlU2NhbihkYXRhLCBvZmZzZXQsXG4gICAgICAgICAgICBmcmFtZSwgY29tcG9uZW50cywgdGhpcy5yZXNldEludGVydmFsLFxuICAgICAgICAgICAgc3BlY3RyYWxTdGFydCwgc3BlY3RyYWxFbmQsXG4gICAgICAgICAgICBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiA+PiA0LCBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiAmIDE1KTtcbiAgICAgICAgICBvZmZzZXQgKz0gcHJvY2Vzc2VkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAweEZGRkY6IC8vIEZpbGwgYnl0ZXNcbiAgICAgICAgICBpZiAoZGF0YVtvZmZzZXRdICE9PSAweEZGKSB7IC8vIEF2b2lkIHNraXBwaW5nIGEgdmFsaWQgbWFya2VyLlxuICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0IC0gM10gPT09IDB4RkZcbiAgICAgICAgICAgICYmIGRhdGFbb2Zmc2V0IC0gMl0gPj0gMHhDMCAmJiBkYXRhW29mZnNldCAtIDJdIDw9IDB4RkUpIHtcbiAgICAgICAgICAgIC8vIGNvdWxkIGJlIGluY29ycmVjdCBlbmNvZGluZyAtLSBsYXN0IDB4RkYgYnl0ZSBvZiB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIC8vIGJsb2NrIHdhcyBlYXRlbiBieSB0aGUgZW5jb2RlclxuICAgICAgICAgICAgb2Zmc2V0IC09IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIEpQRUcgbWFya2VyICR7ZmlsZU1hcmtlci50b1N0cmluZygxNil9YCk7XG4gICAgICB9XG4gICAgICBmaWxlTWFya2VyID0gcmVhZFVpbnQxNigpO1xuICAgIH1cbiAgfVxuXG4gIGdldFJlc3VsdCgpIHtcbiAgICBjb25zdCB7IGZyYW1lcyB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5mcmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGZyYW1lcyB3ZXJlIGRlY29kZWQnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZnJhbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybignbW9yZSB0aGFuIG9uZSBmcmFtZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGVhY2ggZnJhbWUncyBjb21wb25lbnRzIHF1YW50aXphdGlvbiB0YWJsZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNwID0gdGhpcy5mcmFtZXNbaV0uY29tcG9uZW50cztcbiAgICAgIGZvciAoY29uc3QgaiBvZiBPYmplY3Qua2V5cyhjcCkpIHtcbiAgICAgICAgY3Bbal0ucXVhbnRpemF0aW9uVGFibGUgPSB0aGlzLnF1YW50aXphdGlvblRhYmxlc1tjcFtqXS5xdWFudGl6YXRpb25JZHhdO1xuICAgICAgICBkZWxldGUgY3Bbal0ucXVhbnRpemF0aW9uSWR4O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzWzBdO1xuICAgIGNvbnN0IHsgY29tcG9uZW50cywgY29tcG9uZW50c09yZGVyIH0gPSBmcmFtZTtcbiAgICBjb25zdCBvdXRDb21wb25lbnRzID0gW107XG4gICAgY29uc3Qgd2lkdGggPSBmcmFtZS5zYW1wbGVzUGVyTGluZTtcbiAgICBjb25zdCBoZWlnaHQgPSBmcmFtZS5zY2FuTGluZXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHNPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRzT3JkZXJbaV1dO1xuICAgICAgb3V0Q29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgbGluZXM6IGJ1aWxkQ29tcG9uZW50RGF0YShmcmFtZSwgY29tcG9uZW50KSxcbiAgICAgICAgc2NhbGVYOiBjb21wb25lbnQuaCAvIGZyYW1lLm1heEgsXG4gICAgICAgIHNjYWxlWTogY29tcG9uZW50LnYgLyBmcmFtZS5tYXhWLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiBvdXRDb21wb25lbnRzLmxlbmd0aCk7XG4gICAgbGV0IG9pID0gMDtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRDb21wb25lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gb3V0Q29tcG9uZW50c1tpXTtcbiAgICAgICAgICBvdXRbb2ldID0gY29tcG9uZW50LmxpbmVzWzAgfCB5ICogY29tcG9uZW50LnNjYWxlWV1bMCB8IHggKiBjb21wb25lbnQuc2NhbGVYXTtcbiAgICAgICAgICArK29pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSnBlZ0RlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7XG4gIGNvbnN0cnVjdG9yKGZpbGVEaXJlY3RvcnkpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVhZGVyID0gbmV3IEpwZWdTdHJlYW1SZWFkZXIoKTtcbiAgICBpZiAoZmlsZURpcmVjdG9yeS5KUEVHVGFibGVzKSB7XG4gICAgICB0aGlzLnJlYWRlci5wYXJzZShmaWxlRGlyZWN0b3J5LkpQRUdUYWJsZXMpO1xuICAgIH1cbiAgfVxuXG4gIGRlY29kZUJsb2NrKGJ1ZmZlcikge1xuICAgIHRoaXMucmVhZGVyLnJlc2V0RnJhbWVzKCk7XG4gICAgdGhpcy5yZWFkZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgcmV0dXJuIHRoaXMucmVhZGVyLmdldFJlc3VsdCgpLmJ1ZmZlcjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/jpeg.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/lerc.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/lerc.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LercDecoder),\n/* harmony export */   zstd: () => (/* binding */ zstd)\n/* harmony export */ });\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var lerc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lerc */ \"(ssr)/./node_modules/lerc/LercDecode.js\");\n/* harmony import */ var zstddec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zstddec */ \"(ssr)/./node_modules/zstddec/dist/zstddec.modern.js\");\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../globals.js */ \"(ssr)/./node_modules/geotiff/dist-module/globals.js\");\n\n\n\n\n\n\nconst zstd = new zstddec__WEBPACK_IMPORTED_MODULE_2__.ZSTDDecoder();\n\nclass LercDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n  constructor(fileDirectory) {\n    super();\n\n    this.planarConfiguration = typeof fileDirectory.PlanarConfiguration !== 'undefined' ? fileDirectory.PlanarConfiguration : 1;\n    this.samplesPerPixel = typeof fileDirectory.SamplesPerPixel !== 'undefined' ? fileDirectory.SamplesPerPixel : 1;\n\n    this.addCompression = fileDirectory.LercParameters[_globals_js__WEBPACK_IMPORTED_MODULE_4__.LercParameters.AddCompression];\n  }\n\n  decodeBlock(buffer) {\n    switch (this.addCompression) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_4__.LercAddCompression.None:\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_4__.LercAddCompression.Deflate:\n        buffer = (0,pako__WEBPACK_IMPORTED_MODULE_0__.inflate)(new Uint8Array(buffer)).buffer; // eslint-disable-line no-param-reassign, prefer-destructuring\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_4__.LercAddCompression.Zstandard:\n        buffer = zstd.decode(new Uint8Array(buffer)).buffer; // eslint-disable-line no-param-reassign, prefer-destructuring\n        break;\n      default:\n        throw new Error(`Unsupported LERC additional compression method identifier: ${this.addCompression}`);\n    }\n\n    const lercResult = lerc__WEBPACK_IMPORTED_MODULE_1__.decode(buffer, { returnPixelInterleavedDims: this.planarConfiguration === 1 });\n    const lercData = lercResult.pixels[0];\n    return lercData.buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9sZXJjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0I7QUFDUDtBQUNjO0FBQ0s7QUFDd0I7O0FBRTVELGlCQUFpQixnREFBVzs7QUFFcEIsMEJBQTBCLHVEQUFXO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1REFBdUQsdURBQWM7QUFDckU7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMkRBQWtCO0FBQzdCO0FBQ0EsV0FBVywyREFBa0I7QUFDN0IsaUJBQWlCLDZDQUFPLGlDQUFpQztBQUN6RDtBQUNBLFdBQVcsMkRBQWtCO0FBQzdCLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0Esc0ZBQXNGLG9CQUFvQjtBQUMxRzs7QUFFQSx1QkFBdUIsd0NBQVcsV0FBVyw0REFBNEQ7QUFDekc7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvY29tcHJlc3Npb24vbGVyYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbmZsYXRlIH0gZnJvbSAncGFrbyc7XG5pbXBvcnQgTGVyYyBmcm9tICdsZXJjJztcbmltcG9ydCB7IFpTVEREZWNvZGVyIH0gZnJvbSAnenN0ZGRlYyc7XG5pbXBvcnQgQmFzZURlY29kZXIgZnJvbSAnLi9iYXNlZGVjb2Rlci5qcyc7XG5pbXBvcnQgeyBMZXJjUGFyYW1ldGVycywgTGVyY0FkZENvbXByZXNzaW9uIH0gZnJvbSAnLi4vZ2xvYmFscy5qcyc7XG5cbmV4cG9ydCBjb25zdCB6c3RkID0gbmV3IFpTVEREZWNvZGVyKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExlcmNEZWNvZGVyIGV4dGVuZHMgQmFzZURlY29kZXIge1xuICBjb25zdHJ1Y3RvcihmaWxlRGlyZWN0b3J5KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9IHR5cGVvZiBmaWxlRGlyZWN0b3J5LlBsYW5hckNvbmZpZ3VyYXRpb24gIT09ICd1bmRlZmluZWQnID8gZmlsZURpcmVjdG9yeS5QbGFuYXJDb25maWd1cmF0aW9uIDogMTtcbiAgICB0aGlzLnNhbXBsZXNQZXJQaXhlbCA9IHR5cGVvZiBmaWxlRGlyZWN0b3J5LlNhbXBsZXNQZXJQaXhlbCAhPT0gJ3VuZGVmaW5lZCcgPyBmaWxlRGlyZWN0b3J5LlNhbXBsZXNQZXJQaXhlbCA6IDE7XG5cbiAgICB0aGlzLmFkZENvbXByZXNzaW9uID0gZmlsZURpcmVjdG9yeS5MZXJjUGFyYW1ldGVyc1tMZXJjUGFyYW1ldGVycy5BZGRDb21wcmVzc2lvbl07XG4gIH1cblxuICBkZWNvZGVCbG9jayhidWZmZXIpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYWRkQ29tcHJlc3Npb24pIHtcbiAgICAgIGNhc2UgTGVyY0FkZENvbXByZXNzaW9uLk5vbmU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMZXJjQWRkQ29tcHJlc3Npb24uRGVmbGF0ZTpcbiAgICAgICAgYnVmZmVyID0gaW5mbGF0ZShuZXcgVWludDhBcnJheShidWZmZXIpKS5idWZmZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMZXJjQWRkQ29tcHJlc3Npb24uWnN0YW5kYXJkOlxuICAgICAgICBidWZmZXIgPSB6c3RkLmRlY29kZShuZXcgVWludDhBcnJheShidWZmZXIpKS5idWZmZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBMRVJDIGFkZGl0aW9uYWwgY29tcHJlc3Npb24gbWV0aG9kIGlkZW50aWZpZXI6ICR7dGhpcy5hZGRDb21wcmVzc2lvbn1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBsZXJjUmVzdWx0ID0gTGVyYy5kZWNvZGUoYnVmZmVyLCB7IHJldHVyblBpeGVsSW50ZXJsZWF2ZWREaW1zOiB0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDEgfSk7XG4gICAgY29uc3QgbGVyY0RhdGEgPSBsZXJjUmVzdWx0LnBpeGVsc1swXTtcbiAgICByZXR1cm4gbGVyY0RhdGEuYnVmZmVyO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/lerc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/lzw.js":
/*!*************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/lzw.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LZWDecoder)\n/* harmony export */ });\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n\n\nconst MIN_BITS = 9;\nconst CLEAR_CODE = 256; // clear code\nconst EOI_CODE = 257; // end of information\nconst MAX_BYTELENGTH = 12;\n\nfunction getByte(array, position, length) {\n  const d = position % 8;\n  const a = Math.floor(position / 8);\n  const de = 8 - d;\n  const ef = (position + length) - ((a + 1) * 8);\n  let fg = (8 * (a + 2)) - (position + length);\n  const dg = ((a + 2) * 8) - position;\n  fg = Math.max(0, fg);\n  if (a >= array.length) {\n    console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');\n    return EOI_CODE;\n  }\n  let chunk1 = array[a] & ((2 ** (8 - d)) - 1);\n  chunk1 <<= (length - de);\n  let chunks = chunk1;\n  if (a + 1 < array.length) {\n    let chunk2 = array[a + 1] >>> fg;\n    chunk2 <<= Math.max(0, (length - dg));\n    chunks += chunk2;\n  }\n  if (ef > 8 && a + 2 < array.length) {\n    const hi = ((a + 3) * 8) - (position + length);\n    const chunk3 = array[a + 2] >>> hi;\n    chunks += chunk3;\n  }\n  return chunks;\n}\n\nfunction appendReversed(dest, source) {\n  for (let i = source.length - 1; i >= 0; i--) {\n    dest.push(source[i]);\n  }\n  return dest;\n}\n\nfunction decompress(input) {\n  const dictionaryIndex = new Uint16Array(4093);\n  const dictionaryChar = new Uint8Array(4093);\n  for (let i = 0; i <= 257; i++) {\n    dictionaryIndex[i] = 4096;\n    dictionaryChar[i] = i;\n  }\n  let dictionaryLength = 258;\n  let byteLength = MIN_BITS;\n  let position = 0;\n\n  function initDictionary() {\n    dictionaryLength = 258;\n    byteLength = MIN_BITS;\n  }\n  function getNext(array) {\n    const byte = getByte(array, position, byteLength);\n    position += byteLength;\n    return byte;\n  }\n  function addToDictionary(i, c) {\n    dictionaryChar[dictionaryLength] = c;\n    dictionaryIndex[dictionaryLength] = i;\n    dictionaryLength++;\n    return dictionaryLength - 1;\n  }\n  function getDictionaryReversed(n) {\n    const rev = [];\n    for (let i = n; i !== 4096; i = dictionaryIndex[i]) {\n      rev.push(dictionaryChar[i]);\n    }\n    return rev;\n  }\n\n  const result = [];\n  initDictionary();\n  const array = new Uint8Array(input);\n  let code = getNext(array);\n  let oldCode;\n  while (code !== EOI_CODE) {\n    if (code === CLEAR_CODE) {\n      initDictionary();\n      code = getNext(array);\n      while (code === CLEAR_CODE) {\n        code = getNext(array);\n      }\n\n      if (code === EOI_CODE) {\n        break;\n      } else if (code > CLEAR_CODE) {\n        throw new Error(`corrupted code at scanline ${code}`);\n      } else {\n        const val = getDictionaryReversed(code);\n        appendReversed(result, val);\n        oldCode = code;\n      }\n    } else if (code < dictionaryLength) {\n      const val = getDictionaryReversed(code);\n      appendReversed(result, val);\n      addToDictionary(oldCode, val[val.length - 1]);\n      oldCode = code;\n    } else {\n      const oldVal = getDictionaryReversed(oldCode);\n      if (!oldVal) {\n        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);\n      }\n      appendReversed(result, oldVal);\n      result.push(oldVal[oldVal.length - 1]);\n      addToDictionary(oldCode, oldVal[oldVal.length - 1]);\n      oldCode = code;\n    }\n\n    if (dictionaryLength + 1 >= (2 ** byteLength)) {\n      if (byteLength === MAX_BYTELENGTH) {\n        oldCode = undefined;\n      } else {\n        byteLength++;\n      }\n    }\n    code = getNext(array);\n  }\n  return new Uint8Array(result);\n}\n\nclass LZWDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  decodeBlock(buffer) {\n    return decompress(buffer, false).buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9sencuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMkM7O0FBRTNDO0FBQ0Esd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNEQUFzRCxLQUFLO0FBQzNELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMkRBQTJELFNBQVMsSUFBSSxpQkFBaUIsY0FBYyxTQUFTO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUseUJBQXlCLHVEQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2NvbXByZXNzaW9uL2x6dy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZURlY29kZXIgZnJvbSAnLi9iYXNlZGVjb2Rlci5qcyc7XG5cbmNvbnN0IE1JTl9CSVRTID0gOTtcbmNvbnN0IENMRUFSX0NPREUgPSAyNTY7IC8vIGNsZWFyIGNvZGVcbmNvbnN0IEVPSV9DT0RFID0gMjU3OyAvLyBlbmQgb2YgaW5mb3JtYXRpb25cbmNvbnN0IE1BWF9CWVRFTEVOR1RIID0gMTI7XG5cbmZ1bmN0aW9uIGdldEJ5dGUoYXJyYXksIHBvc2l0aW9uLCBsZW5ndGgpIHtcbiAgY29uc3QgZCA9IHBvc2l0aW9uICUgODtcbiAgY29uc3QgYSA9IE1hdGguZmxvb3IocG9zaXRpb24gLyA4KTtcbiAgY29uc3QgZGUgPSA4IC0gZDtcbiAgY29uc3QgZWYgPSAocG9zaXRpb24gKyBsZW5ndGgpIC0gKChhICsgMSkgKiA4KTtcbiAgbGV0IGZnID0gKDggKiAoYSArIDIpKSAtIChwb3NpdGlvbiArIGxlbmd0aCk7XG4gIGNvbnN0IGRnID0gKChhICsgMikgKiA4KSAtIHBvc2l0aW9uO1xuICBmZyA9IE1hdGgubWF4KDAsIGZnKTtcbiAgaWYgKGEgPj0gYXJyYXkubGVuZ3RoKSB7XG4gICAgY29uc29sZS53YXJuKCdyYW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBiZWZvcmUgZmluZGluZyBFT0lfQ09ERSAoZW5kIG9uIGlucHV0IGNvZGUpJyk7XG4gICAgcmV0dXJuIEVPSV9DT0RFO1xuICB9XG4gIGxldCBjaHVuazEgPSBhcnJheVthXSAmICgoMiAqKiAoOCAtIGQpKSAtIDEpO1xuICBjaHVuazEgPDw9IChsZW5ndGggLSBkZSk7XG4gIGxldCBjaHVua3MgPSBjaHVuazE7XG4gIGlmIChhICsgMSA8IGFycmF5Lmxlbmd0aCkge1xuICAgIGxldCBjaHVuazIgPSBhcnJheVthICsgMV0gPj4+IGZnO1xuICAgIGNodW5rMiA8PD0gTWF0aC5tYXgoMCwgKGxlbmd0aCAtIGRnKSk7XG4gICAgY2h1bmtzICs9IGNodW5rMjtcbiAgfVxuICBpZiAoZWYgPiA4ICYmIGEgKyAyIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgY29uc3QgaGkgPSAoKGEgKyAzKSAqIDgpIC0gKHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICBjb25zdCBjaHVuazMgPSBhcnJheVthICsgMl0gPj4+IGhpO1xuICAgIGNodW5rcyArPSBjaHVuazM7XG4gIH1cbiAgcmV0dXJuIGNodW5rcztcbn1cblxuZnVuY3Rpb24gYXBwZW5kUmV2ZXJzZWQoZGVzdCwgc291cmNlKSB7XG4gIGZvciAobGV0IGkgPSBzb3VyY2UubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBkZXN0LnB1c2goc291cmNlW2ldKTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cblxuZnVuY3Rpb24gZGVjb21wcmVzcyhpbnB1dCkge1xuICBjb25zdCBkaWN0aW9uYXJ5SW5kZXggPSBuZXcgVWludDE2QXJyYXkoNDA5Myk7XG4gIGNvbnN0IGRpY3Rpb25hcnlDaGFyID0gbmV3IFVpbnQ4QXJyYXkoNDA5Myk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IDI1NzsgaSsrKSB7XG4gICAgZGljdGlvbmFyeUluZGV4W2ldID0gNDA5NjtcbiAgICBkaWN0aW9uYXJ5Q2hhcltpXSA9IGk7XG4gIH1cbiAgbGV0IGRpY3Rpb25hcnlMZW5ndGggPSAyNTg7XG4gIGxldCBieXRlTGVuZ3RoID0gTUlOX0JJVFM7XG4gIGxldCBwb3NpdGlvbiA9IDA7XG5cbiAgZnVuY3Rpb24gaW5pdERpY3Rpb25hcnkoKSB7XG4gICAgZGljdGlvbmFyeUxlbmd0aCA9IDI1ODtcbiAgICBieXRlTGVuZ3RoID0gTUlOX0JJVFM7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TmV4dChhcnJheSkge1xuICAgIGNvbnN0IGJ5dGUgPSBnZXRCeXRlKGFycmF5LCBwb3NpdGlvbiwgYnl0ZUxlbmd0aCk7XG4gICAgcG9zaXRpb24gKz0gYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gYnl0ZTtcbiAgfVxuICBmdW5jdGlvbiBhZGRUb0RpY3Rpb25hcnkoaSwgYykge1xuICAgIGRpY3Rpb25hcnlDaGFyW2RpY3Rpb25hcnlMZW5ndGhdID0gYztcbiAgICBkaWN0aW9uYXJ5SW5kZXhbZGljdGlvbmFyeUxlbmd0aF0gPSBpO1xuICAgIGRpY3Rpb25hcnlMZW5ndGgrKztcbiAgICByZXR1cm4gZGljdGlvbmFyeUxlbmd0aCAtIDE7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RGljdGlvbmFyeVJldmVyc2VkKG4pIHtcbiAgICBjb25zdCByZXYgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gbjsgaSAhPT0gNDA5NjsgaSA9IGRpY3Rpb25hcnlJbmRleFtpXSkge1xuICAgICAgcmV2LnB1c2goZGljdGlvbmFyeUNoYXJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV2O1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGluaXREaWN0aW9uYXJ5KCk7XG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICBsZXQgY29kZSA9IGdldE5leHQoYXJyYXkpO1xuICBsZXQgb2xkQ29kZTtcbiAgd2hpbGUgKGNvZGUgIT09IEVPSV9DT0RFKSB7XG4gICAgaWYgKGNvZGUgPT09IENMRUFSX0NPREUpIHtcbiAgICAgIGluaXREaWN0aW9uYXJ5KCk7XG4gICAgICBjb2RlID0gZ2V0TmV4dChhcnJheSk7XG4gICAgICB3aGlsZSAoY29kZSA9PT0gQ0xFQVJfQ09ERSkge1xuICAgICAgICBjb2RlID0gZ2V0TmV4dChhcnJheSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlID09PSBFT0lfQ09ERSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA+IENMRUFSX0NPREUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb3JydXB0ZWQgY29kZSBhdCBzY2FubGluZSAke2NvZGV9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2YWwgPSBnZXREaWN0aW9uYXJ5UmV2ZXJzZWQoY29kZSk7XG4gICAgICAgIGFwcGVuZFJldmVyc2VkKHJlc3VsdCwgdmFsKTtcbiAgICAgICAgb2xkQ29kZSA9IGNvZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlIDwgZGljdGlvbmFyeUxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsID0gZ2V0RGljdGlvbmFyeVJldmVyc2VkKGNvZGUpO1xuICAgICAgYXBwZW5kUmV2ZXJzZWQocmVzdWx0LCB2YWwpO1xuICAgICAgYWRkVG9EaWN0aW9uYXJ5KG9sZENvZGUsIHZhbFt2YWwubGVuZ3RoIC0gMV0pO1xuICAgICAgb2xkQ29kZSA9IGNvZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9sZFZhbCA9IGdldERpY3Rpb25hcnlSZXZlcnNlZChvbGRDb2RlKTtcbiAgICAgIGlmICghb2xkVmFsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQm9ndXMgZW50cnkuIE5vdCBpbiBkaWN0aW9uYXJ5LCAke29sZENvZGV9IC8gJHtkaWN0aW9uYXJ5TGVuZ3RofSwgcG9zaXRpb246ICR7cG9zaXRpb259YCk7XG4gICAgICB9XG4gICAgICBhcHBlbmRSZXZlcnNlZChyZXN1bHQsIG9sZFZhbCk7XG4gICAgICByZXN1bHQucHVzaChvbGRWYWxbb2xkVmFsLmxlbmd0aCAtIDFdKTtcbiAgICAgIGFkZFRvRGljdGlvbmFyeShvbGRDb2RlLCBvbGRWYWxbb2xkVmFsLmxlbmd0aCAtIDFdKTtcbiAgICAgIG9sZENvZGUgPSBjb2RlO1xuICAgIH1cblxuICAgIGlmIChkaWN0aW9uYXJ5TGVuZ3RoICsgMSA+PSAoMiAqKiBieXRlTGVuZ3RoKSkge1xuICAgICAgaWYgKGJ5dGVMZW5ndGggPT09IE1BWF9CWVRFTEVOR1RIKSB7XG4gICAgICAgIG9sZENvZGUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBieXRlTGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuICAgIGNvZGUgPSBnZXROZXh0KGFycmF5KTtcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTFpXRGVjb2RlciBleHRlbmRzIEJhc2VEZWNvZGVyIHtcbiAgZGVjb2RlQmxvY2soYnVmZmVyKSB7XG4gICAgcmV0dXJuIGRlY29tcHJlc3MoYnVmZmVyLCBmYWxzZSkuYnVmZmVyO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/lzw.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/packbits.js":
/*!******************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/packbits.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PackbitsDecoder)\n/* harmony export */ });\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n\n\nclass PackbitsDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  decodeBlock(buffer) {\n    const dataView = new DataView(buffer);\n    const out = [];\n\n    for (let i = 0; i < buffer.byteLength; ++i) {\n      let header = dataView.getInt8(i);\n      if (header < 0) {\n        const next = dataView.getUint8(i + 1);\n        header = -header;\n        for (let j = 0; j <= header; ++j) {\n          out.push(next);\n        }\n        i += 1;\n      } else {\n        for (let j = 0; j <= header; ++j) {\n          out.push(dataView.getUint8(i + j + 1));\n        }\n        i += header + 1;\n      }\n    }\n    return new Uint8Array(out).buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9wYWNrYml0cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyQzs7QUFFNUIsOEJBQThCLHVEQUFXO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvY29tcHJlc3Npb24vcGFja2JpdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VEZWNvZGVyIGZyb20gJy4vYmFzZWRlY29kZXIuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWNrYml0c0RlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7XG4gIGRlY29kZUJsb2NrKGJ1ZmZlcikge1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgY29uc3Qgb3V0ID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5ieXRlTGVuZ3RoOyArK2kpIHtcbiAgICAgIGxldCBoZWFkZXIgPSBkYXRhVmlldy5nZXRJbnQ4KGkpO1xuICAgICAgaWYgKGhlYWRlciA8IDApIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IGRhdGFWaWV3LmdldFVpbnQ4KGkgKyAxKTtcbiAgICAgICAgaGVhZGVyID0gLWhlYWRlcjtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gaGVhZGVyOyArK2opIHtcbiAgICAgICAgICBvdXQucHVzaChuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBoZWFkZXI7ICsraikge1xuICAgICAgICAgIG91dC5wdXNoKGRhdGFWaWV3LmdldFVpbnQ4KGkgKyBqICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGkgKz0gaGVhZGVyICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG91dCkuYnVmZmVyO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/packbits.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/raw.js":
/*!*************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/raw.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RawDecoder)\n/* harmony export */ });\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n\n\nclass RawDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  decodeBlock(buffer) {\n    return buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9yYXcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMkM7O0FBRTVCLHlCQUF5Qix1REFBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9yYXcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VEZWNvZGVyIGZyb20gJy4vYmFzZWRlY29kZXIuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYXdEZWNvZGVyIGV4dGVuZHMgQmFzZURlY29kZXIge1xuICBkZWNvZGVCbG9jayhidWZmZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/raw.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/webimage.js":
/*!******************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/webimage.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WebImageDecoder)\n/* harmony export */ });\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n\n\n/**\n * class WebImageDecoder\n *\n * This decoder uses the browsers image decoding facilities to read image\n * formats like WebP when supported.\n */\nclass WebImageDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor() {\n    super();\n    if (typeof createImageBitmap === 'undefined') {\n      throw new Error('Cannot decode WebImage as `createImageBitmap` is not available');\n    } else if (typeof document === 'undefined' && typeof OffscreenCanvas === 'undefined') {\n      throw new Error('Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available');\n    }\n  }\n\n  async decode(fileDirectory, buffer) {\n    const blob = new Blob([buffer]);\n    const imageBitmap = await createImageBitmap(blob);\n\n    let canvas;\n    if (typeof document !== 'undefined') {\n      canvas = document.createElement('canvas');\n      canvas.width = imageBitmap.width;\n      canvas.height = imageBitmap.height;\n    } else {\n      canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n    }\n\n    const ctx = canvas.getContext('2d');\n    ctx.drawImage(imageBitmap, 0, 0);\n\n    // TODO: check how many samples per pixel we have, and return RGB/RGBA accordingly\n    // it seems like GDAL always encodes via RGBA which does not require a translation\n\n    return ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data.buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi93ZWJpbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsOEJBQThCLHVEQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvY29tcHJlc3Npb24vd2ViaW1hZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VEZWNvZGVyIGZyb20gJy4vYmFzZWRlY29kZXIuanMnO1xuXG4vKipcbiAqIGNsYXNzIFdlYkltYWdlRGVjb2RlclxuICpcbiAqIFRoaXMgZGVjb2RlciB1c2VzIHRoZSBicm93c2VycyBpbWFnZSBkZWNvZGluZyBmYWNpbGl0aWVzIHRvIHJlYWQgaW1hZ2VcbiAqIGZvcm1hdHMgbGlrZSBXZWJQIHdoZW4gc3VwcG9ydGVkLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJJbWFnZURlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY29kZSBXZWJJbWFnZSBhcyBgY3JlYXRlSW1hZ2VCaXRtYXBgIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY29kZSBXZWJJbWFnZSBhcyBuZWl0aGVyIGBkb2N1bWVudGAgbm9yIGBPZmZzY3JlZW5DYW52YXNgIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBkZWNvZGUoZmlsZURpcmVjdG9yeSwgYnVmZmVyKSB7XG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdKTtcbiAgICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGJsb2IpO1xuXG4gICAgbGV0IGNhbnZhcztcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjYW52YXMud2lkdGggPSBpbWFnZUJpdG1hcC53aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZUJpdG1hcC5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoaW1hZ2VCaXRtYXAud2lkdGgsIGltYWdlQml0bWFwLmhlaWdodCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmRyYXdJbWFnZShpbWFnZUJpdG1hcCwgMCwgMCk7XG5cbiAgICAvLyBUT0RPOiBjaGVjayBob3cgbWFueSBzYW1wbGVzIHBlciBwaXhlbCB3ZSBoYXZlLCBhbmQgcmV0dXJuIFJHQi9SR0JBIGFjY29yZGluZ2x5XG4gICAgLy8gaXQgc2VlbXMgbGlrZSBHREFMIGFsd2F5cyBlbmNvZGVzIHZpYSBSR0JBIHdoaWNoIGRvZXMgbm90IHJlcXVpcmUgYSB0cmFuc2xhdGlvblxuXG4gICAgcmV0dXJuIGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgaW1hZ2VCaXRtYXAud2lkdGgsIGltYWdlQml0bWFwLmhlaWdodCkuZGF0YS5idWZmZXI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/webimage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/dataslice.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataslice.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DataSlice)\n/* harmony export */ });\nclass DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9kYXRhc2xpY2UuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2RhdGFzbGljZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhU2xpY2Uge1xuICBjb25zdHJ1Y3RvcihhcnJheUJ1ZmZlciwgc2xpY2VPZmZzZXQsIGxpdHRsZUVuZGlhbiwgYmlnVGlmZikge1xuICAgIHRoaXMuX2RhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgICB0aGlzLl9zbGljZU9mZnNldCA9IHNsaWNlT2Zmc2V0O1xuICAgIHRoaXMuX2xpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbjtcbiAgICB0aGlzLl9iaWdUaWZmID0gYmlnVGlmZjtcbiAgfVxuXG4gIGdldCBzbGljZU9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2xpY2VPZmZzZXQ7XG4gIH1cblxuICBnZXQgc2xpY2VUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlT2Zmc2V0ICsgdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgfVxuXG4gIGdldCBsaXR0bGVFbmRpYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpdHRsZUVuZGlhbjtcbiAgfVxuXG4gIGdldCBiaWdUaWZmKCkge1xuICAgIHJldHVybiB0aGlzLl9iaWdUaWZmO1xuICB9XG5cbiAgZ2V0IGJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuYnVmZmVyO1xuICB9XG5cbiAgY292ZXJzKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2VPZmZzZXQgPD0gb2Zmc2V0ICYmIHRoaXMuc2xpY2VUb3AgPj0gb2Zmc2V0ICsgbGVuZ3RoO1xuICB9XG5cbiAgcmVhZFVpbnQ4KG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRVaW50OChcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRJbnQ4KG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQ4KFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZFVpbnQxNihvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDE2KFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZEludDE2KG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQxNihcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRVaW50MzIob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldFVpbnQzMihcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRJbnQzMihvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50MzIoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkRmxvYXQzMihvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0RmxvYXQzMihcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRGbG9hdDY0KG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRGbG9hdDY0KFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZFVpbnQ2NChvZmZzZXQpIHtcbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5yZWFkVWludDMyKG9mZnNldCk7XG4gICAgY29uc3QgcmlnaHQgPSB0aGlzLnJlYWRVaW50MzIob2Zmc2V0ICsgNCk7XG4gICAgbGV0IGNvbWJpbmVkO1xuICAgIGlmICh0aGlzLl9saXR0bGVFbmRpYW4pIHtcbiAgICAgIGNvbWJpbmVkID0gbGVmdCArICgoMiAqKiAzMikgKiByaWdodCk7XG4gICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbWJpbmVkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7Y29tYmluZWR9IGV4Y2VlZHMgTUFYX1NBRkVfSU5URUdFUi4gYFxuICAgICAgICAgICsgJ1ByZWNpc2lvbiBtYXkgYmUgbG9zdC4gUGxlYXNlIHJlcG9ydCBpZiB5b3UgZ2V0IHRoaXMgbWVzc2FnZSB0byBodHRwczovL2dpdGh1Yi5jb20vZ2VvdGlmZmpzL2dlb3RpZmYuanMvaXNzdWVzJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICB9XG4gICAgY29tYmluZWQgPSAoKDIgKiogMzIpICogbGVmdCkgKyByaWdodDtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbWJpbmVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtjb21iaW5lZH0gZXhjZWVkcyBNQVhfU0FGRV9JTlRFR0VSLiBgXG4gICAgICAgICsgJ1ByZWNpc2lvbiBtYXkgYmUgbG9zdC4gUGxlYXNlIHJlcG9ydCBpZiB5b3UgZ2V0IHRoaXMgbWVzc2FnZSB0byBodHRwczovL2dpdGh1Yi5jb20vZ2VvdGlmZmpzL2dlb3RpZmYuanMvaXNzdWVzJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbWJpbmVkO1xuICB9XG5cbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NTMzODM4NC84MDYwNTkxXG4gIHJlYWRJbnQ2NChvZmZzZXQpIHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIGNvbnN0IGlzTmVnYXRpdmUgPSAodGhpcy5fZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgKHRoaXMuX2xpdHRsZUVuZGlhbiA/IDcgOiAwKSkgJiAweDgwKVxuICAgICAgPiAwO1xuICAgIGxldCBjYXJyeWluZyA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgIGxldCBieXRlID0gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDgoXG4gICAgICAgIG9mZnNldCArICh0aGlzLl9saXR0bGVFbmRpYW4gPyBpIDogNyAtIGkpLFxuICAgICAgKTtcbiAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgIGlmIChjYXJyeWluZykge1xuICAgICAgICAgIGlmIChieXRlICE9PSAweDAwKSB7XG4gICAgICAgICAgICBieXRlID0gfihieXRlIC0gMSkgJiAweGZmO1xuICAgICAgICAgICAgY2FycnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnl0ZSA9IH5ieXRlICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgKz0gYnl0ZSAqICgyNTYgKiogaSk7XG4gICAgfVxuICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmVhZE9mZnNldChvZmZzZXQpIHtcbiAgICBpZiAodGhpcy5fYmlnVGlmZikge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFVpbnQ2NChvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZWFkVWludDMyKG9mZnNldCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/dataslice.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/dataview64.js":
/*!********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataview64.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DataView64)\n/* harmony export */ });\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @petamoriken/float16 */ \"(ssr)/./node_modules/@petamoriken/float16/src/DataView.mjs\");\n\n\nclass DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return (0,_petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__.getFloat16)(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9kYXRhdmlldzY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWtEOztBQUVuQztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZ0VBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2RhdGF2aWV3NjQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0RmxvYXQxNiB9IGZyb20gJ0BwZXRhbW9yaWtlbi9mbG9hdDE2JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0YVZpZXc2NCB7XG4gIGNvbnN0cnVjdG9yKGFycmF5QnVmZmVyKSB7XG4gICAgdGhpcy5fZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICB9XG5cbiAgZ2V0IGJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuYnVmZmVyO1xuICB9XG5cbiAgZ2V0VWludDY0KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgY29uc3QgbGVmdCA9IHRoaXMuZ2V0VWludDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgICBjb25zdCByaWdodCA9IHRoaXMuZ2V0VWludDMyKG9mZnNldCArIDQsIGxpdHRsZUVuZGlhbik7XG4gICAgbGV0IGNvbWJpbmVkO1xuICAgIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICAgIGNvbWJpbmVkID0gbGVmdCArICgoMiAqKiAzMikgKiByaWdodCk7XG4gICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbWJpbmVkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7Y29tYmluZWR9IGV4Y2VlZHMgTUFYX1NBRkVfSU5URUdFUi4gYFxuICAgICAgICAgICsgJ1ByZWNpc2lvbiBtYXkgYmUgbG9zdC4gUGxlYXNlIHJlcG9ydCBpZiB5b3UgZ2V0IHRoaXMgbWVzc2FnZSB0byBodHRwczovL2dpdGh1Yi5jb20vZ2VvdGlmZmpzL2dlb3RpZmYuanMvaXNzdWVzJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICB9XG4gICAgY29tYmluZWQgPSAoKDIgKiogMzIpICogbGVmdCkgKyByaWdodDtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbWJpbmVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtjb21iaW5lZH0gZXhjZWVkcyBNQVhfU0FGRV9JTlRFR0VSLiBgXG4gICAgICAgICsgJ1ByZWNpc2lvbiBtYXkgYmUgbG9zdC4gUGxlYXNlIHJlcG9ydCBpZiB5b3UgZ2V0IHRoaXMgbWVzc2FnZSB0byBodHRwczovL2dpdGh1Yi5jb20vZ2VvdGlmZmpzL2dlb3RpZmYuanMvaXNzdWVzJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbWJpbmVkO1xuICB9XG5cbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NTMzODM4NC84MDYwNTkxXG4gIGdldEludDY0KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBjb25zdCBpc05lZ2F0aXZlID0gKHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIChsaXR0bGVFbmRpYW4gPyA3IDogMCkpICYgMHg4MCkgPiAwO1xuICAgIGxldCBjYXJyeWluZyA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgIGxldCBieXRlID0gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgKGxpdHRsZUVuZGlhbiA/IGkgOiA3IC0gaSkpO1xuICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgaWYgKGNhcnJ5aW5nKSB7XG4gICAgICAgICAgaWYgKGJ5dGUgIT09IDB4MDApIHtcbiAgICAgICAgICAgIGJ5dGUgPSB+KGJ5dGUgLSAxKSAmIDB4ZmY7XG4gICAgICAgICAgICBjYXJyeWluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBieXRlID0gfmJ5dGUgJiAweGZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YWx1ZSArPSBieXRlICogKDI1NiAqKiBpKTtcbiAgICB9XG4gICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBnZXRVaW50OChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRVaW50OChvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRJbnQ4KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEludDgob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0VWludDE2KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRJbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRVaW50MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldEludDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEludDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldEZsb2F0MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gZ2V0RmxvYXQxNih0aGlzLl9kYXRhVmlldywgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0RmxvYXQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRGbG9hdDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldEZsb2F0NjQob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/dataview64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/geotiff.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiff.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseClient: () => (/* reexport safe */ _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__.BaseClient),\n/* harmony export */   BaseDecoder: () => (/* reexport safe */ _compression_basedecoder_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   BaseResponse: () => (/* reexport safe */ _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__.BaseResponse),\n/* harmony export */   GeoTIFF: () => (/* binding */ GeoTIFF),\n/* harmony export */   GeoTIFFImage: () => (/* reexport safe */ _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   MultiGeoTIFF: () => (/* binding */ MultiGeoTIFF),\n/* harmony export */   Pool: () => (/* reexport safe */ _pool_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"]),\n/* harmony export */   addDecoder: () => (/* reexport safe */ _compression_index_js__WEBPACK_IMPORTED_MODULE_3__.addDecoder),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromArrayBuffer: () => (/* binding */ fromArrayBuffer),\n/* harmony export */   fromBlob: () => (/* binding */ fromBlob),\n/* harmony export */   fromCustomClient: () => (/* binding */ fromCustomClient),\n/* harmony export */   fromFile: () => (/* binding */ fromFile),\n/* harmony export */   fromUrl: () => (/* binding */ fromUrl),\n/* harmony export */   fromUrls: () => (/* binding */ fromUrls),\n/* harmony export */   getDecoder: () => (/* reexport safe */ _compression_index_js__WEBPACK_IMPORTED_MODULE_3__.getDecoder),\n/* harmony export */   globals: () => (/* reexport module object */ _globals_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   rgb: () => (/* reexport module object */ _rgb_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   setLogger: () => (/* reexport safe */ _logging_js__WEBPACK_IMPORTED_MODULE_4__.setLogger),\n/* harmony export */   writeArrayBuffer: () => (/* binding */ writeArrayBuffer)\n/* harmony export */ });\n/* harmony import */ var _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geotiffimage.js */ \"(ssr)/./node_modules/geotiff/dist-module/geotiffimage.js\");\n/* harmony import */ var _dataview64_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dataview64.js */ \"(ssr)/./node_modules/geotiff/dist-module/dataview64.js\");\n/* harmony import */ var _dataslice_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dataslice.js */ \"(ssr)/./node_modules/geotiff/dist-module/dataslice.js\");\n/* harmony import */ var _pool_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./pool.js */ \"(ssr)/./node_modules/geotiff/dist-module/pool.js\");\n/* harmony import */ var _source_remote_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./source/remote.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/remote.js\");\n/* harmony import */ var _source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./source/arraybuffer.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/arraybuffer.js\");\n/* harmony import */ var _source_filereader_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./source/filereader.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/filereader.js\");\n/* harmony import */ var _source_file_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./source/file.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/file.js\");\n/* harmony import */ var _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./source/client/base.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.js */ \"(ssr)/./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _geotiffwriter_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./geotiffwriter.js */ \"(ssr)/./node_modules/geotiff/dist-module/geotiffwriter.js\");\n/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb.js */ \"(ssr)/./node_modules/geotiff/dist-module/rgb.js\");\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./compression/index.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/index.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./logging.js */ \"(ssr)/./node_modules/geotiff/dist-module/logging.js\");\n/* harmony import */ var _compression_basedecoder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compression/basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n/** @module geotiff */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.BYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SBYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.UNDEFINED:\n      return 1;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SHORT: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SSHORT:\n      return 2;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.FLOAT: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD:\n      return 4;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.DOUBLE:\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = _globals_js__WEBPACK_IMPORTED_MODULE_0__.geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (_globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.BYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new _dataslice_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && _globals_js__WEBPACK_IMPORTED_MODULE_0__.arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[_globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new _dataview64_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoTIFF);\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\n\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeCustomSource)(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource((0,_source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_9__.makeBufferSource)(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromFile(path, signal) {\n  return GeoTIFF.fromSource((0,_source_file_js__WEBPACK_IMPORTED_MODULE_10__.makeFileSource)(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource((0,_source_filereader_js__WEBPACK_IMPORTED_MODULE_11__.makeFileReaderSource)(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nasync function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nfunction writeArrayBuffer(values, metadata) {\n  return (0,_geotiffwriter_js__WEBPACK_IMPORTED_MODULE_12__.writeGeotiff)(values, metadata);\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDNkM7QUFDSjtBQUNGO0FBQ1Y7O0FBRTJDO0FBQ2I7QUFDRztBQUNaO0FBQ2lCOztBQUVnQjtBQUNqQztBQUNWO0FBQ1I7QUFDZ0M7QUFDdkI7O0FBRXRCO0FBQ0o7QUFDdUQ7QUFDcEM7QUFDYjs7QUFFckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0IsY0FBYztBQUNqRCxhQUFhLHlCQUF5QjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCLGNBQWM7QUFDbkQsYUFBYSwyQkFBMkI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQixjQUFjO0FBQ2xFLGFBQWEsMERBQTBEO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQSxTQUFTLG1EQUFVLFlBQVksbURBQVUsYUFBYSxtREFBVSxhQUFhLG1EQUFVO0FBQ3ZGO0FBQ0EsU0FBUyxtREFBVSxhQUFhLG1EQUFVO0FBQzFDO0FBQ0EsU0FBUyxtREFBVSxZQUFZLG1EQUFVLGFBQWEsbURBQVUsYUFBYSxtREFBVTtBQUN2RjtBQUNBLFNBQVMsbURBQVUsZ0JBQWdCLG1EQUFVLGlCQUFpQixtREFBVTtBQUN4RSxTQUFTLG1EQUFVLGFBQWEsbURBQVUsY0FBYyxtREFBVTtBQUNsRTtBQUNBO0FBQ0Esa0RBQWtELFVBQVU7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGdDQUFnQztBQUNsRCxnQkFBZ0Isb0RBQVc7QUFDM0I7QUFDQSxTQUFTLHNEQUFhO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwwREFBMEQsSUFBSTtBQUM5RCxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLG1EQUFVLFlBQVksbURBQVUsYUFBYSxtREFBVTtBQUNoRSxzQ0FBc0M7QUFDdEM7QUFDQSxTQUFTLG1EQUFVO0FBQ25CLHFDQUFxQztBQUNyQztBQUNBLFNBQVMsbURBQVU7QUFDbkIsdUNBQXVDO0FBQ3ZDO0FBQ0EsU0FBUyxtREFBVTtBQUNuQixzQ0FBc0M7QUFDdEM7QUFDQSxTQUFTLG1EQUFVLFlBQVksbURBQVU7QUFDekMsdUNBQXVDO0FBQ3ZDO0FBQ0EsU0FBUyxtREFBVTtBQUNuQixzQ0FBc0M7QUFDdEM7QUFDQSxTQUFTLG1EQUFVLGFBQWEsbURBQVU7QUFDMUMsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUyxtREFBVTtBQUNuQixpQ0FBaUM7QUFDakM7QUFDQSxTQUFTLG1EQUFVO0FBQ25CLDJDQUEyQztBQUMzQztBQUNBLFNBQVMsbURBQVU7QUFDbkIsMENBQTBDO0FBQzFDO0FBQ0EsU0FBUyxtREFBVTtBQUNuQix3Q0FBd0M7QUFDeEM7QUFDQSxTQUFTLG1EQUFVO0FBQ25CLHdDQUF3QztBQUN4QztBQUNBO0FBQ0Esa0RBQWtELFVBQVU7QUFDNUQ7O0FBRUE7QUFDQSxzQkFBc0IsbURBQVUsMkJBQTJCLG1EQUFVO0FBQ3JFLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1gsb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbURBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQSxhQUFhLDRDQUE0QyxXQUFXO0FBQ3BFLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0EsZ0NBQWdDO0FBQ2hDLFlBQVkscUNBQXFDO0FBQ2pELFVBQVUsbUJBQW1COztBQUU3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBLGdCQUFnQiwyREFBMkQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLHlCQUF5QjtBQUM1RDtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsNkJBQTZCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLDRCQUE0QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLG9EQUFXO0FBQ3hDLDJCQUEyQixtREFBVSwyQkFBMkIsbURBQVU7QUFDMUU7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixzREFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtREFBVTtBQUN2RCw0Q0FBNEMsbURBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtREFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMseUJBQXlCO0FBQ3ZFLHlCQUF5QixzREFBVTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1CO0FBQ25CLGlFQUFlLE9BQU8sRUFBQzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0EscUJBQXFCLHdEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0I7O0FBRXhCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGtDQUFrQyx3QkFBd0I7QUFDMUQsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDTyx3Q0FBd0M7QUFDL0MsNEJBQTRCLG1FQUFnQjtBQUM1Qzs7QUFFQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixrQ0FBa0Msd0JBQXdCO0FBQzFELFdBQVcsYUFBYTtBQUN4QjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ08sb0RBQW9EO0FBQzNELDRCQUE0QixtRUFBZ0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixtR0FBbUc7QUFDcEgsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ087QUFDUCw0QkFBNEIsd0VBQWdCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isc0NBQXNDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ087QUFDUCw0QkFBNEIsZ0VBQWM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBLFVBQVUsNkRBQTZEO0FBQ3ZFLFVBQVU7QUFDVjtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLGFBQWE7QUFDeEI7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNPO0FBQ1AsNEJBQTRCLDRFQUFvQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsb0RBQW9EO0FBQ3BEO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDTyxnRUFBZ0U7QUFDdkUsNENBQTRDLG1FQUFnQjtBQUM1RDtBQUNBLGlEQUFpRCxtRUFBZ0I7QUFDakU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QjtBQUNPO0FBQ1AsU0FBUyxnRUFBWTtBQUNyQjs7QUFFZ0I7QUFDUTtBQUNZIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2dlb3RpZmYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBtb2R1bGUgZ2VvdGlmZiAqL1xuaW1wb3J0IEdlb1RJRkZJbWFnZSBmcm9tICcuL2dlb3RpZmZpbWFnZS5qcyc7XG5pbXBvcnQgRGF0YVZpZXc2NCBmcm9tICcuL2RhdGF2aWV3NjQuanMnO1xuaW1wb3J0IERhdGFTbGljZSBmcm9tICcuL2RhdGFzbGljZS5qcyc7XG5pbXBvcnQgUG9vbCBmcm9tICcuL3Bvb2wuanMnO1xuXG5pbXBvcnQgeyBtYWtlUmVtb3RlU291cmNlLCBtYWtlQ3VzdG9tU291cmNlIH0gZnJvbSAnLi9zb3VyY2UvcmVtb3RlLmpzJztcbmltcG9ydCB7IG1ha2VCdWZmZXJTb3VyY2UgfSBmcm9tICcuL3NvdXJjZS9hcnJheWJ1ZmZlci5qcyc7XG5pbXBvcnQgeyBtYWtlRmlsZVJlYWRlclNvdXJjZSB9IGZyb20gJy4vc291cmNlL2ZpbGVyZWFkZXIuanMnO1xuaW1wb3J0IHsgbWFrZUZpbGVTb3VyY2UgfSBmcm9tICcuL3NvdXJjZS9maWxlLmpzJztcbmltcG9ydCB7IEJhc2VDbGllbnQsIEJhc2VSZXNwb25zZSB9IGZyb20gJy4vc291cmNlL2NsaWVudC9iYXNlLmpzJztcblxuaW1wb3J0IHsgZmllbGRUeXBlcywgZmllbGRUYWdOYW1lcywgYXJyYXlGaWVsZHMsIGdlb0tleU5hbWVzIH0gZnJvbSAnLi9nbG9iYWxzLmpzJztcbmltcG9ydCB7IHdyaXRlR2VvdGlmZiB9IGZyb20gJy4vZ2VvdGlmZndyaXRlci5qcyc7XG5pbXBvcnQgKiBhcyBnbG9iYWxzIGZyb20gJy4vZ2xvYmFscy5qcyc7XG5pbXBvcnQgKiBhcyByZ2IgZnJvbSAnLi9yZ2IuanMnO1xuaW1wb3J0IHsgZ2V0RGVjb2RlciwgYWRkRGVjb2RlciB9IGZyb20gJy4vY29tcHJlc3Npb24vaW5kZXguanMnO1xuaW1wb3J0IHsgc2V0TG9nZ2VyIH0gZnJvbSAnLi9sb2dnaW5nLmpzJztcblxuZXhwb3J0IHsgZ2xvYmFscyB9O1xuZXhwb3J0IHsgcmdiIH07XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhc2VEZWNvZGVyIH0gZnJvbSAnLi9jb21wcmVzc2lvbi9iYXNlZGVjb2Rlci5qcyc7XG5leHBvcnQgeyBnZXREZWNvZGVyLCBhZGREZWNvZGVyIH07XG5leHBvcnQgeyBzZXRMb2dnZXIgfTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7VWludDhBcnJheSB8IEludDhBcnJheSB8IFVpbnQxNkFycmF5IHwgSW50MTZBcnJheSB8IFVpbnQzMkFycmF5IHwgSW50MzJBcnJheSB8IEZsb2F0MzJBcnJheSB8IEZsb2F0NjRBcnJheX1cbiAqIFR5cGVkQXJyYXlcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7IGhlaWdodDpudW1iZXIsIHdpZHRoOiBudW1iZXIgfX0gRGltZW5zaW9uc1xuICovXG5cbi8qKlxuICogVGhlIGF1dG9nZW5lcmF0ZWQgZG9jcyBhcmUgYSBsaXR0bGUgY29uZnVzaW5nIGhlcmUuIFRoZSBlZmZlY3RpdmUgdHlwZSBpczpcbiAqXG4gKiBgVHlwZWRBcnJheSAmIHsgaGVpZ2h0OiBudW1iZXI7IHdpZHRoOiBudW1iZXJ9YFxuICogQHR5cGVkZWYge1R5cGVkQXJyYXkgJiBEaW1lbnNpb25zfSBUeXBlZEFycmF5V2l0aERpbWVuc2lvbnNcbiAqL1xuXG4vKipcbiAqIFRoZSBhdXRvZ2VuZXJhdGVkIGRvY3MgYXJlIGEgbGl0dGxlIGNvbmZ1c2luZyBoZXJlLiBUaGUgZWZmZWN0aXZlIHR5cGUgaXM6XG4gKlxuICogYFR5cGVkQXJyYXlbXSAmIHsgaGVpZ2h0OiBudW1iZXI7IHdpZHRoOiBudW1iZXJ9YFxuICogQHR5cGVkZWYge1R5cGVkQXJyYXlbXSAmIERpbWVuc2lvbnN9IFR5cGVkQXJyYXlBcnJheVdpdGhEaW1lbnNpb25zXG4gKi9cblxuLyoqXG4gKiAgVGhlIGF1dG9nZW5lcmF0ZWQgZG9jcyBhcmUgYSBsaXR0bGUgY29uZnVzaW5nIGhlcmUuIFRoZSBlZmZlY3RpdmUgdHlwZSBpczpcbiAqXG4gKiBgKFR5cGVkQXJyYXkgfCBUeXBlZEFycmF5W10pICYgeyBoZWlnaHQ6IG51bWJlcjsgd2lkdGg6IG51bWJlcn1gXG4gKiBAdHlwZWRlZiB7VHlwZWRBcnJheVdpdGhEaW1lbnNpb25zIHwgVHlwZWRBcnJheUFycmF5V2l0aERpbWVuc2lvbnN9IFJlYWRSYXN0ZXJSZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBnZXRGaWVsZFR5cGVMZW5ndGgoZmllbGRUeXBlKSB7XG4gIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkJZVEU6IGNhc2UgZmllbGRUeXBlcy5BU0NJSTogY2FzZSBmaWVsZFR5cGVzLlNCWVRFOiBjYXNlIGZpZWxkVHlwZXMuVU5ERUZJTkVEOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlNIT1JUOiBjYXNlIGZpZWxkVHlwZXMuU1NIT1JUOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkxPTkc6IGNhc2UgZmllbGRUeXBlcy5TTE9ORzogY2FzZSBmaWVsZFR5cGVzLkZMT0FUOiBjYXNlIGZpZWxkVHlwZXMuSUZEOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlJBVElPTkFMOiBjYXNlIGZpZWxkVHlwZXMuU1JBVElPTkFMOiBjYXNlIGZpZWxkVHlwZXMuRE9VQkxFOlxuICAgIGNhc2UgZmllbGRUeXBlcy5MT05HODogY2FzZSBmaWVsZFR5cGVzLlNMT05HODogY2FzZSBmaWVsZFR5cGVzLklGRDg6XG4gICAgICByZXR1cm4gODtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgZmllbGQgdHlwZTogJHtmaWVsZFR5cGV9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VHZW9LZXlEaXJlY3RvcnkoZmlsZURpcmVjdG9yeSkge1xuICBjb25zdCByYXdHZW9LZXlEaXJlY3RvcnkgPSBmaWxlRGlyZWN0b3J5Lkdlb0tleURpcmVjdG9yeTtcbiAgaWYgKCFyYXdHZW9LZXlEaXJlY3RvcnkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGdlb0tleURpcmVjdG9yeSA9IHt9O1xuICBmb3IgKGxldCBpID0gNDsgaSA8PSByYXdHZW9LZXlEaXJlY3RvcnlbM10gKiA0OyBpICs9IDQpIHtcbiAgICBjb25zdCBrZXkgPSBnZW9LZXlOYW1lc1tyYXdHZW9LZXlEaXJlY3RvcnlbaV1dO1xuICAgIGNvbnN0IGxvY2F0aW9uID0gKHJhd0dlb0tleURpcmVjdG9yeVtpICsgMV0pXG4gICAgICA/IChmaWVsZFRhZ05hbWVzW3Jhd0dlb0tleURpcmVjdG9yeVtpICsgMV1dKSA6IG51bGw7XG4gICAgY29uc3QgY291bnQgPSByYXdHZW9LZXlEaXJlY3RvcnlbaSArIDJdO1xuICAgIGNvbnN0IG9mZnNldCA9IHJhd0dlb0tleURpcmVjdG9yeVtpICsgM107XG5cbiAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgIGlmICghbG9jYXRpb24pIHtcbiAgICAgIHZhbHVlID0gb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGZpbGVEaXJlY3RvcnlbbG9jYXRpb25dO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZ2V0IHZhbHVlIG9mIGdlb0tleSAnJHtrZXl9Jy5gKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIGNvdW50IC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLnN1YmFycmF5KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBjb3VudCk7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ2VvS2V5RGlyZWN0b3J5W2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gZ2VvS2V5RGlyZWN0b3J5O1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZXMoZGF0YVNsaWNlLCBmaWVsZFR5cGUsIGNvdW50LCBvZmZzZXQpIHtcbiAgbGV0IHZhbHVlcyA9IG51bGw7XG4gIGxldCByZWFkTWV0aG9kID0gbnVsbDtcbiAgY29uc3QgZmllbGRUeXBlTGVuZ3RoID0gZ2V0RmllbGRUeXBlTGVuZ3RoKGZpZWxkVHlwZSk7XG5cbiAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICBjYXNlIGZpZWxkVHlwZXMuQllURTogY2FzZSBmaWVsZFR5cGVzLkFTQ0lJOiBjYXNlIGZpZWxkVHlwZXMuVU5ERUZJTkVEOlxuICAgICAgdmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRVaW50ODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TQllURTpcbiAgICAgIHZhbHVlcyA9IG5ldyBJbnQ4QXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRJbnQ4O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlNIT1JUOlxuICAgICAgdmFsdWVzID0gbmV3IFVpbnQxNkFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkVWludDE2O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlNTSE9SVDpcbiAgICAgIHZhbHVlcyA9IG5ldyBJbnQxNkFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkSW50MTY7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuTE9ORzogY2FzZSBmaWVsZFR5cGVzLklGRDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50MzJBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZFVpbnQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TTE9ORzpcbiAgICAgIHZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkSW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuTE9ORzg6IGNhc2UgZmllbGRUeXBlcy5JRkQ4OlxuICAgICAgdmFsdWVzID0gbmV3IEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkVWludDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlNMT05HODpcbiAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZEludDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlJBVElPTkFMOlxuICAgICAgdmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KGNvdW50ICogMik7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZFVpbnQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TUkFUSU9OQUw6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50MzJBcnJheShjb3VudCAqIDIpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRJbnQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5GTE9BVDpcbiAgICAgIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRGbG9hdDMyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkRPVUJMRTpcbiAgICAgIHZhbHVlcyA9IG5ldyBGbG9hdDY0QXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRGbG9hdDY0O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGZpZWxkIHR5cGU6ICR7ZmllbGRUeXBlfWApO1xuICB9XG5cbiAgLy8gbm9ybWFsIGZpZWxkc1xuICBpZiAoIShmaWVsZFR5cGUgPT09IGZpZWxkVHlwZXMuUkFUSU9OQUwgfHwgZmllbGRUeXBlID09PSBmaWVsZFR5cGVzLlNSQVRJT05BTCkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHJlYWRNZXRob2QuY2FsbChcbiAgICAgICAgZGF0YVNsaWNlLCBvZmZzZXQgKyAoaSAqIGZpZWxkVHlwZUxlbmd0aCksXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHsgLy8gUkFUSU9OQUwgb3IgU1JBVElPTkFMXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAyKSB7XG4gICAgICB2YWx1ZXNbaV0gPSByZWFkTWV0aG9kLmNhbGwoXG4gICAgICAgIGRhdGFTbGljZSwgb2Zmc2V0ICsgKGkgKiBmaWVsZFR5cGVMZW5ndGgpLFxuICAgICAgKTtcbiAgICAgIHZhbHVlc1tpICsgMV0gPSByZWFkTWV0aG9kLmNhbGwoXG4gICAgICAgIGRhdGFTbGljZSwgb2Zmc2V0ICsgKChpICogZmllbGRUeXBlTGVuZ3RoKSArIDQpLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZmllbGRUeXBlID09PSBmaWVsZFR5cGVzLkFTQ0lJKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKS5kZWNvZGUodmFsdWVzKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuXG4vKipcbiAqIERhdGEgY2xhc3MgdG8gc3RvcmUgdGhlIHBhcnNlZCBmaWxlIGRpcmVjdG9yeSwgZ2VvIGtleSBkaXJlY3RvcnkgYW5kXG4gKiBvZmZzZXQgdG8gdGhlIG5leHQgSUZEXG4gKi9cbmNsYXNzIEltYWdlRmlsZURpcmVjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKGZpbGVEaXJlY3RvcnksIGdlb0tleURpcmVjdG9yeSwgbmV4dElGREJ5dGVPZmZzZXQpIHtcbiAgICB0aGlzLmZpbGVEaXJlY3RvcnkgPSBmaWxlRGlyZWN0b3J5O1xuICAgIHRoaXMuZ2VvS2V5RGlyZWN0b3J5ID0gZ2VvS2V5RGlyZWN0b3J5O1xuICAgIHRoaXMubmV4dElGREJ5dGVPZmZzZXQgPSBuZXh0SUZEQnl0ZU9mZnNldDtcbiAgfVxufVxuXG4vKipcbiAqIEVycm9yIGNsYXNzIGZvciBjYXNlcyB3aGVuIGFuIElGRCBpbmRleCB3YXMgcmVxdWVzdGVkLCB0aGF0IGRvZXMgbm90IGV4aXN0XG4gKiBpbiB0aGUgZmlsZS5cbiAqL1xuY2xhc3MgR2VvVElGRkltYWdlSW5kZXhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoaW5kZXgpIHtcbiAgICBzdXBlcihgTm8gaW1hZ2UgYXQgaW5kZXggJHtpbmRleH1gKTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gIH1cbn1cblxuY2xhc3MgR2VvVElGRkJhc2Uge1xuICAvKipcbiAgICogKGV4cGVyaW1lbnRhbCkgUmVhZHMgcmFzdGVyIGRhdGEgZnJvbSB0aGUgYmVzdCBmaXR0aW5nIGltYWdlLiBUaGlzIGZ1bmN0aW9uIHVzZXNcbiAgICogdGhlIGltYWdlIHdpdGggdGhlIGxvd2VzdCByZXNvbHV0aW9uIHRoYXQgaXMgc3RpbGwgYSBoaWdoZXIgcmVzb2x1dGlvbiB0aGFuIHRoZVxuICAgKiByZXF1ZXN0ZWQgcmVzb2x1dGlvbi5cbiAgICogV2hlbiBzcGVjaWZpZWQsIHRoZSBgYmJveGAgb3B0aW9uIGlzIHRyYW5zbGF0ZWQgdG8gdGhlIGB3aW5kb3dgIG9wdGlvbiBhbmQgdGhlXG4gICAqIGByZXNYYCBhbmQgYHJlc1lgIHRvIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHJlc3BlY3RpdmVseS5cbiAgICogVGhlbiwgdGhlIFtyZWFkUmFzdGVyc117QGxpbmsgR2VvVElGRkltYWdlI3JlYWRSYXN0ZXJzfSBtZXRob2Qgb2YgdGhlIHNlbGVjdGVkXG4gICAqIGltYWdlIGlzIGNhbGxlZCBhbmQgdGhlIHJlc3VsdCByZXR1cm5lZC5cbiAgICogQHNlZSBHZW9USUZGSW1hZ2UucmVhZFJhc3RlcnNcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vZ2VvdGlmZmltYWdlJykuUmVhZFJhc3Rlck9wdGlvbnN9IFtvcHRpb25zPXt9XSBvcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRSYXN0ZXJSZXN1bHQ+fSB0aGUgZGVjb2RlZCBhcnJheShzKSwgd2l0aCBgaGVpZ2h0YCBhbmQgYHdpZHRoYCwgYXMgYSBwcm9taXNlXG4gICAqL1xuICBhc3luYyByZWFkUmFzdGVycyhvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHdpbmRvdzogaW1hZ2VXaW5kb3csIHdpZHRoLCBoZWlnaHQgfSA9IG9wdGlvbnM7XG4gICAgbGV0IHsgcmVzWCwgcmVzWSwgYmJveCB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGZpcnN0SW1hZ2UgPSBhd2FpdCB0aGlzLmdldEltYWdlKCk7XG4gICAgbGV0IHVzZWRJbWFnZSA9IGZpcnN0SW1hZ2U7XG4gICAgY29uc3QgaW1hZ2VDb3VudCA9IGF3YWl0IHRoaXMuZ2V0SW1hZ2VDb3VudCgpO1xuICAgIGNvbnN0IGltZ0JCb3ggPSBmaXJzdEltYWdlLmdldEJvdW5kaW5nQm94KCk7XG5cbiAgICBpZiAoaW1hZ2VXaW5kb3cgJiYgYmJveCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIFwiYmJveFwiIGFuZCBcIndpbmRvd1wiIHBhc3NlZC4nKTtcbiAgICB9XG5cbiAgICAvLyBpZiB3aWR0aC9oZWlnaHQgaXMgcGFzc2VkLCB0cmFuc2Zvcm0gaXQgdG8gcmVzb2x1dGlvblxuICAgIGlmICh3aWR0aCB8fCBoZWlnaHQpIHtcbiAgICAgIC8vIGlmIHdlIGhhdmUgYW4gaW1hZ2Ugd2luZG93IChwaXhlbCBjb29yZGluYXRlcyksIHRyYW5zZm9ybSBpdCB0byBhIEJCb3hcbiAgICAgIC8vIHVzaW5nIHRoZSBvcmlnaW4vcmVzb2x1dGlvbiBvZiB0aGUgZmlyc3QgaW1hZ2UuXG4gICAgICBpZiAoaW1hZ2VXaW5kb3cpIHtcbiAgICAgICAgY29uc3QgW29YLCBvWV0gPSBmaXJzdEltYWdlLmdldE9yaWdpbigpO1xuICAgICAgICBjb25zdCBbclgsIHJZXSA9IGZpcnN0SW1hZ2UuZ2V0UmVzb2x1dGlvbigpO1xuXG4gICAgICAgIGJib3ggPSBbXG4gICAgICAgICAgb1ggKyAoaW1hZ2VXaW5kb3dbMF0gKiByWCksXG4gICAgICAgICAgb1kgKyAoaW1hZ2VXaW5kb3dbMV0gKiByWSksXG4gICAgICAgICAgb1ggKyAoaW1hZ2VXaW5kb3dbMl0gKiByWCksXG4gICAgICAgICAgb1kgKyAoaW1hZ2VXaW5kb3dbM10gKiByWSksXG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgYSBiYm94IChvciBjYWxjdWxhdGVkIG9uZSlcblxuICAgICAgY29uc3QgdXNlZEJCb3ggPSBiYm94IHx8IGltZ0JCb3g7XG5cbiAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICBpZiAocmVzWCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCB3aWR0aCBhbmQgcmVzWCBwYXNzZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXNYID0gKHVzZWRCQm94WzJdIC0gdXNlZEJCb3hbMF0pIC8gd2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0KSB7XG4gICAgICAgIGlmIChyZXNZKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIHdpZHRoIGFuZCByZXNZIHBhc3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJlc1kgPSAodXNlZEJCb3hbM10gLSB1c2VkQkJveFsxXSkgLyBoZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgcmVzb2x1dGlvbiBpcyBzZXQgb3IgY2FsY3VsYXRlZCwgdHJ5IHRvIGdldCB0aGUgaW1hZ2Ugd2l0aCB0aGUgd29yc3QgYWNjZXB0YWJsZSByZXNvbHV0aW9uXG4gICAgaWYgKHJlc1ggfHwgcmVzWSkge1xuICAgICAgY29uc3QgYWxsSW1hZ2VzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlQ291bnQ7ICsraSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IGF3YWl0IHRoaXMuZ2V0SW1hZ2UoaSk7XG4gICAgICAgIGNvbnN0IHsgU3ViZmlsZVR5cGU6IHN1YmZpbGVUeXBlLCBOZXdTdWJmaWxlVHlwZTogbmV3U3ViZmlsZVR5cGUgfSA9IGltYWdlLmZpbGVEaXJlY3Rvcnk7XG4gICAgICAgIGlmIChpID09PSAwIHx8IHN1YmZpbGVUeXBlID09PSAyIHx8IG5ld1N1YmZpbGVUeXBlICYgMSkge1xuICAgICAgICAgIGFsbEltYWdlcy5wdXNoKGltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhbGxJbWFnZXMuc29ydCgoYSwgYikgPT4gYS5nZXRXaWR0aCgpIC0gYi5nZXRXaWR0aCgpKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsSW1hZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gYWxsSW1hZ2VzW2ldO1xuICAgICAgICBjb25zdCBpbWdSZXNYID0gKGltZ0JCb3hbMl0gLSBpbWdCQm94WzBdKSAvIGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgIGNvbnN0IGltZ1Jlc1kgPSAoaW1nQkJveFszXSAtIGltZ0JCb3hbMV0pIC8gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgdXNlZEltYWdlID0gaW1hZ2U7XG4gICAgICAgIGlmICgocmVzWCAmJiByZXNYID4gaW1nUmVzWCkgfHwgKHJlc1kgJiYgcmVzWSA+IGltZ1Jlc1kpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd25kID0gaW1hZ2VXaW5kb3c7XG4gICAgaWYgKGJib3gpIHtcbiAgICAgIGNvbnN0IFtvWCwgb1ldID0gZmlyc3RJbWFnZS5nZXRPcmlnaW4oKTtcbiAgICAgIGNvbnN0IFtpbWFnZVJlc1gsIGltYWdlUmVzWV0gPSB1c2VkSW1hZ2UuZ2V0UmVzb2x1dGlvbihmaXJzdEltYWdlKTtcblxuICAgICAgd25kID0gW1xuICAgICAgICBNYXRoLnJvdW5kKChiYm94WzBdIC0gb1gpIC8gaW1hZ2VSZXNYKSxcbiAgICAgICAgTWF0aC5yb3VuZCgoYmJveFsxXSAtIG9ZKSAvIGltYWdlUmVzWSksXG4gICAgICAgIE1hdGgucm91bmQoKGJib3hbMl0gLSBvWCkgLyBpbWFnZVJlc1gpLFxuICAgICAgICBNYXRoLnJvdW5kKChiYm94WzNdIC0gb1kpIC8gaW1hZ2VSZXNZKSxcbiAgICAgIF07XG4gICAgICB3bmQgPSBbXG4gICAgICAgIE1hdGgubWluKHduZFswXSwgd25kWzJdKSxcbiAgICAgICAgTWF0aC5taW4od25kWzFdLCB3bmRbM10pLFxuICAgICAgICBNYXRoLm1heCh3bmRbMF0sIHduZFsyXSksXG4gICAgICAgIE1hdGgubWF4KHduZFsxXSwgd25kWzNdKSxcbiAgICAgIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVzZWRJbWFnZS5yZWFkUmFzdGVycyh7IC4uLm9wdGlvbnMsIHdpbmRvdzogd25kIH0pO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gR2VvVElGRk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NhY2hlPWZhbHNlXSB3aGV0aGVyIG9yIG5vdCBkZWNvZGVkIHRpbGVzIHNoYWxsIGJlIGNhY2hlZC5cbiAqL1xuXG4vKipcbiAqIFRoZSBhYnN0cmFjdGlvbiBmb3IgYSB3aG9sZSBHZW9USUZGIGZpbGUuXG4gKiBAYXVnbWVudHMgR2VvVElGRkJhc2VcbiAqL1xuY2xhc3MgR2VvVElGRiBleHRlbmRzIEdlb1RJRkZCYXNlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSBUaGUgZGF0YXNvdXJjZSB0byByZWFkIGZyb20uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdGhlIGltYWdlIHVzZXMgbGl0dGxlIGVuZGlhbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBiaWdUaWZmIFdoZXRoZXIgdGhlIGltYWdlIHVzZXMgYmlnVElGRiBjb252ZW50aW9ucy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZpcnN0SUZET2Zmc2V0IFRoZSBudW1lcmljIGJ5dGUtb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBpbWFnZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIGZpcnN0IElGRC5cbiAgICogQHBhcmFtIHtHZW9USUZGT3B0aW9uc30gW29wdGlvbnNdIGZ1cnRoZXIgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgbGl0dGxlRW5kaWFuLCBiaWdUaWZmLCBmaXJzdElGRE9mZnNldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbjtcbiAgICB0aGlzLmJpZ1RpZmYgPSBiaWdUaWZmO1xuICAgIHRoaXMuZmlyc3RJRkRPZmZzZXQgPSBmaXJzdElGRE9mZnNldDtcbiAgICB0aGlzLmNhY2hlID0gb3B0aW9ucy5jYWNoZSB8fCBmYWxzZTtcbiAgICB0aGlzLmlmZFJlcXVlc3RzID0gW107XG4gICAgdGhpcy5naG9zdFZhbHVlcyA9IG51bGw7XG4gIH1cblxuICBhc3luYyBnZXRTbGljZShvZmZzZXQsIHNpemUpIHtcbiAgICBjb25zdCBmYWxsYmFja1NpemUgPSB0aGlzLmJpZ1RpZmYgPyA0MDQ4IDogMTAyNDtcbiAgICByZXR1cm4gbmV3IERhdGFTbGljZShcbiAgICAgIChhd2FpdCB0aGlzLnNvdXJjZS5mZXRjaChbe1xuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGxlbmd0aDogdHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnID8gc2l6ZSA6IGZhbGxiYWNrU2l6ZSxcbiAgICAgIH1dKSlbMF0sXG4gICAgICBvZmZzZXQsXG4gICAgICB0aGlzLmxpdHRsZUVuZGlhbixcbiAgICAgIHRoaXMuYmlnVGlmZixcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3RydWN0cyB0byBwYXJzZSBhbiBpbWFnZSBmaWxlIGRpcmVjdG9yeSBhdCB0aGUgZ2l2ZW4gZmlsZSBvZmZzZXQuXG4gICAqIEFzIHRoZXJlIGlzIG5vIHdheSB0byBlbnN1cmUgdGhhdCBhIGxvY2F0aW9uIGlzIGluZGVlZCB0aGUgc3RhcnQgb2YgYW4gSUZELFxuICAgKiB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIHdpdGggY2F1dGlvbiAoZS5nIG9ubHkgdXNpbmcgdGhlIElGRCBvZmZzZXRzIGZyb21cbiAgICogdGhlIGhlYWRlcnMgb3Igb3RoZXIgSUZEcykuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIG9mZnNldCB0byBwYXJzZSB0aGUgSUZEIGF0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEltYWdlRmlsZURpcmVjdG9yeT59IHRoZSBwYXJzZWQgSUZEXG4gICAqL1xuICBhc3luYyBwYXJzZUZpbGVEaXJlY3RvcnlBdChvZmZzZXQpIHtcbiAgICBjb25zdCBlbnRyeVNpemUgPSB0aGlzLmJpZ1RpZmYgPyAyMCA6IDEyO1xuICAgIGNvbnN0IG9mZnNldFNpemUgPSB0aGlzLmJpZ1RpZmYgPyA4IDogMjtcblxuICAgIGxldCBkYXRhU2xpY2UgPSBhd2FpdCB0aGlzLmdldFNsaWNlKG9mZnNldCk7XG4gICAgY29uc3QgbnVtRGlyRW50cmllcyA9IHRoaXMuYmlnVGlmZlxuICAgICAgPyBkYXRhU2xpY2UucmVhZFVpbnQ2NChvZmZzZXQpXG4gICAgICA6IGRhdGFTbGljZS5yZWFkVWludDE2KG9mZnNldCk7XG5cbiAgICAvLyBpZiB0aGUgc2xpY2UgZG9lcyBub3QgY292ZXIgdGhlIHdob2xlIElGRCwgcmVxdWVzdCBhIGJpZ2dlciBzbGljZSwgd2hlcmUgdGhlXG4gICAgLy8gd2hvbGUgSUZEIGZpdHM6IG51bSBvZiBlbnRyaWVzICsgbiB4IHRhZyBsZW5ndGggKyBvZmZzZXQgdG8gbmV4dCBJRkRcbiAgICBjb25zdCBieXRlU2l6ZSA9IChudW1EaXJFbnRyaWVzICogZW50cnlTaXplKSArICh0aGlzLmJpZ1RpZmYgPyAxNiA6IDYpO1xuICAgIGlmICghZGF0YVNsaWNlLmNvdmVycyhvZmZzZXQsIGJ5dGVTaXplKSkge1xuICAgICAgZGF0YVNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShvZmZzZXQsIGJ5dGVTaXplKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlRGlyZWN0b3J5ID0ge307XG5cbiAgICAvLyBsb29wIG92ZXIgdGhlIElGRCBhbmQgY3JlYXRlIGEgZmlsZSBkaXJlY3Rvcnkgb2JqZWN0XG4gICAgbGV0IGkgPSBvZmZzZXQgKyAodGhpcy5iaWdUaWZmID8gOCA6IDIpO1xuICAgIGZvciAobGV0IGVudHJ5Q291bnQgPSAwOyBlbnRyeUNvdW50IDwgbnVtRGlyRW50cmllczsgaSArPSBlbnRyeVNpemUsICsrZW50cnlDb3VudCkge1xuICAgICAgY29uc3QgZmllbGRUYWcgPSBkYXRhU2xpY2UucmVhZFVpbnQxNihpKTtcbiAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IGRhdGFTbGljZS5yZWFkVWludDE2KGkgKyAyKTtcbiAgICAgIGNvbnN0IHR5cGVDb3VudCA9IHRoaXMuYmlnVGlmZlxuICAgICAgICA/IGRhdGFTbGljZS5yZWFkVWludDY0KGkgKyA0KVxuICAgICAgICA6IGRhdGFTbGljZS5yZWFkVWludDMyKGkgKyA0KTtcblxuICAgICAgbGV0IGZpZWxkVmFsdWVzO1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgY29uc3QgZmllbGRUeXBlTGVuZ3RoID0gZ2V0RmllbGRUeXBlTGVuZ3RoKGZpZWxkVHlwZSk7XG4gICAgICBjb25zdCB2YWx1ZU9mZnNldCA9IGkgKyAodGhpcy5iaWdUaWZmID8gMTIgOiA4KTtcblxuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgdmFsdWUgaXMgZGlyZWN0bHkgZW5jb2RlZCBpbiB0aGUgdGFnIG9yIHJlZmVycyB0byBhXG4gICAgICAvLyBkaWZmZXJlbnQgZXh0ZXJuYWwgYnl0ZSByYW5nZVxuICAgICAgaWYgKGZpZWxkVHlwZUxlbmd0aCAqIHR5cGVDb3VudCA8PSAodGhpcy5iaWdUaWZmID8gOCA6IDQpKSB7XG4gICAgICAgIGZpZWxkVmFsdWVzID0gZ2V0VmFsdWVzKGRhdGFTbGljZSwgZmllbGRUeXBlLCB0eXBlQ291bnQsIHZhbHVlT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlc29sdmUgdGhlIHJlZmVyZW5jZSB0byB0aGUgYWN0dWFsIGJ5dGUgcmFuZ2VcbiAgICAgICAgY29uc3QgYWN0dWFsT2Zmc2V0ID0gZGF0YVNsaWNlLnJlYWRPZmZzZXQodmFsdWVPZmZzZXQpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZFR5cGVMZW5ndGgoZmllbGRUeXBlKSAqIHR5cGVDb3VudDtcblxuICAgICAgICAvLyBjaGVjaywgd2hldGhlciB3ZSBhY3R1YWxseSBjb3ZlciB0aGUgcmVmZXJlbmNlZCBieXRlIHJhbmdlOyBpZiBub3QsXG4gICAgICAgIC8vIHJlcXVlc3QgYSBuZXcgc2xpY2Ugb2YgYnl0ZXMgdG8gcmVhZCBmcm9tIGl0XG4gICAgICAgIGlmIChkYXRhU2xpY2UuY292ZXJzKGFjdHVhbE9mZnNldCwgbGVuZ3RoKSkge1xuICAgICAgICAgIGZpZWxkVmFsdWVzID0gZ2V0VmFsdWVzKGRhdGFTbGljZSwgZmllbGRUeXBlLCB0eXBlQ291bnQsIGFjdHVhbE9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZmllbGREYXRhU2xpY2UgPSBhd2FpdCB0aGlzLmdldFNsaWNlKGFjdHVhbE9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICBmaWVsZFZhbHVlcyA9IGdldFZhbHVlcyhmaWVsZERhdGFTbGljZSwgZmllbGRUeXBlLCB0eXBlQ291bnQsIGFjdHVhbE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdW5wYWNrIHNpbmdsZSB2YWx1ZXMgZnJvbSB0aGUgYXJyYXlcbiAgICAgIGlmICh0eXBlQ291bnQgPT09IDEgJiYgYXJyYXlGaWVsZHMuaW5kZXhPZihmaWVsZFRhZykgPT09IC0xXG4gICAgICAgICYmICEoZmllbGRUeXBlID09PSBmaWVsZFR5cGVzLlJBVElPTkFMIHx8IGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5TUkFUSU9OQUwpKSB7XG4gICAgICAgIHZhbHVlID0gZmllbGRWYWx1ZXNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGZpZWxkVmFsdWVzO1xuICAgICAgfVxuXG4gICAgICAvLyB3cml0ZSB0aGUgdGFncyB2YWx1ZSB0byB0aGUgZmlsZSBkaXJlY3RseVxuICAgICAgZmlsZURpcmVjdG9yeVtmaWVsZFRhZ05hbWVzW2ZpZWxkVGFnXV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgZ2VvS2V5RGlyZWN0b3J5ID0gcGFyc2VHZW9LZXlEaXJlY3RvcnkoZmlsZURpcmVjdG9yeSk7XG4gICAgY29uc3QgbmV4dElGREJ5dGVPZmZzZXQgPSBkYXRhU2xpY2UucmVhZE9mZnNldChcbiAgICAgIG9mZnNldCArIG9mZnNldFNpemUgKyAoZW50cnlTaXplICogbnVtRGlyRW50cmllcyksXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgSW1hZ2VGaWxlRGlyZWN0b3J5KFxuICAgICAgZmlsZURpcmVjdG9yeSxcbiAgICAgIGdlb0tleURpcmVjdG9yeSxcbiAgICAgIG5leHRJRkRCeXRlT2Zmc2V0LFxuICAgICk7XG4gIH1cblxuICBhc3luYyByZXF1ZXN0SUZEKGluZGV4KSB7XG4gICAgLy8gc2VlIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGF0IElGRCBpbmRleCByZXF1ZXN0ZWQuXG4gICAgaWYgKHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdKSB7XG4gICAgICAvLyBhdHRhY2ggdG8gYW4gYWxyZWFkeSByZXF1ZXN0ZWQgSUZEXG4gICAgICByZXR1cm4gdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF07XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBpbmRleCAwXG4gICAgICB0aGlzLmlmZFJlcXVlc3RzW2luZGV4XSA9IHRoaXMucGFyc2VGaWxlRGlyZWN0b3J5QXQodGhpcy5maXJzdElGRE9mZnNldCk7XG4gICAgICByZXR1cm4gdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF07XG4gICAgfSBlbHNlIGlmICghdGhpcy5pZmRSZXF1ZXN0c1tpbmRleCAtIDFdKSB7XG4gICAgICAvLyBpZiB0aGUgcHJldmlvdXMgSUZEIHdhcyBub3QgeWV0IGxvYWRlZCwgbG9hZCB0aGF0IG9uZSBmaXJzdFxuICAgICAgLy8gdGhpcyBpcyB0aGUgcmVjdXJzaXZlIGNhbGwuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlmZFJlcXVlc3RzW2luZGV4IC0gMV0gPSB0aGlzLnJlcXVlc3RJRkQoaW5kZXggLSAxKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIG9uZSBhbHJlYWR5IHdhcyBhbiBpbmRleCBlcnJvciwgcmV0aHJvd1xuICAgICAgICAvLyB3aXRoIHRoZSBjdXJyZW50IGluZGV4XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgR2VvVElGRkltYWdlSW5kZXhFcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBHZW9USUZGSW1hZ2VJbmRleEVycm9yKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXRocm93IGFueXRoaW5nIGVsc2VcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgdGhlIHByZXZpb3VzIElGRCB3YXMgbG9hZGVkLCB3ZSBjYW4gZmluYWxseSBmZXRjaCB0aGUgb25lIHdlIGFyZSBpbnRlcmVzdGVkIGluLlxuICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIGFuIElJRkUsIG90aGVyd2lzZSB0aGlzLmlmZFJlcXVlc3RzW2luZGV4XSB3b3VsZCBiZSBkZWxheWVkXG4gICAgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF0gPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJldmlvdXNJZmQgPSBhd2FpdCB0aGlzLmlmZFJlcXVlc3RzW2luZGV4IC0gMV07XG4gICAgICBpZiAocHJldmlvdXNJZmQubmV4dElGREJ5dGVPZmZzZXQgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEdlb1RJRkZJbWFnZUluZGV4RXJyb3IoaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGaWxlRGlyZWN0b3J5QXQocHJldmlvdXNJZmQubmV4dElGREJ5dGVPZmZzZXQpO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbi10aCBpbnRlcm5hbCBzdWJmaWxlIG9mIGFuIGltYWdlLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF0gdGhlIGluZGV4IG9mIHRoZSBpbWFnZSB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEdlb1RJRkZJbWFnZT59IHRoZSBpbWFnZSBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICovXG4gIGFzeW5jIGdldEltYWdlKGluZGV4ID0gMCkge1xuICAgIGNvbnN0IGlmZCA9IGF3YWl0IHRoaXMucmVxdWVzdElGRChpbmRleCk7XG4gICAgcmV0dXJuIG5ldyBHZW9USUZGSW1hZ2UoXG4gICAgICBpZmQuZmlsZURpcmVjdG9yeSwgaWZkLmdlb0tleURpcmVjdG9yeSxcbiAgICAgIHRoaXMuZGF0YVZpZXcsIHRoaXMubGl0dGxlRW5kaWFuLCB0aGlzLmNhY2hlLCB0aGlzLnNvdXJjZSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvdW50IG9mIHRoZSBpbnRlcm5hbCBzdWJmaWxlcy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gdGhlIG51bWJlciBvZiBpbnRlcm5hbCBzdWJmaWxlIGltYWdlc1xuICAgKi9cbiAgYXN5bmMgZ2V0SW1hZ2VDb3VudCgpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIC8vIGxvb3AgdW50aWwgd2UgcnVuIG91dCBvZiBJRkRzXG4gICAgbGV0IGhhc05leHQgPSB0cnVlO1xuICAgIHdoaWxlIChoYXNOZXh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3RJRkQoaW5kZXgpO1xuICAgICAgICArK2luZGV4O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEdlb1RJRkZJbWFnZUluZGV4RXJyb3IpIHtcbiAgICAgICAgICBoYXNOZXh0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZXMgb2YgdGhlIENPRyBnaG9zdCBhcmVhIGFzIGEgcGFyc2VkIG1hcC5cbiAgICogU2VlIGh0dHBzOi8vZ2RhbC5vcmcvZHJpdmVycy9yYXN0ZXIvY29nLmh0bWwjaGVhZGVyLWdob3N0LWFyZWEgZm9yIHJlZmVyZW5jZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSB0aGUgcGFyc2VkIGdob3N0IGFyZWEgb3IgbnVsbCwgaWYgbm8gc3VjaCBhcmVhIHdhcyBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0R2hvc3RWYWx1ZXMoKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iaWdUaWZmID8gMTYgOiA4O1xuICAgIGlmICh0aGlzLmdob3N0VmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5naG9zdFZhbHVlcztcbiAgICB9XG4gICAgY29uc3QgZGV0ZWN0aW9uU3RyaW5nID0gJ0dEQUxfU1RSVUNUVVJBTF9NRVRBREFUQV9TSVpFPSc7XG4gICAgY29uc3QgaGV1cmlzdGljQXJlYVNpemUgPSBkZXRlY3Rpb25TdHJpbmcubGVuZ3RoICsgMTAwO1xuICAgIGxldCBzbGljZSA9IGF3YWl0IHRoaXMuZ2V0U2xpY2Uob2Zmc2V0LCBoZXVyaXN0aWNBcmVhU2l6ZSk7XG4gICAgaWYgKGRldGVjdGlvblN0cmluZyA9PT0gZ2V0VmFsdWVzKHNsaWNlLCBmaWVsZFR5cGVzLkFTQ0lJLCBkZXRlY3Rpb25TdHJpbmcubGVuZ3RoLCBvZmZzZXQpKSB7XG4gICAgICBjb25zdCB2YWx1ZXNTdHJpbmcgPSBnZXRWYWx1ZXMoc2xpY2UsIGZpZWxkVHlwZXMuQVNDSUksIGhldXJpc3RpY0FyZWFTaXplLCBvZmZzZXQpO1xuICAgICAgY29uc3QgZmlyc3RMaW5lID0gdmFsdWVzU3RyaW5nLnNwbGl0KCdcXG4nKVswXTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhU2l6ZSA9IE51bWJlcihmaXJzdExpbmUuc3BsaXQoJz0nKVsxXS5zcGxpdCgnICcpWzBdKSArIGZpcnN0TGluZS5sZW5ndGg7XG4gICAgICBpZiAobWV0YWRhdGFTaXplID4gaGV1cmlzdGljQXJlYVNpemUpIHtcbiAgICAgICAgc2xpY2UgPSBhd2FpdCB0aGlzLmdldFNsaWNlKG9mZnNldCwgbWV0YWRhdGFTaXplKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZ1bGxTdHJpbmcgPSBnZXRWYWx1ZXMoc2xpY2UsIGZpZWxkVHlwZXMuQVNDSUksIG1ldGFkYXRhU2l6ZSwgb2Zmc2V0KTtcbiAgICAgIHRoaXMuZ2hvc3RWYWx1ZXMgPSB7fTtcbiAgICAgIGZ1bGxTdHJpbmdcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAuZmlsdGVyKChsaW5lKSA9PiBsaW5lLmxlbmd0aCA+IDApXG4gICAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUuc3BsaXQoJz0nKSlcbiAgICAgICAgLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIHRoaXMuZ2hvc3RWYWx1ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2hvc3RWYWx1ZXM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSAoR2VvKVRJRkYgZmlsZSBmcm9tIHRoZSBnaXZlbiBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gc291cmNlIFRoZSBzb3VyY2Ugb2YgZGF0YSB0byBwYXJzZSBmcm9tLlxuICAgKiBAcGFyYW0ge0dlb1RJRkZPcHRpb25zfSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0aGF0IG1heSBiZSBzaWduYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21Tb3VyY2Uoc291cmNlLCBvcHRpb25zLCBzaWduYWwpIHtcbiAgICBjb25zdCBoZWFkZXJEYXRhID0gKGF3YWl0IHNvdXJjZS5mZXRjaChbeyBvZmZzZXQ6IDAsIGxlbmd0aDogMTAyNCB9XSwgc2lnbmFsKSlbMF07XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXc2NChoZWFkZXJEYXRhKTtcblxuICAgIGNvbnN0IEJPTSA9IGRhdGFWaWV3LmdldFVpbnQxNigwLCAwKTtcbiAgICBsZXQgbGl0dGxlRW5kaWFuO1xuICAgIGlmIChCT00gPT09IDB4NDk0OSkge1xuICAgICAgbGl0dGxlRW5kaWFuID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKEJPTSA9PT0gMHg0RDREKSB7XG4gICAgICBsaXR0bGVFbmRpYW4gPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBieXRlIG9yZGVyIHZhbHVlLicpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hZ2ljTnVtYmVyID0gZGF0YVZpZXcuZ2V0VWludDE2KDIsIGxpdHRsZUVuZGlhbik7XG4gICAgbGV0IGJpZ1RpZmY7XG4gICAgaWYgKG1hZ2ljTnVtYmVyID09PSA0Mikge1xuICAgICAgYmlnVGlmZiA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAobWFnaWNOdW1iZXIgPT09IDQzKSB7XG4gICAgICBiaWdUaWZmID0gdHJ1ZTtcbiAgICAgIGNvbnN0IG9mZnNldEJ5dGVTaXplID0gZGF0YVZpZXcuZ2V0VWludDE2KDQsIGxpdHRsZUVuZGlhbik7XG4gICAgICBpZiAob2Zmc2V0Qnl0ZVNpemUgIT09IDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvZmZzZXQgYnl0ZS1zaXplLicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1hZ2ljIG51bWJlci4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdElGRE9mZnNldCA9IGJpZ1RpZmZcbiAgICAgID8gZGF0YVZpZXcuZ2V0VWludDY0KDgsIGxpdHRsZUVuZGlhbilcbiAgICAgIDogZGF0YVZpZXcuZ2V0VWludDMyKDQsIGxpdHRsZUVuZGlhbik7XG4gICAgcmV0dXJuIG5ldyBHZW9USUZGKHNvdXJjZSwgbGl0dGxlRW5kaWFuLCBiaWdUaWZmLCBmaXJzdElGRE9mZnNldCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSB1bmRlcmx5aW5nIGZpbGUgYnVmZmVyXG4gICAqIE4uQi4gQWZ0ZXIgdGhlIEdlb1RJRkYgaGFzIGJlZW4gY29tcGxldGVseSBwcm9jZXNzZWQgaXQgbmVlZHNcbiAgICogdG8gYmUgY2xvc2VkIGJ1dCBvbmx5IGlmIGl0IGhhcyBiZWVuIGNvbnN0cnVjdGVkIGZyb20gYSBmaWxlLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZS5jbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNsb3NlKCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgeyBHZW9USUZGIH07XG5leHBvcnQgZGVmYXVsdCBHZW9USUZGO1xuXG4vKipcbiAqIFdyYXBwZXIgZm9yIEdlb1RJRkYgZmlsZXMgdGhhdCBoYXZlIGV4dGVybmFsIG92ZXJ2aWV3cy5cbiAqIEBhdWdtZW50cyBHZW9USUZGQmFzZVxuICovXG5jbGFzcyBNdWx0aUdlb1RJRkYgZXh0ZW5kcyBHZW9USUZGQmFzZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgTXVsdGlHZW9USUZGIGZyb20gYSBtYWluIGFuZCBzZXZlcmFsIG92ZXJ2aWV3IGZpbGVzLlxuICAgKiBAcGFyYW0ge0dlb1RJRkZ9IG1haW5GaWxlIFRoZSBtYWluIEdlb1RJRkYgZmlsZS5cbiAgICogQHBhcmFtIHtHZW9USUZGW119IG92ZXJ2aWV3RmlsZXMgQW4gYXJyYXkgb2Ygb3ZlcnZpZXcgZmlsZXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYWluRmlsZSwgb3ZlcnZpZXdGaWxlcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tYWluRmlsZSA9IG1haW5GaWxlO1xuICAgIHRoaXMub3ZlcnZpZXdGaWxlcyA9IG92ZXJ2aWV3RmlsZXM7XG4gICAgdGhpcy5pbWFnZUZpbGVzID0gW21haW5GaWxlXS5jb25jYXQob3ZlcnZpZXdGaWxlcyk7XG5cbiAgICB0aGlzLmZpbGVEaXJlY3Rvcmllc1BlckZpbGUgPSBudWxsO1xuICAgIHRoaXMuZmlsZURpcmVjdG9yaWVzUGVyRmlsZVBhcnNpbmcgPSBudWxsO1xuICAgIHRoaXMuaW1hZ2VDb3VudCA9IG51bGw7XG4gIH1cblxuICBhc3luYyBwYXJzZUZpbGVEaXJlY3Rvcmllc1BlckZpbGUoKSB7XG4gICAgY29uc3QgcmVxdWVzdHMgPSBbdGhpcy5tYWluRmlsZS5wYXJzZUZpbGVEaXJlY3RvcnlBdCh0aGlzLm1haW5GaWxlLmZpcnN0SUZET2Zmc2V0KV1cbiAgICAgIC5jb25jYXQodGhpcy5vdmVydmlld0ZpbGVzLm1hcCgoZmlsZSkgPT4gZmlsZS5wYXJzZUZpbGVEaXJlY3RvcnlBdChmaWxlLmZpcnN0SUZET2Zmc2V0KSkpO1xuXG4gICAgdGhpcy5maWxlRGlyZWN0b3JpZXNQZXJGaWxlID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdHMpO1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3Rvcmllc1BlckZpbGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuLXRoIGludGVybmFsIHN1YmZpbGUgb2YgYW4gaW1hZ2UuIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD0wXSB0aGUgaW5kZXggb2YgdGhlIGltYWdlIHRvIHJldHVybi5cbiAgICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRkltYWdlPn0gdGhlIGltYWdlIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKi9cbiAgYXN5bmMgZ2V0SW1hZ2UoaW5kZXggPSAwKSB7XG4gICAgYXdhaXQgdGhpcy5nZXRJbWFnZUNvdW50KCk7XG4gICAgYXdhaXQgdGhpcy5wYXJzZUZpbGVEaXJlY3Rvcmllc1BlckZpbGUoKTtcbiAgICBsZXQgdmlzaXRlZCA9IDA7XG4gICAgbGV0IHJlbGF0aXZlSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbWFnZUZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbWFnZUZpbGUgPSB0aGlzLmltYWdlRmlsZXNbaV07XG4gICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgdGhpcy5pbWFnZUNvdW50c1tpXTsgaWkrKykge1xuICAgICAgICBpZiAoaW5kZXggPT09IHZpc2l0ZWQpIHtcbiAgICAgICAgICBjb25zdCBpZmQgPSBhd2FpdCBpbWFnZUZpbGUucmVxdWVzdElGRChyZWxhdGl2ZUluZGV4KTtcbiAgICAgICAgICByZXR1cm4gbmV3IEdlb1RJRkZJbWFnZShcbiAgICAgICAgICAgIGlmZC5maWxlRGlyZWN0b3J5LCBpZmQuZ2VvS2V5RGlyZWN0b3J5LFxuICAgICAgICAgICAgaW1hZ2VGaWxlLmRhdGFWaWV3LCBpbWFnZUZpbGUubGl0dGxlRW5kaWFuLCBpbWFnZUZpbGUuY2FjaGUsIGltYWdlRmlsZS5zb3VyY2UsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkKys7XG4gICAgICAgIHJlbGF0aXZlSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlSW5kZXggPSAwO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGltYWdlIGluZGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY291bnQgb2YgdGhlIGludGVybmFsIHN1YmZpbGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSB0aGUgbnVtYmVyIG9mIGludGVybmFsIHN1YmZpbGUgaW1hZ2VzXG4gICAqL1xuICBhc3luYyBnZXRJbWFnZUNvdW50KCkge1xuICAgIGlmICh0aGlzLmltYWdlQ291bnQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlQ291bnQ7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RzID0gW3RoaXMubWFpbkZpbGUuZ2V0SW1hZ2VDb3VudCgpXVxuICAgICAgLmNvbmNhdCh0aGlzLm92ZXJ2aWV3RmlsZXMubWFwKChmaWxlKSA9PiBmaWxlLmdldEltYWdlQ291bnQoKSkpO1xuICAgIHRoaXMuaW1hZ2VDb3VudHMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXF1ZXN0cyk7XG4gICAgdGhpcy5pbWFnZUNvdW50ID0gdGhpcy5pbWFnZUNvdW50cy5yZWR1Y2UoKGNvdW50LCBpZmRzKSA9PiBjb3VudCArIGlmZHMsIDApO1xuICAgIHJldHVybiB0aGlzLmltYWdlQ291bnQ7XG4gIH1cbn1cblxuZXhwb3J0IHsgTXVsdGlHZW9USUZGIH07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBHZW9USUZGIGZyb20gYSByZW1vdGUgVVJMLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIGFjY2VzcyB0aGUgaW1hZ2UgZnJvbVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgc291cmNlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rIG1ha2VSZW1vdGVTb3VyY2V9IGZvciBkZXRhaWxzLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tVXJsKHVybCwgb3B0aW9ucyA9IHt9LCBzaWduYWwpIHtcbiAgcmV0dXJuIEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlUmVtb3RlU291cmNlKHVybCwgb3B0aW9ucyksIHNpZ25hbCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBHZW9USUZGIGZyb20gYSBjdXN0b20ge0BsaW5rIEJhc2VDbGllbnR9LlxuICogQHBhcmFtIHtCYXNlQ2xpZW50fSBjbGllbnQgVGhlIGNsaWVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayBtYWtlUmVtb3RlU291cmNlfSBmb3IgZGV0YWlscy5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbUN1c3RvbUNsaWVudChjbGllbnQsIG9wdGlvbnMgPSB7fSwgc2lnbmFsKSB7XG4gIHJldHVybiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZUN1c3RvbVNvdXJjZShjbGllbnQsIG9wdGlvbnMpLCBzaWduYWwpO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhIG5ldyBHZW9USUZGIGZyb20gYW5cbiAqIFtBcnJheUJ1ZmZlcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXlCdWZmZXJ9LlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGRhdGEgdG8gcmVhZCB0aGUgZmlsZSBmcm9tLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIsIHNpZ25hbCkge1xuICByZXR1cm4gR2VvVElGRi5mcm9tU291cmNlKG1ha2VCdWZmZXJTb3VyY2UoYXJyYXlCdWZmZXIpLCBzaWduYWwpO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhIEdlb1RJRkYgZnJvbSBhIGxvY2FsIGZpbGUgcGF0aC4gVGhpcyB1c2VzIHRoZSBub2RlXG4gKiBbZmlsZXN5c3RlbSBBUElde0BsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbH0gYW5kIGlzXG4gKiBub3QgYXZhaWxhYmxlIG9uIGJyb3dzZXJzLlxuICpcbiAqIE4uQi4gQWZ0ZXIgdGhlIEdlb1RJRkYgaGFzIGJlZW4gY29tcGxldGVseSBwcm9jZXNzZWQgaXQgbmVlZHNcbiAqIHRvIGJlIGNsb3NlZCBidXQgb25seSBpZiBpdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBmcm9tIGEgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBmaWxlIHBhdGggdG8gcmVhZCBmcm9tLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tRmlsZShwYXRoLCBzaWduYWwpIHtcbiAgcmV0dXJuIEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlRmlsZVNvdXJjZShwYXRoKSwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBHZW9USUZGIGZyb20gYW4gSFRNTFxuICogW0Jsb2Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9ifSBvclxuICogW0ZpbGVde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlfVxuICogb2JqZWN0LlxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGJsb2IgVGhlIEJsb2Igb3IgRmlsZSBvYmplY3QgdG8gcmVhZCBmcm9tLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tQmxvYihibG9iLCBzaWduYWwpIHtcbiAgcmV0dXJuIEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlRmlsZVJlYWRlclNvdXJjZShibG9iKSwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBNdWx0aUdlb1RJRkYgZnJvbSB0aGUgZ2l2ZW4gVVJMcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYWluVXJsIFRoZSBVUkwgZm9yIHRoZSBtYWluIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvdmVydmlld1VybHMgQW4gYXJyYXkgb2YgVVJMcyBmb3IgdGhlIG92ZXJ2aWV3IGltYWdlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIFttYWtlUmVtb3RlU291cmNlXXtAbGluayBtb2R1bGU6c291cmNlLm1ha2VSZW1vdGVTb3VyY2V9XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBkZXRhaWxzLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNdWx0aUdlb1RJRkY+fSBUaGUgcmVzdWx0aW5nIE11bHRpR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbVVybHMobWFpblVybCwgb3ZlcnZpZXdVcmxzID0gW10sIG9wdGlvbnMgPSB7fSwgc2lnbmFsKSB7XG4gIGNvbnN0IG1haW5GaWxlID0gYXdhaXQgR2VvVElGRi5mcm9tU291cmNlKG1ha2VSZW1vdGVTb3VyY2UobWFpblVybCwgb3B0aW9ucyksIHNpZ25hbCk7XG4gIGNvbnN0IG92ZXJ2aWV3RmlsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBvdmVydmlld1VybHMubWFwKCh1cmwpID0+IEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlUmVtb3RlU291cmNlKHVybCwgb3B0aW9ucykpKSxcbiAgKTtcblxuICByZXR1cm4gbmV3IE11bHRpR2VvVElGRihtYWluRmlsZSwgb3ZlcnZpZXdGaWxlcyk7XG59XG5cbi8qKlxuICogTWFpbiBjcmVhdGluZyBmdW5jdGlvbiBmb3IgR2VvVElGRiBmaWxlcy5cbiAqIEBwYXJhbSB7KEFycmF5KX0gYXJyYXkgb2YgcGl4ZWwgdmFsdWVzXG4gKiBAcmV0dXJucyB7bWV0YWRhdGF9IG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUFycmF5QnVmZmVyKHZhbHVlcywgbWV0YWRhdGEpIHtcbiAgcmV0dXJuIHdyaXRlR2VvdGlmZih2YWx1ZXMsIG1ldGFkYXRhKTtcbn1cblxuZXhwb3J0IHsgUG9vbCB9O1xuZXhwb3J0IHsgR2VvVElGRkltYWdlIH07XG5leHBvcnQgeyBCYXNlQ2xpZW50LCBCYXNlUmVzcG9uc2UgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/geotiff.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/geotiffimage.js":
/*!**********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffimage.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @petamoriken/float16 */ \"(ssr)/./node_modules/@petamoriken/float16/src/DataView.mjs\");\n/* harmony import */ var xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xml-utils/get-attribute.js */ \"(ssr)/./node_modules/xml-utils/get-attribute.js\");\n/* harmony import */ var xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xml-utils/find-tags-by-name.js */ \"(ssr)/./node_modules/xml-utils/find-tags-by-name.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./globals.js */ \"(ssr)/./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rgb.js */ \"(ssr)/./node_modules/geotiff/dist-module/rgb.js\");\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./compression/index.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/index.js\");\n/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resample.js */ \"(ssr)/./node_modules/geotiff/dist-module/resample.js\");\n/** @module geotiffimage */\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return (0,_petamoriken_float16__WEBPACK_IMPORTED_MODULE_2__.getFloat16)(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = (0,_resample_js__WEBPACK_IMPORTED_MODULE_3__.resampleInterleaved)(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = (0,_resample_js__WEBPACK_IMPORTED_MODULE_3__.resample)(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await (0,_compression_index_js__WEBPACK_IMPORTED_MODULE_4__.getDecoder)(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === _globals_js__WEBPACK_IMPORTED_MODULE_5__.ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.WhiteIsZero:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.BlackIsZero:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.YCbCr:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.WhiteIsZero:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromWhiteIsZero)(raster, max);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.BlackIsZero:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromBlackIsZero)(raster, max);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.Palette:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromPalette)(raster, fileDirectory.ColorMap);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CMYK:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromCMYK)(raster);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.YCbCr:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromYCbCr)(raster);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CIELab:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromCIELab)(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_1__(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoTIFFImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmaW1hZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNrRDtBQUNJO0FBQ007O0FBRWtCO0FBQzRCO0FBQ3REO0FBQ1U7O0FBRTlEO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZUFBZTtBQUM3QixjQUFjLGVBQWU7QUFDN0I7QUFDQSxjQUFjLGVBQWU7QUFDN0IsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsYUFBYTtBQUMzQjtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUNBQW1DO0FBQ2pELGNBQWMseUNBQXlDOztBQUV2RDtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQSxzQkFBc0Is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dEM7QUFDQSxlQUFlLHVEQUFZO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsWUFBWSxFQUFDIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2dlb3RpZmZpbWFnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQG1vZHVsZSBnZW90aWZmaW1hZ2UgKi9cbmltcG9ydCB7IGdldEZsb2F0MTYgfSBmcm9tICdAcGV0YW1vcmlrZW4vZmxvYXQxNic7XG5pbXBvcnQgZ2V0QXR0cmlidXRlIGZyb20gJ3htbC11dGlscy9nZXQtYXR0cmlidXRlLmpzJztcbmltcG9ydCBmaW5kVGFnc0J5TmFtZSBmcm9tICd4bWwtdXRpbHMvZmluZC10YWdzLWJ5LW5hbWUuanMnO1xuXG5pbXBvcnQgeyBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucywgRXh0cmFTYW1wbGVzVmFsdWVzIH0gZnJvbSAnLi9nbG9iYWxzLmpzJztcbmltcG9ydCB7IGZyb21XaGl0ZUlzWmVybywgZnJvbUJsYWNrSXNaZXJvLCBmcm9tUGFsZXR0ZSwgZnJvbUNNWUssIGZyb21ZQ2JDciwgZnJvbUNJRUxhYiB9IGZyb20gJy4vcmdiLmpzJztcbmltcG9ydCB7IGdldERlY29kZXIgfSBmcm9tICcuL2NvbXByZXNzaW9uL2luZGV4LmpzJztcbmltcG9ydCB7IHJlc2FtcGxlLCByZXNhbXBsZUludGVybGVhdmVkIH0gZnJvbSAnLi9yZXNhbXBsZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVhZFJhc3Rlck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW3dpbmRvdz13aG9sZSB3aW5kb3ddIHRoZSBzdWJzZXQgdG8gcmVhZCBkYXRhIGZyb20gaW4gcGl4ZWxzLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbYmJveD13aG9sZSBpbWFnZV0gdGhlIHN1YnNldCB0byByZWFkIGRhdGEgZnJvbSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbc2FtcGxlcz1hbGwgc2FtcGxlc10gdGhlIHNlbGVjdGlvbiBvZiBzYW1wbGVzIHRvIHJlYWQgZnJvbS4gRGVmYXVsdCBpcyBhbGwgc2FtcGxlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVybGVhdmU9ZmFsc2VdIHdoZXRoZXIgdGhlIGRhdGEgc2hhbGwgYmUgcmVhZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBvbmUgc2luZ2xlIGFycmF5IG9yIHNlcGFyYXRlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5cy5cbiAqIEBwcm9wZXJ0eSB7UG9vbH0gW3Bvb2w9bnVsbF0gVGhlIG9wdGlvbmFsIGRlY29kZXIgcG9vbCB0byB1c2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dpZHRoXSBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0LiBXaGVuIHRoZSB3aWR0aCBpcyBub3QgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWUgYXMgdGhlIGltYWdlcywgcmVzYW1wbGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaGVpZ2h0XSBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dC4gV2hlbiB0aGUgd2lkdGggaXMgbm90IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtZSBhcyB0aGUgaW1hZ2VzLCByZXNhbXBsaW5nIHdpbGwgYmUgcGVyZm9ybWVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtyZXNhbXBsZU1ldGhvZD0nbmVhcmVzdCddIFRoZSBkZXNpcmVkIHJlc2FtcGxpbmcgbWV0aG9kLlxuICogQHByb3BlcnR5IHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGFib3J0ZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bWJlcltdfSBbZmlsbFZhbHVlXSBUaGUgdmFsdWUgdG8gdXNlIGZvciBwYXJ0cyBvZiB0aGUgaW1hZ2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHNpZGUgb2YgdGhlIGltYWdlcyBleHRlbnQuIFdoZW4gbXVsdGlwbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZXMgYXJlIHJlcXVlc3RlZCwgYW4gYXJyYXkgb2YgZmlsbCB2YWx1ZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbiBiZSBwYXNzZWQuXG4gKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL2dlb3RpZmYuanNcIikuVHlwZWRBcnJheX0gVHlwZWRBcnJheSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL2dlb3RpZmYuanNcIikuUmVhZFJhc3RlclJlc3VsdH0gUmVhZFJhc3RlclJlc3VsdCAqL1xuXG5mdW5jdGlvbiBzdW0oYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHMgPSAwO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHMgKz0gYXJyYXlbaV07XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIGFycmF5Rm9yVHlwZShmb3JtYXQsIGJpdHNQZXJTYW1wbGUsIHNpemUpIHtcbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIDE6IC8vIHVuc2lnbmVkIGludGVnZXIgZGF0YVxuICAgICAgaWYgKGJpdHNQZXJTYW1wbGUgPD0gOCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPD0gMTYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA8PSAzMikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KHNpemUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOiAvLyB0d29zIGNvbXBsZW1lbnQgc2lnbmVkIGludGVnZXIgZGF0YVxuICAgICAgaWYgKGJpdHNQZXJTYW1wbGUgPT09IDgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPT09IDE2KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA9PT0gMzIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOiAvLyBmbG9hdGluZyBwb2ludCBkYXRhXG4gICAgICBzd2l0Y2ggKGJpdHNQZXJTYW1wbGUpIHtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShzaXplKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgZGF0YSBmb3JtYXQvYml0c1BlclNhbXBsZScpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24oZm9ybWF0LCBiaXRzUGVyU2FtcGxlKSB7XG4gIGlmICgoZm9ybWF0ID09PSAxIHx8IGZvcm1hdCA9PT0gMikgJiYgYml0c1BlclNhbXBsZSA8PSAzMiAmJiBiaXRzUGVyU2FtcGxlICUgOCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDMgJiYgKGJpdHNQZXJTYW1wbGUgPT09IDE2IHx8IGJpdHNQZXJTYW1wbGUgPT09IDMyIHx8IGJpdHNQZXJTYW1wbGUgPT09IDY0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkoaW5CdWZmZXIsIGZvcm1hdCwgcGxhbmFyQ29uZmlndXJhdGlvbiwgc2FtcGxlc1BlclBpeGVsLCBiaXRzUGVyU2FtcGxlLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQpIHtcbiAgLy8gY29uc3QgaW5CeXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShpbkJ1ZmZlcik7XG4gIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5CdWZmZXIpO1xuICBjb25zdCBvdXRTaXplID0gcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMlxuICAgID8gdGlsZUhlaWdodCAqIHRpbGVXaWR0aFxuICAgIDogdGlsZUhlaWdodCAqIHRpbGVXaWR0aCAqIHNhbXBsZXNQZXJQaXhlbDtcbiAgY29uc3Qgc2FtcGxlc1RvVHJhbnNmZXIgPSBwbGFuYXJDb25maWd1cmF0aW9uID09PSAyXG4gICAgPyAxIDogc2FtcGxlc1BlclBpeGVsO1xuICBjb25zdCBvdXRBcnJheSA9IGFycmF5Rm9yVHlwZShmb3JtYXQsIGJpdHNQZXJTYW1wbGUsIG91dFNpemUpO1xuICAvLyBsZXQgcGl4ZWwgPSAwO1xuXG4gIGNvbnN0IGJpdE1hc2sgPSBwYXJzZUludCgnMScucmVwZWF0KGJpdHNQZXJTYW1wbGUpLCAyKTtcblxuICBpZiAoZm9ybWF0ID09PSAxKSB7IC8vIHVuc2lnbmVkIGludGVnZXJcbiAgICAvLyB0cmFuc2xhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vT1NHZW8vZ2RhbC9ibG9iL21hc3Rlci9nZGFsL2ZybXRzL2d0aWZmL2dlb3RpZmYuY3BwI0w3MzM3XG4gICAgbGV0IHBpeGVsQml0U2tpcDtcbiAgICAvLyBsZXQgc2FtcGxlQml0T2Zmc2V0ID0gMDtcbiAgICBpZiAocGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMSkge1xuICAgICAgcGl4ZWxCaXRTa2lwID0gc2FtcGxlc1BlclBpeGVsICogYml0c1BlclNhbXBsZTtcbiAgICAgIC8vIHNhbXBsZUJpdE9mZnNldCA9IChzYW1wbGVzUGVyUGl4ZWwgLSAxKSAqIGJpdHNQZXJTYW1wbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBpeGVsQml0U2tpcCA9IGJpdHNQZXJTYW1wbGU7XG4gICAgfVxuXG4gICAgLy8gQml0cyBwZXIgbGluZSByb3VuZHMgdXAgdG8gbmV4dCBieXRlIGJvdW5kYXJ5LlxuICAgIGxldCBiaXRzUGVyTGluZSA9IHRpbGVXaWR0aCAqIHBpeGVsQml0U2tpcDtcbiAgICBpZiAoKGJpdHNQZXJMaW5lICYgNykgIT09IDApIHtcbiAgICAgIGJpdHNQZXJMaW5lID0gKGJpdHNQZXJMaW5lICsgNykgJiAofjcpO1xuICAgIH1cblxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGlsZUhlaWdodDsgKyt5KSB7XG4gICAgICBjb25zdCBsaW5lQml0T2Zmc2V0ID0geSAqIGJpdHNQZXJMaW5lO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aWxlV2lkdGg7ICsreCkge1xuICAgICAgICBjb25zdCBwaXhlbEJpdE9mZnNldCA9IGxpbmVCaXRPZmZzZXQgKyAoeCAqIHNhbXBsZXNUb1RyYW5zZmVyICogYml0c1BlclNhbXBsZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlc1RvVHJhbnNmZXI7ICsraSkge1xuICAgICAgICAgIGNvbnN0IGJpdE9mZnNldCA9IHBpeGVsQml0T2Zmc2V0ICsgKGkgKiBiaXRzUGVyU2FtcGxlKTtcbiAgICAgICAgICBjb25zdCBvdXRJbmRleCA9ICgoKHkgKiB0aWxlV2lkdGgpICsgeCkgKiBzYW1wbGVzVG9UcmFuc2ZlcikgKyBpO1xuXG4gICAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IE1hdGguZmxvb3IoYml0T2Zmc2V0IC8gOCk7XG4gICAgICAgICAgY29uc3QgaW5uZXJCaXRPZmZzZXQgPSBiaXRPZmZzZXQgJSA4O1xuICAgICAgICAgIGlmIChpbm5lckJpdE9mZnNldCArIGJpdHNQZXJTYW1wbGUgPD0gOCkge1xuICAgICAgICAgICAgb3V0QXJyYXlbb3V0SW5kZXhdID0gKHZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCkgPj4gKDggLSBiaXRzUGVyU2FtcGxlKSAtIGlubmVyQml0T2Zmc2V0KSAmIGJpdE1hc2s7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbm5lckJpdE9mZnNldCArIGJpdHNQZXJTYW1wbGUgPD0gMTYpIHtcbiAgICAgICAgICAgIG91dEFycmF5W291dEluZGV4XSA9ICh2aWV3LmdldFVpbnQxNihieXRlT2Zmc2V0KSA+PiAoMTYgLSBiaXRzUGVyU2FtcGxlKSAtIGlubmVyQml0T2Zmc2V0KSAmIGJpdE1hc2s7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbm5lckJpdE9mZnNldCArIGJpdHNQZXJTYW1wbGUgPD0gMjQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhdyA9ICh2aWV3LmdldFVpbnQxNihieXRlT2Zmc2V0KSA8PCA4KSB8ICh2aWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQgKyAyKSk7XG4gICAgICAgICAgICBvdXRBcnJheVtvdXRJbmRleF0gPSAocmF3ID4+ICgyNCAtIGJpdHNQZXJTYW1wbGUpIC0gaW5uZXJCaXRPZmZzZXQpICYgYml0TWFzaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0QXJyYXlbb3V0SW5kZXhdID0gKHZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQpID4+ICgzMiAtIGJpdHNQZXJTYW1wbGUpIC0gaW5uZXJCaXRPZmZzZXQpICYgYml0TWFzaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBsZXQgb3V0V29yZCA9IDA7XG4gICAgICAgICAgLy8gZm9yIChsZXQgYml0ID0gMDsgYml0IDwgYml0c1BlclNhbXBsZTsgKytiaXQpIHtcbiAgICAgICAgICAvLyAgIGlmIChpbkJ5dGVBcnJheVtiaXRPZmZzZXQgPj4gM11cbiAgICAgICAgICAvLyAgICAgJiAoMHg4MCA+PiAoYml0T2Zmc2V0ICYgNykpKSB7XG4gICAgICAgICAgLy8gICAgIG91dFdvcmQgfD0gKDEgPDwgKGJpdHNQZXJTYW1wbGUgLSAxIC0gYml0KSk7XG4gICAgICAgICAgLy8gICB9XG4gICAgICAgICAgLy8gICArK2JpdE9mZnNldDtcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAvLyBvdXRBcnJheVtvdXRJbmRleF0gPSBvdXRXb3JkO1xuICAgICAgICAgIC8vIG91dEFycmF5W3BpeGVsXSA9IG91dFdvcmQ7XG4gICAgICAgICAgLy8gcGl4ZWwgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBiaXRPZmZzZXQgPSBiaXRPZmZzZXQgKyBwaXhlbEJpdFNraXAgLSBiaXRzUGVyU2FtcGxlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDMpIHsgLy8gZmxvYXRpbmcgcG9pbnRcbiAgICAvLyBGbG9hdDE2IGlzIGhhbmRsZWQgZWxzZXdoZXJlXG4gICAgLy8gbm9ybWFsaXplIDE2LzI0IGJpdCBmbG9hdHMgdG8gMzIgYml0IGZsb2F0cyBpbiB0aGUgYXJyYXlcbiAgICAvLyBjb25zb2xlLnRpbWUoKTtcbiAgICAvLyBpZiAoYml0c1BlclNhbXBsZSA9PT0gMTYpIHtcbiAgICAvLyAgIGZvciAobGV0IGJ5dGUgPSAwLCBvdXRJbmRleCA9IDA7IGJ5dGUgPCBpbkJ1ZmZlci5ieXRlTGVuZ3RoOyBieXRlICs9IDIsICsrb3V0SW5kZXgpIHtcbiAgICAvLyAgICAgb3V0QXJyYXlbb3V0SW5kZXhdID0gZ2V0RmxvYXQxNih2aWV3LCBieXRlKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgLy8gY29uc29sZS50aW1lRW5kKClcbiAgfVxuXG4gIHJldHVybiBvdXRBcnJheS5idWZmZXI7XG59XG5cbi8qKlxuICogR2VvVElGRiBzdWItZmlsZSBpbWFnZS5cbiAqL1xuY2xhc3MgR2VvVElGRkltYWdlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gZmlsZURpcmVjdG9yeSBUaGUgcGFyc2VkIGZpbGUgZGlyZWN0b3J5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBnZW9LZXlzIFRoZSBwYXJzZWQgZ2VvLWtleXNcbiAgICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXcgVGhlIERhdGFWaWV3IGZvciB0aGUgdW5kZXJseWluZyBmaWxlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRoZSBmaWxlIGlzIGVuY29kZWQgaW4gbGl0dGxlIG9yIGJpZyBlbmRpYW5cbiAgICogQHBhcmFtIHtCb29sZWFufSBjYWNoZSBXaGV0aGVyIG9yIG5vdCBkZWNvZGVkIHRpbGVzIHNoYWxsIGJlIGNhY2hlZFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9zb3VyY2UvYmFzZXNvdXJjZScpLkJhc2VTb3VyY2V9IHNvdXJjZSBUaGUgZGF0YXNvdXJjZSB0byByZWFkIGZyb21cbiAgICovXG4gIGNvbnN0cnVjdG9yKGZpbGVEaXJlY3RvcnksIGdlb0tleXMsIGRhdGFWaWV3LCBsaXR0bGVFbmRpYW4sIGNhY2hlLCBzb3VyY2UpIHtcbiAgICB0aGlzLmZpbGVEaXJlY3RvcnkgPSBmaWxlRGlyZWN0b3J5O1xuICAgIHRoaXMuZ2VvS2V5cyA9IGdlb0tleXM7XG4gICAgdGhpcy5kYXRhVmlldyA9IGRhdGFWaWV3O1xuICAgIHRoaXMubGl0dGxlRW5kaWFuID0gbGl0dGxlRW5kaWFuO1xuICAgIHRoaXMudGlsZXMgPSBjYWNoZSA/IHt9IDogbnVsbDtcbiAgICB0aGlzLmlzVGlsZWQgPSAhZmlsZURpcmVjdG9yeS5TdHJpcE9mZnNldHM7XG4gICAgY29uc3QgcGxhbmFyQ29uZmlndXJhdGlvbiA9IGZpbGVEaXJlY3RvcnkuUGxhbmFyQ29uZmlndXJhdGlvbjtcbiAgICB0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPSAodHlwZW9mIHBsYW5hckNvbmZpZ3VyYXRpb24gPT09ICd1bmRlZmluZWQnKSA/IDEgOiBwbGFuYXJDb25maWd1cmF0aW9uO1xuICAgIGlmICh0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gIT09IDEgJiYgdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGxhbmFyIGNvbmZpZ3VyYXRpb24uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXNzb2NpYXRlZCBwYXJzZWQgZmlsZSBkaXJlY3RvcnkuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBwYXJzZWQgZmlsZSBkaXJlY3RvcnlcbiAgICovXG4gIGdldEZpbGVEaXJlY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3NvY2lhdGVkIHBhcnNlZCBnZW8ga2V5cy5cbiAgICogQHJldHVybnMge09iamVjdH0gdGhlIHBhcnNlZCBnZW8ga2V5c1xuICAgKi9cbiAgZ2V0R2VvS2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9LZXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBpbWFnZS5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSBpbWFnZVxuICAgKi9cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeS5JbWFnZVdpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgaW1hZ2UuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIGltYWdlXG4gICAqL1xuICBnZXRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeS5JbWFnZUxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgcGl4ZWxcbiAgICovXG4gIGdldFNhbXBsZXNQZXJQaXhlbCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVzUGVyUGl4ZWwgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVzUGVyUGl4ZWwgOiAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIGVhY2ggdGlsZS5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIHdpZHRoIG9mIGVhY2ggdGlsZVxuICAgKi9cbiAgZ2V0VGlsZVdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmlzVGlsZWQgPyB0aGlzLmZpbGVEaXJlY3RvcnkuVGlsZVdpZHRoIDogdGhpcy5nZXRXaWR0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiBlYWNoIHRpbGUuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgZWFjaCB0aWxlXG4gICAqL1xuICBnZXRUaWxlSGVpZ2h0KCkge1xuICAgIGlmICh0aGlzLmlzVGlsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3RvcnkuVGlsZUxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZpbGVEaXJlY3RvcnkuUm93c1BlclN0cmlwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZmlsZURpcmVjdG9yeS5Sb3dzUGVyU3RyaXAsIHRoaXMuZ2V0SGVpZ2h0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRIZWlnaHQoKTtcbiAgfVxuXG4gIGdldEJsb2NrV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGlsZVdpZHRoKCk7XG4gIH1cblxuICBnZXRCbG9ja0hlaWdodCh5KSB7XG4gICAgaWYgKHRoaXMuaXNUaWxlZCB8fCAoeSArIDEpICogdGhpcy5nZXRUaWxlSGVpZ2h0KCkgPD0gdGhpcy5nZXRIZWlnaHQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUhlaWdodCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRIZWlnaHQoKSAtICh5ICogdGhpcy5nZXRUaWxlSGVpZ2h0KCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgZm9yIGVhY2ggcGl4ZWwgYWNyb3NzIGFsbCBzYW1wbGVzLiBPbmx5IGZ1bGxcbiAgICogYnl0ZXMgYXJlIHN1cHBvcnRlZCwgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGVuIHRoaXMgaXMgbm90IHRoZSBjYXNlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgYnl0ZXMgcGVyIHBpeGVsXG4gICAqL1xuICBnZXRCeXRlc1BlclBpeGVsKCkge1xuICAgIGxldCBieXRlcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZS5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXMgKz0gdGhpcy5nZXRTYW1wbGVCeXRlU2l6ZShpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG5cbiAgZ2V0U2FtcGxlQnl0ZVNpemUoaSkge1xuICAgIGlmIChpID49IHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFNhbXBsZSBpbmRleCAke2l9IGlzIG91dCBvZiByYW5nZS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZVtpXSAvIDgpO1xuICB9XG5cbiAgZ2V0UmVhZGVyRm9yU2FtcGxlKHNhbXBsZUluZGV4KSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdFxuICAgICAgPyB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlRm9ybWF0W3NhbXBsZUluZGV4XSA6IDE7XG4gICAgY29uc3QgYml0c1BlclNhbXBsZSA9IHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlW3NhbXBsZUluZGV4XTtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgY2FzZSAxOiAvLyB1bnNpZ25lZCBpbnRlZ2VyIGRhdGFcbiAgICAgICAgaWYgKGJpdHNQZXJTYW1wbGUgPD0gOCkge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0VWludDg7XG4gICAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA8PSAxNikge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0VWludDE2O1xuICAgICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPD0gMzIpIHtcbiAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldFVpbnQzMjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogLy8gdHdvcyBjb21wbGVtZW50IHNpZ25lZCBpbnRlZ2VyIGRhdGFcbiAgICAgICAgaWYgKGJpdHNQZXJTYW1wbGUgPD0gOCkge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50ODtcbiAgICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDE2KSB7XG4gICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRJbnQxNjtcbiAgICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDMyKSB7XG4gICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRJbnQzMjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgc3dpdGNoIChiaXRzUGVyU2FtcGxlKSB7XG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEZsb2F0MTYodGhpcywgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRGbG9hdDMyO1xuICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldEZsb2F0NjQ7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIGZvcm1hdC9iaXRzUGVyU2FtcGxlJyk7XG4gIH1cblxuICBnZXRTYW1wbGVGb3JtYXQoc2FtcGxlSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXRcbiAgICAgID8gdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdFtzYW1wbGVJbmRleF0gOiAxO1xuICB9XG5cbiAgZ2V0Qml0c1BlclNhbXBsZShzYW1wbGVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGVbc2FtcGxlSW5kZXhdO1xuICB9XG5cbiAgZ2V0QXJyYXlGb3JTYW1wbGUoc2FtcGxlSW5kZXgsIHNpemUpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldFNhbXBsZUZvcm1hdChzYW1wbGVJbmRleCk7XG4gICAgY29uc3QgYml0c1BlclNhbXBsZSA9IHRoaXMuZ2V0Qml0c1BlclNhbXBsZShzYW1wbGVJbmRleCk7XG4gICAgcmV0dXJuIGFycmF5Rm9yVHlwZShmb3JtYXQsIGJpdHNQZXJTYW1wbGUsIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlY29kZWQgc3RyaXAgb3IgdGlsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHN0cmlwIG9yIHRpbGUgeC1vZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHRpbGUgeS1vZmZzZXQgKDAgZm9yIHN0cmlwcGVkIGltYWdlcylcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNhbXBsZSB0aGUgc2FtcGxlIHRvIGdldCBmb3Igc2VwYXJhdGVkIHNhbXBsZXNcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb3RpZmZcIikuUG9vbHxpbXBvcnQoXCIuL2dlb3RpZmZcIikuQmFzZURlY29kZXJ9IHBvb2xPckRlY29kZXIgdGhlIGRlY29kZXIgb3IgZGVjb2RlciBwb29sXG4gICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBhc3luYyBnZXRUaWxlT3JTdHJpcCh4LCB5LCBzYW1wbGUsIHBvb2xPckRlY29kZXIsIHNpZ25hbCkge1xuICAgIGNvbnN0IG51bVRpbGVzUGVyUm93ID0gTWF0aC5jZWlsKHRoaXMuZ2V0V2lkdGgoKSAvIHRoaXMuZ2V0VGlsZVdpZHRoKCkpO1xuICAgIGNvbnN0IG51bVRpbGVzUGVyQ29sID0gTWF0aC5jZWlsKHRoaXMuZ2V0SGVpZ2h0KCkgLyB0aGlzLmdldFRpbGVIZWlnaHQoKSk7XG4gICAgbGV0IGluZGV4O1xuICAgIGNvbnN0IHsgdGlsZXMgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMSkge1xuICAgICAgaW5kZXggPSAoeSAqIG51bVRpbGVzUGVyUm93KSArIHg7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDIpIHtcbiAgICAgIGluZGV4ID0gKHNhbXBsZSAqIG51bVRpbGVzUGVyUm93ICogbnVtVGlsZXNQZXJDb2wpICsgKHkgKiBudW1UaWxlc1BlclJvdykgKyB4O1xuICAgIH1cblxuICAgIGxldCBvZmZzZXQ7XG4gICAgbGV0IGJ5dGVDb3VudDtcbiAgICBpZiAodGhpcy5pc1RpbGVkKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLmZpbGVEaXJlY3RvcnkuVGlsZU9mZnNldHNbaW5kZXhdO1xuICAgICAgYnl0ZUNvdW50ID0gdGhpcy5maWxlRGlyZWN0b3J5LlRpbGVCeXRlQ291bnRzW2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gdGhpcy5maWxlRGlyZWN0b3J5LlN0cmlwT2Zmc2V0c1tpbmRleF07XG4gICAgICBieXRlQ291bnQgPSB0aGlzLmZpbGVEaXJlY3RvcnkuU3RyaXBCeXRlQ291bnRzW2luZGV4XTtcbiAgICB9XG4gICAgY29uc3Qgc2xpY2UgPSAoYXdhaXQgdGhpcy5zb3VyY2UuZmV0Y2goW3sgb2Zmc2V0LCBsZW5ndGg6IGJ5dGVDb3VudCB9XSwgc2lnbmFsKSlbMF07XG5cbiAgICBsZXQgcmVxdWVzdDtcbiAgICBpZiAodGlsZXMgPT09IG51bGwgfHwgIXRpbGVzW2luZGV4XSkge1xuICAgIC8vIHJlc29sdmUgZWFjaCByZXF1ZXN0IGJ5IHBvdGVudGlhbGx5IGFwcGx5aW5nIGFycmF5IG5vcm1hbGl6YXRpb25cbiAgICAgIHJlcXVlc3QgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHBvb2xPckRlY29kZXIuZGVjb2RlKHRoaXMuZmlsZURpcmVjdG9yeSwgc2xpY2UpO1xuICAgICAgICBjb25zdCBzYW1wbGVGb3JtYXQgPSB0aGlzLmdldFNhbXBsZUZvcm1hdCgpO1xuICAgICAgICBjb25zdCBiaXRzUGVyU2FtcGxlID0gdGhpcy5nZXRCaXRzUGVyU2FtcGxlKCk7XG4gICAgICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oc2FtcGxlRm9ybWF0LCBiaXRzUGVyU2FtcGxlKSkge1xuICAgICAgICAgIGRhdGEgPSBub3JtYWxpemVBcnJheShcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBzYW1wbGVGb3JtYXQsXG4gICAgICAgICAgICB0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24sXG4gICAgICAgICAgICB0aGlzLmdldFNhbXBsZXNQZXJQaXhlbCgpLFxuICAgICAgICAgICAgYml0c1BlclNhbXBsZSxcbiAgICAgICAgICAgIHRoaXMuZ2V0VGlsZVdpZHRoKCksXG4gICAgICAgICAgICB0aGlzLmdldEJsb2NrSGVpZ2h0KHkpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9KSgpO1xuXG4gICAgICAvLyBzZXQgdGhlIGNhY2hlXG4gICAgICBpZiAodGlsZXMgIT09IG51bGwpIHtcbiAgICAgICAgdGlsZXNbaW5kZXhdID0gcmVxdWVzdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2V0IGZyb20gdGhlIGNhY2hlXG4gICAgICByZXF1ZXN0ID0gdGlsZXNbaW5kZXhdO1xuICAgIH1cblxuICAgIC8vIGNhY2hlIHRoZSB0aWxlIHJlcXVlc3RcbiAgICByZXR1cm4geyB4LCB5LCBzYW1wbGUsIGRhdGE6IGF3YWl0IHJlcXVlc3QgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCByZWFkIGZ1bmN0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBpbWFnZVdpbmRvdyBUaGUgaW1hZ2Ugd2luZG93IGluIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNhbXBsZXMgVGhlIHNlbGVjdGVkIHNhbXBsZXMgKDAtYmFzZWQgaW5kaWNlcylcbiAgICogQHBhcmFtIHtUeXBlZEFycmF5fFR5cGVkQXJyYXlbXX0gdmFsdWVBcnJheXMgVGhlIGFycmF5KHMpIHRvIHdyaXRlIGludG9cbiAgICogQHBhcmFtIHtCb29sZWFufSBpbnRlcmxlYXZlIFdoZXRoZXIgb3Igbm90IHRvIHdyaXRlIGluIGFuIGludGVybGVhdmVkIG1hbm5lclxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvdGlmZlwiKS5Qb29sfEFic3RyYWN0RGVjb2Rlcn0gcG9vbE9yRGVjb2RlciB0aGUgZGVjb2RlciBvciBkZWNvZGVyIHBvb2xcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIHRoZSB3aWR0aCBvZiB3aW5kb3cgdG8gYmUgcmVhZCBpbnRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgdGhlIGhlaWdodCBvZiB3aW5kb3cgdG8gYmUgcmVhZCBpbnRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNhbXBsZU1ldGhvZCB0aGUgcmVzYW1wbGluZyBtZXRob2QgdG8gYmUgdXNlZCB3aGVuIGludGVycG9sYXRpbmdcbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGFib3J0ZWRcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVhZFJhc3RlclJlc3VsdD59XG4gICAqL1xuICBhc3luYyBfcmVhZFJhc3RlcihpbWFnZVdpbmRvdywgc2FtcGxlcywgdmFsdWVBcnJheXMsIGludGVybGVhdmUsIHBvb2xPckRlY29kZXIsIHdpZHRoLFxuICAgIGhlaWdodCwgcmVzYW1wbGVNZXRob2QsIHNpZ25hbCkge1xuICAgIGNvbnN0IHRpbGVXaWR0aCA9IHRoaXMuZ2V0VGlsZVdpZHRoKCk7XG4gICAgY29uc3QgdGlsZUhlaWdodCA9IHRoaXMuZ2V0VGlsZUhlaWdodCgpO1xuICAgIGNvbnN0IGltYWdlV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgY29uc3QgaW1hZ2VIZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuXG4gICAgY29uc3QgbWluWFRpbGUgPSBNYXRoLm1heChNYXRoLmZsb29yKGltYWdlV2luZG93WzBdIC8gdGlsZVdpZHRoKSwgMCk7XG4gICAgY29uc3QgbWF4WFRpbGUgPSBNYXRoLm1pbihcbiAgICAgIE1hdGguY2VpbChpbWFnZVdpbmRvd1syXSAvIHRpbGVXaWR0aCksXG4gICAgICBNYXRoLmNlaWwoaW1hZ2VXaWR0aCAvIHRpbGVXaWR0aCksXG4gICAgKTtcbiAgICBjb25zdCBtaW5ZVGlsZSA9IE1hdGgubWF4KE1hdGguZmxvb3IoaW1hZ2VXaW5kb3dbMV0gLyB0aWxlSGVpZ2h0KSwgMCk7XG4gICAgY29uc3QgbWF4WVRpbGUgPSBNYXRoLm1pbihcbiAgICAgIE1hdGguY2VpbChpbWFnZVdpbmRvd1szXSAvIHRpbGVIZWlnaHQpLFxuICAgICAgTWF0aC5jZWlsKGltYWdlSGVpZ2h0IC8gdGlsZUhlaWdodCksXG4gICAgKTtcbiAgICBjb25zdCB3aW5kb3dXaWR0aCA9IGltYWdlV2luZG93WzJdIC0gaW1hZ2VXaW5kb3dbMF07XG5cbiAgICBsZXQgYnl0ZXNQZXJQaXhlbCA9IHRoaXMuZ2V0Qnl0ZXNQZXJQaXhlbCgpO1xuXG4gICAgY29uc3Qgc3JjU2FtcGxlT2Zmc2V0cyA9IFtdO1xuICAgIGNvbnN0IHNhbXBsZVJlYWRlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDEpIHtcbiAgICAgICAgc3JjU2FtcGxlT2Zmc2V0cy5wdXNoKHN1bSh0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZSwgMCwgc2FtcGxlc1tpXSkgLyA4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNyY1NhbXBsZU9mZnNldHMucHVzaCgwKTtcbiAgICAgIH1cbiAgICAgIHNhbXBsZVJlYWRlcnMucHVzaCh0aGlzLmdldFJlYWRlckZvclNhbXBsZShzYW1wbGVzW2ldKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBjb25zdCB7IGxpdHRsZUVuZGlhbiB9ID0gdGhpcztcblxuICAgIGZvciAobGV0IHlUaWxlID0gbWluWVRpbGU7IHlUaWxlIDwgbWF4WVRpbGU7ICsreVRpbGUpIHtcbiAgICAgIGZvciAobGV0IHhUaWxlID0gbWluWFRpbGU7IHhUaWxlIDwgbWF4WFRpbGU7ICsreFRpbGUpIHtcbiAgICAgICAgbGV0IGdldFByb21pc2U7XG4gICAgICAgIGlmICh0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDEpIHtcbiAgICAgICAgICBnZXRQcm9taXNlID0gdGhpcy5nZXRUaWxlT3JTdHJpcCh4VGlsZSwgeVRpbGUsIDAsIHBvb2xPckRlY29kZXIsIHNpZ25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc2FtcGxlSW5kZXggPSAwOyBzYW1wbGVJbmRleCA8IHNhbXBsZXMubGVuZ3RoOyArK3NhbXBsZUluZGV4KSB7XG4gICAgICAgICAgY29uc3Qgc2kgPSBzYW1wbGVJbmRleDtcbiAgICAgICAgICBjb25zdCBzYW1wbGUgPSBzYW1wbGVzW3NhbXBsZUluZGV4XTtcbiAgICAgICAgICBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAyKSB7XG4gICAgICAgICAgICBieXRlc1BlclBpeGVsID0gdGhpcy5nZXRTYW1wbGVCeXRlU2l6ZShzYW1wbGUpO1xuICAgICAgICAgICAgZ2V0UHJvbWlzZSA9IHRoaXMuZ2V0VGlsZU9yU3RyaXAoeFRpbGUsIHlUaWxlLCBzYW1wbGUsIHBvb2xPckRlY29kZXIsIHNpZ25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBnZXRQcm9taXNlLnRoZW4oKHRpbGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRpbGUuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgICAgICBjb25zdCBibG9ja0hlaWdodCA9IHRoaXMuZ2V0QmxvY2tIZWlnaHQodGlsZS55KTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TGluZSA9IHRpbGUueSAqIHRpbGVIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBmaXJzdENvbCA9IHRpbGUueCAqIHRpbGVXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RMaW5lID0gZmlyc3RMaW5lICsgYmxvY2tIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBsYXN0Q29sID0gKHRpbGUueCArIDEpICogdGlsZVdpZHRoO1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gc2FtcGxlUmVhZGVyc1tzaV07XG5cbiAgICAgICAgICAgIGNvbnN0IHltYXggPSBNYXRoLm1pbihibG9ja0hlaWdodCwgYmxvY2tIZWlnaHQgLSAobGFzdExpbmUgLSBpbWFnZVdpbmRvd1szXSksIGltYWdlSGVpZ2h0IC0gZmlyc3RMaW5lKTtcbiAgICAgICAgICAgIGNvbnN0IHhtYXggPSBNYXRoLm1pbih0aWxlV2lkdGgsIHRpbGVXaWR0aCAtIChsYXN0Q29sIC0gaW1hZ2VXaW5kb3dbMl0pLCBpbWFnZVdpZHRoIC0gZmlyc3RDb2wpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gTWF0aC5tYXgoMCwgaW1hZ2VXaW5kb3dbMV0gLSBmaXJzdExpbmUpOyB5IDwgeW1heDsgKyt5KSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IHggPSBNYXRoLm1heCgwLCBpbWFnZVdpbmRvd1swXSAtIGZpcnN0Q29sKTsgeCA8IHhtYXg7ICsreCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsT2Zmc2V0ID0gKCh5ICogdGlsZVdpZHRoKSArIHgpICogYnl0ZXNQZXJQaXhlbDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlYWRlci5jYWxsKFxuICAgICAgICAgICAgICAgICAgZGF0YVZpZXcsIHBpeGVsT2Zmc2V0ICsgc3JjU2FtcGxlT2Zmc2V0c1tzaV0sIGxpdHRsZUVuZGlhbixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGxldCB3aW5kb3dDb29yZGluYXRlO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcmxlYXZlKSB7XG4gICAgICAgICAgICAgICAgICB3aW5kb3dDb29yZGluYXRlID0gKCh5ICsgZmlyc3RMaW5lIC0gaW1hZ2VXaW5kb3dbMV0pICogd2luZG93V2lkdGggKiBzYW1wbGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgKyAoKHggKyBmaXJzdENvbCAtIGltYWdlV2luZG93WzBdKSAqIHNhbXBsZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICArIHNpO1xuICAgICAgICAgICAgICAgICAgdmFsdWVBcnJheXNbd2luZG93Q29vcmRpbmF0ZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgd2luZG93Q29vcmRpbmF0ZSA9IChcbiAgICAgICAgICAgICAgICAgICAgKHkgKyBmaXJzdExpbmUgLSBpbWFnZVdpbmRvd1sxXSkgKiB3aW5kb3dXaWR0aFxuICAgICAgICAgICAgICAgICAgKSArIHggKyBmaXJzdENvbCAtIGltYWdlV2luZG93WzBdO1xuICAgICAgICAgICAgICAgICAgdmFsdWVBcnJheXNbc2ldW3dpbmRvd0Nvb3JkaW5hdGVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICBpZiAoKHdpZHRoICYmIChpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdKSAhPT0gd2lkdGgpXG4gICAgICAgIHx8IChoZWlnaHQgJiYgKGltYWdlV2luZG93WzNdIC0gaW1hZ2VXaW5kb3dbMV0pICE9PSBoZWlnaHQpKSB7XG4gICAgICBsZXQgcmVzYW1wbGVkO1xuICAgICAgaWYgKGludGVybGVhdmUpIHtcbiAgICAgICAgcmVzYW1wbGVkID0gcmVzYW1wbGVJbnRlcmxlYXZlZChcbiAgICAgICAgICB2YWx1ZUFycmF5cyxcbiAgICAgICAgICBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdLFxuICAgICAgICAgIGltYWdlV2luZG93WzNdIC0gaW1hZ2VXaW5kb3dbMV0sXG4gICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICBzYW1wbGVzLmxlbmd0aCxcbiAgICAgICAgICByZXNhbXBsZU1ldGhvZCxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2FtcGxlZCA9IHJlc2FtcGxlKFxuICAgICAgICAgIHZhbHVlQXJyYXlzLFxuICAgICAgICAgIGltYWdlV2luZG93WzJdIC0gaW1hZ2VXaW5kb3dbMF0sXG4gICAgICAgICAgaW1hZ2VXaW5kb3dbM10gLSBpbWFnZVdpbmRvd1sxXSxcbiAgICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgIHJlc2FtcGxlTWV0aG9kLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVzYW1wbGVkLndpZHRoID0gd2lkdGg7XG4gICAgICByZXNhbXBsZWQuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgcmV0dXJuIHJlc2FtcGxlZDtcbiAgICB9XG5cbiAgICB2YWx1ZUFycmF5cy53aWR0aCA9IHdpZHRoIHx8IGltYWdlV2luZG93WzJdIC0gaW1hZ2VXaW5kb3dbMF07XG4gICAgdmFsdWVBcnJheXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IGltYWdlV2luZG93WzNdIC0gaW1hZ2VXaW5kb3dbMV07XG5cbiAgICByZXR1cm4gdmFsdWVBcnJheXM7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgcmFzdGVyIGRhdGEgZnJvbSB0aGUgaW1hZ2UuIFRoaXMgZnVuY3Rpb24gcmVhZHMgYWxsIHNlbGVjdGVkIHNhbXBsZXNcbiAgICogaW50byBzZXBhcmF0ZSBhcnJheXMgb2YgdGhlIGNvcnJlY3QgdHlwZSBmb3IgdGhhdCBzYW1wbGUgb3IgaW50byBhIHNpbmdsZVxuICAgKiBjb21iaW5lZCBhcnJheSB3aGVuIGBpbnRlcmxlYXZlYCBpcyBzZXQuIFdoZW4gcHJvdmlkZWQsIG9ubHkgYSBzdWJzZXRcbiAgICogb2YgdGhlIHJhc3RlciBpcyByZWFkIGZvciBlYWNoIHNhbXBsZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFkUmFzdGVyT3B0aW9uc30gW29wdGlvbnM9e31dIG9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVhZFJhc3RlclJlc3VsdD59IHRoZSBkZWNvZGVkIGFycmF5cyBhcyBhIHByb21pc2VcbiAgICovXG4gIGFzeW5jIHJlYWRSYXN0ZXJzKHtcbiAgICB3aW5kb3c6IHduZCwgc2FtcGxlcyA9IFtdLCBpbnRlcmxlYXZlLCBwb29sID0gbnVsbCxcbiAgICB3aWR0aCwgaGVpZ2h0LCByZXNhbXBsZU1ldGhvZCwgZmlsbFZhbHVlLCBzaWduYWwsXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IGltYWdlV2luZG93ID0gd25kIHx8IFswLCAwLCB0aGlzLmdldFdpZHRoKCksIHRoaXMuZ2V0SGVpZ2h0KCldO1xuXG4gICAgLy8gY2hlY2sgcGFyYW1ldGVyc1xuICAgIGlmIChpbWFnZVdpbmRvd1swXSA+IGltYWdlV2luZG93WzJdIHx8IGltYWdlV2luZG93WzFdID4gaW1hZ2VXaW5kb3dbM10pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdWJzZXRzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaW1hZ2VXaW5kb3dXaWR0aCA9IGltYWdlV2luZG93WzJdIC0gaW1hZ2VXaW5kb3dbMF07XG4gICAgY29uc3QgaW1hZ2VXaW5kb3dIZWlnaHQgPSBpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdO1xuICAgIGNvbnN0IG51bVBpeGVscyA9IGltYWdlV2luZG93V2lkdGggKiBpbWFnZVdpbmRvd0hlaWdodDtcbiAgICBjb25zdCBzYW1wbGVzUGVyUGl4ZWwgPSB0aGlzLmdldFNhbXBsZXNQZXJQaXhlbCgpO1xuXG4gICAgaWYgKCFzYW1wbGVzIHx8ICFzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzUGVyUGl4ZWw7ICsraSkge1xuICAgICAgICBzYW1wbGVzLnB1c2goaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoc2FtcGxlc1tpXSA+PSBzYW1wbGVzUGVyUGl4ZWwpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFJhbmdlRXJyb3IoYEludmFsaWQgc2FtcGxlIGluZGV4ICcke3NhbXBsZXNbaV19Jy5gKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHZhbHVlQXJyYXlzO1xuICAgIGlmIChpbnRlcmxlYXZlKSB7XG4gICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlRm9ybWF0XG4gICAgICAgID8gTWF0aC5tYXguYXBwbHkobnVsbCwgdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdCkgOiAxO1xuICAgICAgY29uc3QgYml0c1BlclNhbXBsZSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlKTtcbiAgICAgIHZhbHVlQXJyYXlzID0gYXJyYXlGb3JUeXBlKGZvcm1hdCwgYml0c1BlclNhbXBsZSwgbnVtUGl4ZWxzICogc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgaWYgKGZpbGxWYWx1ZSkge1xuICAgICAgICB2YWx1ZUFycmF5cy5maWxsKGZpbGxWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlQXJyYXlzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdmFsdWVBcnJheSA9IHRoaXMuZ2V0QXJyYXlGb3JTYW1wbGUoc2FtcGxlc1tpXSwgbnVtUGl4ZWxzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsbFZhbHVlKSAmJiBpIDwgZmlsbFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHZhbHVlQXJyYXkuZmlsbChmaWxsVmFsdWVbaV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGxWYWx1ZSAmJiAhQXJyYXkuaXNBcnJheShmaWxsVmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWVBcnJheS5maWxsKGZpbGxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVBcnJheXMucHVzaCh2YWx1ZUFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwb29sT3JEZWNvZGVyID0gcG9vbCB8fCBhd2FpdCBnZXREZWNvZGVyKHRoaXMuZmlsZURpcmVjdG9yeSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9yZWFkUmFzdGVyKFxuICAgICAgaW1hZ2VXaW5kb3csIHNhbXBsZXMsIHZhbHVlQXJyYXlzLCBpbnRlcmxlYXZlLCBwb29sT3JEZWNvZGVyLCB3aWR0aCwgaGVpZ2h0LCByZXNhbXBsZU1ldGhvZCwgc2lnbmFsLFxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyByYXN0ZXIgZGF0YSBmcm9tIHRoZSBpbWFnZSBhcyBSR0IuIFRoZSByZXN1bHQgaXMgYWx3YXlzIGFuXG4gICAqIGludGVybGVhdmVkIHR5cGVkIGFycmF5LlxuICAgKiBDb2xvcnNwYWNlcyBvdGhlciB0aGFuIFJHQiB3aWxsIGJlIHRyYW5zZm9ybWVkIHRvIFJHQiwgY29sb3IgbWFwcyBleHBhbmRlZC5cbiAgICogV2hlbiBubyBvdGhlciBtZXRob2QgaXMgYXBwbGljYWJsZSwgdGhlIGZpcnN0IHNhbXBsZSBpcyB1c2VkIHRvIHByb2R1Y2UgYVxuICAgKiBncmF5c2NhbGUgaW1hZ2UuXG4gICAqIFdoZW4gcHJvdmlkZWQsIG9ubHkgYSBzdWJzZXQgb2YgdGhlIHJhc3RlciBpcyByZWFkIGZvciBlYWNoIHNhbXBsZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMud2luZG93XSB0aGUgc3Vic2V0IHRvIHJlYWQgZGF0YSBmcm9tIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pbnRlcmxlYXZlPXRydWVdIHdoZXRoZXIgdGhlIGRhdGEgc2hhbGwgYmUgcmVhZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIG9uZSBzaW5nbGUgYXJyYXkgb3Igc2VwYXJhdGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW90aWZmXCIpLlBvb2x9IFtvcHRpb25zLnBvb2w9bnVsbF0gVGhlIG9wdGlvbmFsIGRlY29kZXIgcG9vbCB0byB1c2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dC4gV2hlbiB0aGUgd2lkdGggaXMgbm8gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtZSBhcyB0aGUgaW1hZ2VzLCByZXNhbXBsaW5nIHdpbGwgYmUgcGVyZm9ybWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dC4gV2hlbiB0aGUgd2lkdGggaXMgbm8gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWUgYXMgdGhlIGltYWdlcywgcmVzYW1wbGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlc2FtcGxlTWV0aG9kPSduZWFyZXN0J10gVGhlIGRlc2lyZWQgcmVzYW1wbGluZyBtZXRob2QuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlQWxwaGE9ZmFsc2VdIEVuYWJsZSByZWFkaW5nIGFscGhhIGNoYW5uZWwgaWYgcHJlc2VudC5cbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW29wdGlvbnMuc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0aGF0IG1heSBiZSBzaWduYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRSYXN0ZXJSZXN1bHQ+fSB0aGUgUkdCIGFycmF5IGFzIGEgUHJvbWlzZVxuICAgKi9cbiAgYXN5bmMgcmVhZFJHQih7IHdpbmRvdywgaW50ZXJsZWF2ZSA9IHRydWUsIHBvb2wgPSBudWxsLCB3aWR0aCwgaGVpZ2h0LFxuICAgIHJlc2FtcGxlTWV0aG9kLCBlbmFibGVBbHBoYSA9IGZhbHNlLCBzaWduYWwgfSA9IHt9KSB7XG4gICAgY29uc3QgaW1hZ2VXaW5kb3cgPSB3aW5kb3cgfHwgWzAsIDAsIHRoaXMuZ2V0V2lkdGgoKSwgdGhpcy5nZXRIZWlnaHQoKV07XG5cbiAgICAvLyBjaGVjayBwYXJhbWV0ZXJzXG4gICAgaWYgKGltYWdlV2luZG93WzBdID4gaW1hZ2VXaW5kb3dbMl0gfHwgaW1hZ2VXaW5kb3dbMV0gPiBpbWFnZVdpbmRvd1szXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNldHMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBwaSA9IHRoaXMuZmlsZURpcmVjdG9yeS5QaG90b21ldHJpY0ludGVycHJldGF0aW9uO1xuXG4gICAgaWYgKHBpID09PSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5SR0IpIHtcbiAgICAgIGxldCBzID0gWzAsIDEsIDJdO1xuICAgICAgaWYgKCghKHRoaXMuZmlsZURpcmVjdG9yeS5FeHRyYVNhbXBsZXMgPT09IEV4dHJhU2FtcGxlc1ZhbHVlcy5VbnNwZWNpZmllZCkpICYmIGVuYWJsZUFscGhhKSB7XG4gICAgICAgIHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVhZFJhc3RlcnMoe1xuICAgICAgICB3aW5kb3csXG4gICAgICAgIGludGVybGVhdmUsXG4gICAgICAgIHNhbXBsZXM6IHMsXG4gICAgICAgIHBvb2wsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHJlc2FtcGxlTWV0aG9kLFxuICAgICAgICBzaWduYWwsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgc2FtcGxlcztcbiAgICBzd2l0Y2ggKHBpKSB7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLldoaXRlSXNaZXJvOlxuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5CbGFja0lzWmVybzpcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuUGFsZXR0ZTpcbiAgICAgICAgc2FtcGxlcyA9IFswXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLkNNWUs6XG4gICAgICAgIHNhbXBsZXMgPSBbMCwgMSwgMiwgM107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5ZQ2JDcjpcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuQ0lFTGFiOlxuICAgICAgICBzYW1wbGVzID0gWzAsIDEsIDJdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvciB1bnN1cHBvcnRlZCBwaG90b21ldHJpYyBpbnRlcnByZXRhdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJPcHRpb25zID0ge1xuICAgICAgd2luZG93OiBpbWFnZVdpbmRvdyxcbiAgICAgIGludGVybGVhdmU6IHRydWUsXG4gICAgICBzYW1wbGVzLFxuICAgICAgcG9vbCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcmVzYW1wbGVNZXRob2QsXG4gICAgICBzaWduYWwsXG4gICAgfTtcbiAgICBjb25zdCB7IGZpbGVEaXJlY3RvcnkgfSA9IHRoaXM7XG4gICAgY29uc3QgcmFzdGVyID0gYXdhaXQgdGhpcy5yZWFkUmFzdGVycyhzdWJPcHRpb25zKTtcblxuICAgIGNvbnN0IG1heCA9IDIgKiogdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGVbMF07XG4gICAgbGV0IGRhdGE7XG4gICAgc3dpdGNoIChwaSkge1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5XaGl0ZUlzWmVybzpcbiAgICAgICAgZGF0YSA9IGZyb21XaGl0ZUlzWmVybyhyYXN0ZXIsIG1heCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5CbGFja0lzWmVybzpcbiAgICAgICAgZGF0YSA9IGZyb21CbGFja0lzWmVybyhyYXN0ZXIsIG1heCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5QYWxldHRlOlxuICAgICAgICBkYXRhID0gZnJvbVBhbGV0dGUocmFzdGVyLCBmaWxlRGlyZWN0b3J5LkNvbG9yTWFwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLkNNWUs6XG4gICAgICAgIGRhdGEgPSBmcm9tQ01ZSyhyYXN0ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuWUNiQ3I6XG4gICAgICAgIGRhdGEgPSBmcm9tWUNiQ3IocmFzdGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLkNJRUxhYjpcbiAgICAgICAgZGF0YSA9IGZyb21DSUVMYWIocmFzdGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHBob3RvbWV0cmljIGludGVycHJldGF0aW9uLicpO1xuICAgIH1cblxuICAgIC8vIGlmIG5vbi1pbnRlcmxlYXZlZCBkYXRhIGlzIHJlcXVlc3RlZCwgd2UgbXVzdCBzcGxpdCB0aGUgY2hhbm5lbHNcbiAgICAvLyBpbnRvIHRoZWlyIHJlc3BlY3RpdmUgYXJyYXlzXG4gICAgaWYgKCFpbnRlcmxlYXZlKSB7XG4gICAgICBjb25zdCByZWQgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCAvIDMpO1xuICAgICAgY29uc3QgZ3JlZW4gPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCAvIDMpO1xuICAgICAgY29uc3QgYmx1ZSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoIC8gMyk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSAzLCArK2opIHtcbiAgICAgICAgcmVkW2pdID0gZGF0YVtpXTtcbiAgICAgICAgZ3JlZW5bal0gPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYmx1ZVtqXSA9IGRhdGFbaSArIDJdO1xuICAgICAgfVxuICAgICAgZGF0YSA9IFtyZWQsIGdyZWVuLCBibHVlXTtcbiAgICB9XG5cbiAgICBkYXRhLndpZHRoID0gcmFzdGVyLndpZHRoO1xuICAgIGRhdGEuaGVpZ2h0ID0gcmFzdGVyLmhlaWdodDtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRpZXBvaW50cy5cbiAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgKi9cbiAgZ2V0VGllUG9pbnRzKCkge1xuICAgIGlmICghdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCB0aWVQb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50Lmxlbmd0aDsgaSArPSA2KSB7XG4gICAgICB0aWVQb2ludHMucHVzaCh7XG4gICAgICAgIGk6IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50W2ldLFxuICAgICAgICBqOiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpICsgMV0sXG4gICAgICAgIGs6IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50W2kgKyAyXSxcbiAgICAgICAgeDogdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnRbaSArIDNdLFxuICAgICAgICB5OiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpICsgNF0sXG4gICAgICAgIHo6IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50W2kgKyA1XSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGllUG9pbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcnNlZCBHREFMIG1ldGFkYXRhIGl0ZW1zLlxuICAgKlxuICAgKiBJZiBzYW1wbGUgaXMgcGFzc2VkIHRvIG51bGwsIGRhdGFzZXQtbGV2ZWwgbWV0YWRhdGEgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogT3RoZXJ3aXNlIG9ubHkgbWV0YWRhdGEgc3BlY2lmaWMgdG8gdGhlIHByb3ZpZGVkIHNhbXBsZSB3aWxsIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NhbXBsZT1udWxsXSBUaGUgc2FtcGxlIGluZGV4LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0R0RBTE1ldGFkYXRhKHNhbXBsZSA9IG51bGwpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHt9O1xuICAgIGlmICghdGhpcy5maWxlRGlyZWN0b3J5LkdEQUxfTUVUQURBVEEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdHJpbmcgPSB0aGlzLmZpbGVEaXJlY3RvcnkuR0RBTF9NRVRBREFUQTtcblxuICAgIGxldCBpdGVtcyA9IGZpbmRUYWdzQnlOYW1lKHN0cmluZywgJ0l0ZW0nKTtcblxuICAgIGlmIChzYW1wbGUgPT09IG51bGwpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBnZXRBdHRyaWJ1dGUoaXRlbSwgJ3NhbXBsZScpID09PSB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gTnVtYmVyKGdldEF0dHJpYnV0ZShpdGVtLCAnc2FtcGxlJykpID09PSBzYW1wbGUpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIG1ldGFkYXRhW2dldEF0dHJpYnV0ZShpdGVtLCAnbmFtZScpXSA9IGl0ZW0uaW5uZXI7XG4gICAgfVxuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBHREFMIG5vZGF0YSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfG51bGx9XG4gICAqL1xuICBnZXRHREFMTm9EYXRhKCkge1xuICAgIGlmICghdGhpcy5maWxlRGlyZWN0b3J5LkdEQUxfTk9EQVRBKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nID0gdGhpcy5maWxlRGlyZWN0b3J5LkdEQUxfTk9EQVRBO1xuICAgIHJldHVybiBOdW1iZXIoc3RyaW5nLnN1YnN0cmluZygwLCBzdHJpbmcubGVuZ3RoIC0gMSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGltYWdlIG9yaWdpbiBhcyBhIFhZWi12ZWN0b3IuIFdoZW4gdGhlIGltYWdlIGhhcyBubyBhZmZpbmVcbiAgICogdHJhbnNmb3JtYXRpb24sIHRoZW4gYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IFRoZSBvcmlnaW4gYXMgYSB2ZWN0b3JcbiAgICovXG4gIGdldE9yaWdpbigpIHtcbiAgICBjb25zdCB0aWVQb2ludHMgPSB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludDtcbiAgICBjb25zdCBtb2RlbFRyYW5zZm9ybWF0aW9uID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVHJhbnNmb3JtYXRpb247XG4gICAgaWYgKHRpZVBvaW50cyAmJiB0aWVQb2ludHMubGVuZ3RoID09PSA2KSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aWVQb2ludHNbM10sXG4gICAgICAgIHRpZVBvaW50c1s0XSxcbiAgICAgICAgdGllUG9pbnRzWzVdLFxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKG1vZGVsVHJhbnNmb3JtYXRpb24pIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG1vZGVsVHJhbnNmb3JtYXRpb25bM10sXG4gICAgICAgIG1vZGVsVHJhbnNmb3JtYXRpb25bN10sXG4gICAgICAgIG1vZGVsVHJhbnNmb3JtYXRpb25bMTFdLFxuICAgICAgXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW1hZ2UgZG9lcyBub3QgaGF2ZSBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb24uJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW1hZ2UgcmVzb2x1dGlvbiBhcyBhIFhZWi12ZWN0b3IuIFdoZW4gdGhlIGltYWdlIGhhcyBubyBhZmZpbmVcbiAgICogdHJhbnNmb3JtYXRpb24sIHRoZW4gYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICogQHBhcmFtIHtHZW9USUZGSW1hZ2V9IFtyZWZlcmVuY2VJbWFnZT1udWxsXSBBIHJlZmVyZW5jZSBpbWFnZSB0byBjYWxjdWxhdGUgdGhlIHJlc29sdXRpb24gZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIGNhc2VzIHdoZW4gdGhlIGN1cnJlbnQgaW1hZ2UgZG9lcyBub3QgaGF2ZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZCB0YWdzIG9uIGl0cyBvd24uXG4gICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBUaGUgcmVzb2x1dGlvbiBhcyBhIHZlY3RvclxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbihyZWZlcmVuY2VJbWFnZSA9IG51bGwpIHtcbiAgICBjb25zdCBtb2RlbFBpeGVsU2NhbGUgPSB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxQaXhlbFNjYWxlO1xuICAgIGNvbnN0IG1vZGVsVHJhbnNmb3JtYXRpb24gPSB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUcmFuc2Zvcm1hdGlvbjtcblxuICAgIGlmIChtb2RlbFBpeGVsU2NhbGUpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG1vZGVsUGl4ZWxTY2FsZVswXSxcbiAgICAgICAgLW1vZGVsUGl4ZWxTY2FsZVsxXSxcbiAgICAgICAgbW9kZWxQaXhlbFNjYWxlWzJdLFxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKG1vZGVsVHJhbnNmb3JtYXRpb24pIHtcbiAgICAgIGlmIChtb2RlbFRyYW5zZm9ybWF0aW9uWzFdID09PSAwICYmIG1vZGVsVHJhbnNmb3JtYXRpb25bNF0gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzBdLFxuICAgICAgICAgIC1tb2RlbFRyYW5zZm9ybWF0aW9uWzVdLFxuICAgICAgICAgIG1vZGVsVHJhbnNmb3JtYXRpb25bMTBdLFxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5zcXJ0KChtb2RlbFRyYW5zZm9ybWF0aW9uWzBdICogbW9kZWxUcmFuc2Zvcm1hdGlvblswXSlcbiAgICAgICAgICArIChtb2RlbFRyYW5zZm9ybWF0aW9uWzRdICogbW9kZWxUcmFuc2Zvcm1hdGlvbls0XSkpLFxuICAgICAgICAtTWF0aC5zcXJ0KChtb2RlbFRyYW5zZm9ybWF0aW9uWzFdICogbW9kZWxUcmFuc2Zvcm1hdGlvblsxXSlcbiAgICAgICAgICArIChtb2RlbFRyYW5zZm9ybWF0aW9uWzVdICogbW9kZWxUcmFuc2Zvcm1hdGlvbls1XSkpLFxuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzEwXV07XG4gICAgfVxuXG4gICAgaWYgKHJlZmVyZW5jZUltYWdlKSB7XG4gICAgICBjb25zdCBbcmVmUmVzWCwgcmVmUmVzWSwgcmVmUmVzWl0gPSByZWZlcmVuY2VJbWFnZS5nZXRSZXNvbHV0aW9uKCk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICByZWZSZXNYICogcmVmZXJlbmNlSW1hZ2UuZ2V0V2lkdGgoKSAvIHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgcmVmUmVzWSAqIHJlZmVyZW5jZUltYWdlLmdldEhlaWdodCgpIC8gdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgcmVmUmVzWiAqIHJlZmVyZW5jZUltYWdlLmdldFdpZHRoKCkgLyB0aGlzLmdldFdpZHRoKCksXG4gICAgICBdO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGltYWdlIGRvZXMgbm90IGhhdmUgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBpeGVscyBvZiB0aGUgaW1hZ2UgZGVwaWN0IGFuIGFyZWEgKG9yIHBvaW50KS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHBpeGVscyBhcmUgYSBwb2ludFxuICAgKi9cbiAgcGl4ZWxJc0FyZWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvS2V5cy5HVFJhc3RlclR5cGVHZW9LZXkgPT09IDE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW1hZ2UgYm91bmRpbmcgYm94IGFzIGFuIGFycmF5IG9mIDQgdmFsdWVzOiBtaW4teCwgbWluLXksXG4gICAqIG1heC14IGFuZCBtYXgteS4gV2hlbiB0aGUgaW1hZ2UgaGFzIG5vIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiwgdGhlbiBhblxuICAgKiBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt0aWxlZ3JpZD1mYWxzZV0gSWYgdHJ1ZSByZXR1cm4gZXh0ZW50IGZvciBhIHRpbGVncmlkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRob3V0IGFkanVzdG1lbnQgZm9yIE1vZGVsVHJhbnNmb3JtYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBUaGUgYm91bmRpbmcgYm94XG4gICAqL1xuICBnZXRCb3VuZGluZ0JveCh0aWxlZ3JpZCA9IGZhbHNlKSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcblxuICAgIGlmICh0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUcmFuc2Zvcm1hdGlvbiAmJiAhdGlsZWdyaWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgY29uc3QgW2EsIGIsIGMsIGQsIGUsIGYsIGcsIGhdID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVHJhbnNmb3JtYXRpb247XG5cbiAgICAgIGNvbnN0IGNvcm5lcnMgPSBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzAsIGhlaWdodF0sXG4gICAgICAgIFt3aWR0aCwgMF0sXG4gICAgICAgIFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHByb2plY3RlZCA9IGNvcm5lcnMubWFwKChbSSwgSl0pID0+IFtcbiAgICAgICAgZCArIChhICogSSkgKyAoYiAqIEopLFxuICAgICAgICBoICsgKGUgKiBJKSArIChmICogSiksXG4gICAgICBdKTtcblxuICAgICAgY29uc3QgeHMgPSBwcm9qZWN0ZWQubWFwKChwdCkgPT4gcHRbMF0pO1xuICAgICAgY29uc3QgeXMgPSBwcm9qZWN0ZWQubWFwKChwdCkgPT4gcHRbMV0pO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBNYXRoLm1pbiguLi54cyksXG4gICAgICAgIE1hdGgubWluKC4uLnlzKSxcbiAgICAgICAgTWF0aC5tYXgoLi4ueHMpLFxuICAgICAgICBNYXRoLm1heCguLi55cyksXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbigpO1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuXG4gICAgICBjb25zdCB4MSA9IG9yaWdpblswXTtcbiAgICAgIGNvbnN0IHkxID0gb3JpZ2luWzFdO1xuXG4gICAgICBjb25zdCB4MiA9IHgxICsgKHJlc29sdXRpb25bMF0gKiB3aWR0aCk7XG4gICAgICBjb25zdCB5MiA9IHkxICsgKHJlc29sdXRpb25bMV0gKiBoZWlnaHQpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBNYXRoLm1pbih4MSwgeDIpLFxuICAgICAgICBNYXRoLm1pbih5MSwgeTIpLFxuICAgICAgICBNYXRoLm1heCh4MSwgeDIpLFxuICAgICAgICBNYXRoLm1heCh5MSwgeTIpLFxuICAgICAgXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR2VvVElGRkltYWdlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/geotiffimage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/geotiffwriter.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffwriter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   writeGeotiff: () => (/* binding */ writeGeotiff)\n/* harmony export */ });\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.js */ \"(ssr)/./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/geotiff/dist-module/utils.js\");\n/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\n\n\n\nconst tagName2Code = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagNames);\nconst geoKeyName2Code = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.geoKeyNames);\nconst name2code = {};\n(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assign)(name2code, tagName2Code);\n(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assign)(name2code, geoKeyName2Code);\nconst typeName2byte = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = _globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.endsWith)(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.forEach)(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nfunction writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(height, (rowIndex) => {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(width, (columnIndex) => {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.endsWith)(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = _globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey of geoKeys) {\n    if (metadata.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n    'RowsPerStrip',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmd3JpdGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RjtBQUNuQjs7QUFFdEUscUJBQXFCLGlEQUFNLENBQUMsc0RBQWE7QUFDekMsd0JBQXdCLGlEQUFNLENBQUMsb0RBQVc7QUFDMUM7QUFDQSxpREFBTTtBQUNOLGlEQUFNO0FBQ04sc0JBQXNCLGlEQUFNLENBQUMsdURBQWM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUksZ0RBQUs7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSxnREFBSztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSSxnREFBSztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLGdEQUFLO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEscUJBQXFCLHNEQUFhO0FBQ2xDOztBQUVBO0FBQ0EsOENBQThDLElBQUk7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QUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZ2VvdGlmZndyaXRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBTb21lIHBhcnRzIG9mIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gVVRJRi5qcyxcbiAgd2hpY2ggd2FzIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAgWW91IGNhbiB2aWV3IHRoYXQgaGVyZTpcbiAgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvcGVhL1VUSUYuanMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuKi9cbmltcG9ydCB7IGZpZWxkVGFnTmFtZXMsIGZpZWxkVGFnVHlwZXMsIGZpZWxkVHlwZU5hbWVzLCBnZW9LZXlOYW1lcyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5pbXBvcnQgeyBhc3NpZ24sIGVuZHNXaXRoLCBmb3JFYWNoLCBpbnZlcnQsIHRpbWVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmNvbnN0IHRhZ05hbWUyQ29kZSA9IGludmVydChmaWVsZFRhZ05hbWVzKTtcbmNvbnN0IGdlb0tleU5hbWUyQ29kZSA9IGludmVydChnZW9LZXlOYW1lcyk7XG5jb25zdCBuYW1lMmNvZGUgPSB7fTtcbmFzc2lnbihuYW1lMmNvZGUsIHRhZ05hbWUyQ29kZSk7XG5hc3NpZ24obmFtZTJjb2RlLCBnZW9LZXlOYW1lMkNvZGUpO1xuY29uc3QgdHlwZU5hbWUyYnl0ZSA9IGludmVydChmaWVsZFR5cGVOYW1lcyk7XG5cbi8vIGNvbmZpZyB2YXJpYWJsZXNcbmNvbnN0IG51bUJ5dGVzSW5JZmQgPSAxMDAwO1xuXG5jb25zdCBfYmluQkUgPSB7XG4gIG5leHRaZXJvOiAoZGF0YSwgbykgPT4ge1xuICAgIGxldCBvaW5jciA9IG87XG4gICAgd2hpbGUgKGRhdGFbb2luY3JdICE9PSAwKSB7XG4gICAgICBvaW5jcisrO1xuICAgIH1cbiAgICByZXR1cm4gb2luY3I7XG4gIH0sXG4gIHJlYWRVc2hvcnQ6IChidWZmLCBwKSA9PiB7XG4gICAgcmV0dXJuIChidWZmW3BdIDw8IDgpIHwgYnVmZltwICsgMV07XG4gIH0sXG4gIHJlYWRTaG9ydDogKGJ1ZmYsIHApID0+IHtcbiAgICBjb25zdCBhID0gX2JpbkJFLnVpODtcbiAgICBhWzBdID0gYnVmZltwICsgMV07XG4gICAgYVsxXSA9IGJ1ZmZbcCArIDBdO1xuICAgIHJldHVybiBfYmluQkUuaTE2WzBdO1xuICB9LFxuICByZWFkSW50OiAoYnVmZiwgcCkgPT4ge1xuICAgIGNvbnN0IGEgPSBfYmluQkUudWk4O1xuICAgIGFbMF0gPSBidWZmW3AgKyAzXTtcbiAgICBhWzFdID0gYnVmZltwICsgMl07XG4gICAgYVsyXSA9IGJ1ZmZbcCArIDFdO1xuICAgIGFbM10gPSBidWZmW3AgKyAwXTtcbiAgICByZXR1cm4gX2JpbkJFLmkzMlswXTtcbiAgfSxcbiAgcmVhZFVpbnQ6IChidWZmLCBwKSA9PiB7XG4gICAgY29uc3QgYSA9IF9iaW5CRS51aTg7XG4gICAgYVswXSA9IGJ1ZmZbcCArIDNdO1xuICAgIGFbMV0gPSBidWZmW3AgKyAyXTtcbiAgICBhWzJdID0gYnVmZltwICsgMV07XG4gICAgYVszXSA9IGJ1ZmZbcCArIDBdO1xuICAgIHJldHVybiBfYmluQkUudWkzMlswXTtcbiAgfSxcbiAgcmVhZEFTQ0lJOiAoYnVmZiwgcCwgbCkgPT4ge1xuICAgIHJldHVybiBsLm1hcCgoaSkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmW3AgKyBpXSkpLmpvaW4oJycpO1xuICB9LFxuICByZWFkRmxvYXQ6IChidWZmLCBwKSA9PiB7XG4gICAgY29uc3QgYSA9IF9iaW5CRS51aTg7XG4gICAgdGltZXMoNCwgKGkpID0+IHtcbiAgICAgIGFbaV0gPSBidWZmW3AgKyAzIC0gaV07XG4gICAgfSk7XG4gICAgcmV0dXJuIF9iaW5CRS5mbDMyWzBdO1xuICB9LFxuICByZWFkRG91YmxlOiAoYnVmZiwgcCkgPT4ge1xuICAgIGNvbnN0IGEgPSBfYmluQkUudWk4O1xuICAgIHRpbWVzKDgsIChpKSA9PiB7XG4gICAgICBhW2ldID0gYnVmZltwICsgNyAtIGldO1xuICAgIH0pO1xuICAgIHJldHVybiBfYmluQkUuZmw2NFswXTtcbiAgfSxcbiAgd3JpdGVVc2hvcnQ6IChidWZmLCBwLCBuKSA9PiB7XG4gICAgYnVmZltwXSA9IChuID4+IDgpICYgMjU1O1xuICAgIGJ1ZmZbcCArIDFdID0gbiAmIDI1NTtcbiAgfSxcbiAgd3JpdGVVaW50OiAoYnVmZiwgcCwgbikgPT4ge1xuICAgIGJ1ZmZbcF0gPSAobiA+PiAyNCkgJiAyNTU7XG4gICAgYnVmZltwICsgMV0gPSAobiA+PiAxNikgJiAyNTU7XG4gICAgYnVmZltwICsgMl0gPSAobiA+PiA4KSAmIDI1NTtcbiAgICBidWZmW3AgKyAzXSA9IChuID4+IDApICYgMjU1O1xuICB9LFxuICB3cml0ZUFTQ0lJOiAoYnVmZiwgcCwgcykgPT4ge1xuICAgIHRpbWVzKHMubGVuZ3RoLCAoaSkgPT4ge1xuICAgICAgYnVmZltwICsgaV0gPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgfSk7XG4gIH0sXG4gIHVpODogbmV3IFVpbnQ4QXJyYXkoOCksXG59O1xuXG5fYmluQkUuZmw2NCA9IG5ldyBGbG9hdDY0QXJyYXkoX2JpbkJFLnVpOC5idWZmZXIpO1xuXG5fYmluQkUud3JpdGVEb3VibGUgPSAoYnVmZiwgcCwgbikgPT4ge1xuICBfYmluQkUuZmw2NFswXSA9IG47XG4gIHRpbWVzKDgsIChpKSA9PiB7XG4gICAgYnVmZltwICsgaV0gPSBfYmluQkUudWk4WzcgLSBpXTtcbiAgfSk7XG59O1xuXG5jb25zdCBfd3JpdGVJRkQgPSAoYmluLCBkYXRhLCBfb2Zmc2V0LCBpZmQpID0+IHtcbiAgbGV0IG9mZnNldCA9IF9vZmZzZXQ7XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGlmZCkuZmlsdGVyKChrZXkpID0+IHtcbiAgICByZXR1cm4ga2V5ICE9PSB1bmRlZmluZWQgJiYga2V5ICE9PSBudWxsICYmIGtleSAhPT0gJ3VuZGVmaW5lZCc7XG4gIH0pO1xuXG4gIGJpbi53cml0ZVVzaG9ydChkYXRhLCBvZmZzZXQsIGtleXMubGVuZ3RoKTtcbiAgb2Zmc2V0ICs9IDI7XG5cbiAgbGV0IGVvZmYgPSBvZmZzZXQgKyAoMTIgKiBrZXlzLmxlbmd0aCkgKyA0O1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBsZXQgdGFnID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRhZyA9IGtleTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0YWcgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlTmFtZSA9IGZpZWxkVGFnVHlwZXNbdGFnXTtcbiAgICBjb25zdCB0eXBlTnVtID0gdHlwZU5hbWUyYnl0ZVt0eXBlTmFtZV07XG5cbiAgICBpZiAodHlwZU5hbWUgPT0gbnVsbCB8fCB0eXBlTmFtZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlTmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlIG9mIHRhZzogJHt0YWd9YCk7XG4gICAgfVxuXG4gICAgbGV0IHZhbCA9IGlmZFtrZXldO1xuXG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBnZXQgdmFsdWUgZm9yIGtleSAke2tleX1gKTtcbiAgICB9XG5cbiAgICAvLyBBU0NJSVogZm9ybWF0IHdpdGggdHJhaWxpbmcgMCBjaGFyYWN0ZXJcbiAgICAvLyBodHRwOi8vd3d3LmZpbGVmb3JtYXQuaW5mby9mb3JtYXQvdGlmZi9jb3Jpb24uaHRtXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzc4MzA0NC93aGF0cy10aGUtZGlmZmVyZW5jZS1iZXR3ZWVuLWFzY2lpei12cy1hc2NpaVxuICAgIGlmICh0eXBlTmFtZSA9PT0gJ0FTQ0lJJyAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiBlbmRzV2l0aCh2YWwsICdcXHUwMDAwJykgPT09IGZhbHNlKSB7XG4gICAgICB2YWwgKz0gJ1xcdTAwMDAnO1xuICAgIH1cblxuICAgIGNvbnN0IG51bSA9IHZhbC5sZW5ndGg7XG5cbiAgICBiaW4ud3JpdGVVc2hvcnQoZGF0YSwgb2Zmc2V0LCB0YWcpO1xuICAgIG9mZnNldCArPSAyO1xuXG4gICAgYmluLndyaXRlVXNob3J0KGRhdGEsIG9mZnNldCwgdHlwZU51bSk7XG4gICAgb2Zmc2V0ICs9IDI7XG5cbiAgICBiaW4ud3JpdGVVaW50KGRhdGEsIG9mZnNldCwgbnVtKTtcbiAgICBvZmZzZXQgKz0gNDtcblxuICAgIGxldCBkbGVuID0gWy0xLCAxLCAxLCAyLCA0LCA4LCAwLCAwLCAwLCAwLCAwLCAwLCA4XVt0eXBlTnVtXSAqIG51bTtcbiAgICBsZXQgdG9mZiA9IG9mZnNldDtcblxuICAgIGlmIChkbGVuID4gNCkge1xuICAgICAgYmluLndyaXRlVWludChkYXRhLCBvZmZzZXQsIGVvZmYpO1xuICAgICAgdG9mZiA9IGVvZmY7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVOYW1lID09PSAnQVNDSUknKSB7XG4gICAgICBiaW4ud3JpdGVBU0NJSShkYXRhLCB0b2ZmLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAodHlwZU5hbWUgPT09ICdTSE9SVCcpIHtcbiAgICAgIHRpbWVzKG51bSwgKGkpID0+IHtcbiAgICAgICAgYmluLndyaXRlVXNob3J0KGRhdGEsIHRvZmYgKyAoMiAqIGkpLCB2YWxbaV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlTmFtZSA9PT0gJ0xPTkcnKSB7XG4gICAgICB0aW1lcyhudW0sIChpKSA9PiB7XG4gICAgICAgIGJpbi53cml0ZVVpbnQoZGF0YSwgdG9mZiArICg0ICogaSksIHZhbFtpXSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSAnUkFUSU9OQUwnKSB7XG4gICAgICB0aW1lcyhudW0sIChpKSA9PiB7XG4gICAgICAgIGJpbi53cml0ZVVpbnQoZGF0YSwgdG9mZiArICg4ICogaSksIE1hdGgucm91bmQodmFsW2ldICogMTAwMDApKTtcbiAgICAgICAgYmluLndyaXRlVWludChkYXRhLCB0b2ZmICsgKDggKiBpKSArIDQsIDEwMDAwKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZU5hbWUgPT09ICdET1VCTEUnKSB7XG4gICAgICB0aW1lcyhudW0sIChpKSA9PiB7XG4gICAgICAgIGJpbi53cml0ZURvdWJsZShkYXRhLCB0b2ZmICsgKDggKiBpKSwgdmFsW2ldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChkbGVuID4gNCkge1xuICAgICAgZGxlbiArPSAoZGxlbiAmIDEpO1xuICAgICAgZW9mZiArPSBkbGVuO1xuICAgIH1cblxuICAgIG9mZnNldCArPSA0O1xuICB9XG5cbiAgcmV0dXJuIFtvZmZzZXQsIGVvZmZdO1xufTtcblxuY29uc3QgZW5jb2RlSWZkcyA9IChpZmRzKSA9PiB7XG4gIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShudW1CeXRlc0luSWZkKTtcbiAgbGV0IG9mZnNldCA9IDQ7XG4gIGNvbnN0IGJpbiA9IF9iaW5CRTtcblxuICAvLyBzZXQgYmlnLWVuZGlhbiBieXRlLW9yZGVyXG4gIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RJRkYjQnl0ZV9vcmRlclxuICBkYXRhWzBdID0gNzc7XG4gIGRhdGFbMV0gPSA3NztcblxuICAvLyBzZXQgZm9ybWF0LXZlcnNpb24gbnVtYmVyXG4gIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RJRkYjQnl0ZV9vcmRlclxuICBkYXRhWzNdID0gNDI7XG5cbiAgbGV0IGlmZG8gPSA4O1xuXG4gIGJpbi53cml0ZVVpbnQoZGF0YSwgb2Zmc2V0LCBpZmRvKTtcblxuICBvZmZzZXQgKz0gNDtcblxuICBpZmRzLmZvckVhY2goKGlmZCwgaSkgPT4ge1xuICAgIGNvbnN0IG5vZmZzID0gX3dyaXRlSUZEKGJpbiwgZGF0YSwgaWZkbywgaWZkKTtcbiAgICBpZmRvID0gbm9mZnNbMV07XG4gICAgaWYgKGkgPCBpZmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGJpbi53cml0ZVVpbnQoZGF0YSwgbm9mZnNbMF0sIGlmZG8pO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRhdGEuc2xpY2UpIHtcbiAgICByZXR1cm4gZGF0YS5zbGljZSgwLCBpZmRvKS5idWZmZXI7XG4gIH1cblxuICAvLyBub2RlIGhhc24ndCBpbXBsZW1lbnRlZCBzbGljZSBvbiBVaW50OEFycmF5IHlldFxuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShpZmRvKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZmRvOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBkYXRhW2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQuYnVmZmVyO1xufTtcblxuY29uc3QgZW5jb2RlSW1hZ2UgPSAodmFsdWVzLCB3aWR0aCwgaGVpZ2h0LCBtZXRhZGF0YSkgPT4ge1xuICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB5b3UgcGFzc2VkIGludG8gZW5jb2RlSW1hZ2UgYSB3aWR0aCBvZiB0eXBlICR7aGVpZ2h0fWApO1xuICB9XG5cbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgd2lkdGggPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHlvdSBwYXNzZWQgaW50byBlbmNvZGVJbWFnZSBhIHdpZHRoIG9mIHR5cGUgJHt3aWR0aH1gKTtcbiAgfVxuXG4gIGNvbnN0IGlmZCA9IHtcbiAgICAyNTY6IFt3aWR0aF0sIC8vIEltYWdlV2lkdGhcbiAgICAyNTc6IFtoZWlnaHRdLCAvLyBJbWFnZUxlbmd0aFxuICAgIDI3MzogW251bUJ5dGVzSW5JZmRdLCAvLyBzdHJpcHMgb2Zmc2V0XG4gICAgMjc4OiBbaGVpZ2h0XSwgLy8gUm93c1BlclN0cmlwXG4gICAgMzA1OiAnZ2VvdGlmZi5qcycsIC8vIG5vIGFycmF5IGZvciBBU0NJSShaKVxuICB9O1xuXG4gIGlmIChtZXRhZGF0YSkge1xuICAgIGZvciAoY29uc3QgaSBpbiBtZXRhZGF0YSkge1xuICAgICAgaWYgKG1ldGFkYXRhLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGlmZFtpXSA9IG1ldGFkYXRhW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHByZnggPSBuZXcgVWludDhBcnJheShlbmNvZGVJZmRzKFtpZmRdKSk7XG5cbiAgY29uc3QgaW1nID0gbmV3IFVpbnQ4QXJyYXkodmFsdWVzKTtcblxuICBjb25zdCBzYW1wbGVzUGVyUGl4ZWwgPSBpZmRbMjc3XTtcblxuICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobnVtQnl0ZXNJbklmZCArICh3aWR0aCAqIGhlaWdodCAqIHNhbXBsZXNQZXJQaXhlbCkpO1xuICB0aW1lcyhwcmZ4Lmxlbmd0aCwgKGkpID0+IHtcbiAgICBkYXRhW2ldID0gcHJmeFtpXTtcbiAgfSk7XG4gIGZvckVhY2goaW1nLCAodmFsdWUsIGkpID0+IHtcbiAgICBkYXRhW251bUJ5dGVzSW5JZmQgKyBpXSA9IHZhbHVlO1xuICB9KTtcblxuICByZXR1cm4gZGF0YS5idWZmZXI7XG59O1xuXG5jb25zdCBjb252ZXJ0VG9UaWRzID0gKGlucHV0KSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgIGlmIChrZXkgIT09ICdTdHJpcE9mZnNldHMnKSB7XG4gICAgICBpZiAoIW5hbWUyY29kZVtrZXldKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3Ioa2V5LCAnbm90IGluIG5hbWUyY29kZTonLCBPYmplY3Qua2V5cyhuYW1lMmNvZGUpKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdFtuYW1lMmNvZGVba2V5XV0gPSBpbnB1dFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgdG9BcnJheSA9IChpbnB1dCkgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIFtpbnB1dF07XG59O1xuXG5jb25zdCBtZXRhZGF0YURlZmF1bHRzID0gW1xuICBbJ0NvbXByZXNzaW9uJywgMV0sIC8vIG5vIGNvbXByZXNzaW9uXG4gIFsnUGxhbmFyQ29uZmlndXJhdGlvbicsIDFdLFxuICBbJ0V4dHJhU2FtcGxlcycsIDBdLFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlR2VvdGlmZihkYXRhLCBtZXRhZGF0YSkge1xuICBjb25zdCBpc0ZsYXR0ZW5lZCA9IHR5cGVvZiBkYXRhWzBdID09PSAnbnVtYmVyJztcblxuICBsZXQgaGVpZ2h0O1xuICBsZXQgbnVtQmFuZHM7XG4gIGxldCB3aWR0aDtcbiAgbGV0IGZsYXR0ZW5lZFZhbHVlcztcblxuICBpZiAoaXNGbGF0dGVuZWQpIHtcbiAgICBoZWlnaHQgPSBtZXRhZGF0YS5oZWlnaHQgfHwgbWV0YWRhdGEuSW1hZ2VMZW5ndGg7XG4gICAgd2lkdGggPSBtZXRhZGF0YS53aWR0aCB8fCBtZXRhZGF0YS5JbWFnZVdpZHRoO1xuICAgIG51bUJhbmRzID0gZGF0YS5sZW5ndGggLyAoaGVpZ2h0ICogd2lkdGgpO1xuICAgIGZsYXR0ZW5lZFZhbHVlcyA9IGRhdGE7XG4gIH0gZWxzZSB7XG4gICAgbnVtQmFuZHMgPSBkYXRhLmxlbmd0aDtcbiAgICBoZWlnaHQgPSBkYXRhWzBdLmxlbmd0aDtcbiAgICB3aWR0aCA9IGRhdGFbMF1bMF0ubGVuZ3RoO1xuICAgIGZsYXR0ZW5lZFZhbHVlcyA9IFtdO1xuICAgIHRpbWVzKGhlaWdodCwgKHJvd0luZGV4KSA9PiB7XG4gICAgICB0aW1lcyh3aWR0aCwgKGNvbHVtbkluZGV4KSA9PiB7XG4gICAgICAgIHRpbWVzKG51bUJhbmRzLCAoYmFuZEluZGV4KSA9PiB7XG4gICAgICAgICAgZmxhdHRlbmVkVmFsdWVzLnB1c2goZGF0YVtiYW5kSW5kZXhdW3Jvd0luZGV4XVtjb2x1bW5JbmRleF0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgbWV0YWRhdGEuSW1hZ2VMZW5ndGggPSBoZWlnaHQ7XG4gIGRlbGV0ZSBtZXRhZGF0YS5oZWlnaHQ7XG4gIG1ldGFkYXRhLkltYWdlV2lkdGggPSB3aWR0aDtcbiAgZGVsZXRlIG1ldGFkYXRhLndpZHRoO1xuXG4gIC8vIGNvbnN1bHQgaHR0cHM6Ly93d3cubG9jLmdvdi9wcmVzZXJ2YXRpb24vZGlnaXRhbC9mb3JtYXRzL2NvbnRlbnQvdGlmZl90YWdzLnNodG1sXG5cbiAgaWYgKCFtZXRhZGF0YS5CaXRzUGVyU2FtcGxlKSB7XG4gICAgbWV0YWRhdGEuQml0c1BlclNhbXBsZSA9IHRpbWVzKG51bUJhbmRzLCAoKSA9PiA4KTtcbiAgfVxuXG4gIG1ldGFkYXRhRGVmYXVsdHMuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gdGFnWzBdO1xuICAgIGlmICghbWV0YWRhdGFba2V5XSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0YWdbMV07XG4gICAgICBtZXRhZGF0YVtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBUaGUgY29sb3Igc3BhY2Ugb2YgdGhlIGltYWdlIGRhdGEuXG4gIC8vIDE9YmxhY2sgaXMgemVybyBhbmQgMj1SR0IuXG4gIGlmICghbWV0YWRhdGEuUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbikge1xuICAgIG1ldGFkYXRhLlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24gPSBtZXRhZGF0YS5CaXRzUGVyU2FtcGxlLmxlbmd0aCA9PT0gMyA/IDIgOiAxO1xuICB9XG5cbiAgLy8gVGhlIG51bWJlciBvZiBjb21wb25lbnRzIHBlciBwaXhlbC5cbiAgaWYgKCFtZXRhZGF0YS5TYW1wbGVzUGVyUGl4ZWwpIHtcbiAgICBtZXRhZGF0YS5TYW1wbGVzUGVyUGl4ZWwgPSBbbnVtQmFuZHNdO1xuICB9XG5cbiAgaWYgKCFtZXRhZGF0YS5TdHJpcEJ5dGVDb3VudHMpIHtcbiAgICAvLyB3ZSBhcmUgb25seSB3cml0aW5nIG9uZSBzdHJpcFxuICAgIG1ldGFkYXRhLlN0cmlwQnl0ZUNvdW50cyA9IFtudW1CYW5kcyAqIGhlaWdodCAqIHdpZHRoXTtcbiAgfVxuXG4gIGlmICghbWV0YWRhdGEuTW9kZWxQaXhlbFNjYWxlKSB7XG4gICAgLy8gYXNzdW1lcyByYXN0ZXIgdGFrZXMgdXAgZXhhY3RseSB0aGUgd2hvbGUgZ2xvYmVcbiAgICBtZXRhZGF0YS5Nb2RlbFBpeGVsU2NhbGUgPSBbMzYwIC8gd2lkdGgsIDE4MCAvIGhlaWdodCwgMF07XG4gIH1cblxuICBpZiAoIW1ldGFkYXRhLlNhbXBsZUZvcm1hdCkge1xuICAgIG1ldGFkYXRhLlNhbXBsZUZvcm1hdCA9IHRpbWVzKG51bUJhbmRzLCAoKSA9PiAxKTtcbiAgfVxuXG4gIC8vIGlmIGRpZG4ndCBwYXNzIGluIHByb2plY3Rpb24gaW5mb3JtYXRpb24sIGFzc3VtZSB0aGUgcG9wdWxhciA0MzI2IFwiZ2VvZ3JhcGhpYyBwcm9qZWN0aW9uXCJcbiAgaWYgKCFtZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eSgnR2VvZ3JhcGhpY1R5cGVHZW9LZXknKSAmJiAhbWV0YWRhdGEuaGFzT3duUHJvcGVydHkoJ1Byb2plY3RlZENTVHlwZUdlb0tleScpKSB7XG4gICAgbWV0YWRhdGEuR2VvZ3JhcGhpY1R5cGVHZW9LZXkgPSA0MzI2O1xuICAgIG1ldGFkYXRhLk1vZGVsVGllcG9pbnQgPSBbMCwgMCwgMCwgLTE4MCwgOTAsIDBdOyAvLyByYXN0ZXIgZml0cyB3aG9sZSBnbG9iZVxuICAgIG1ldGFkYXRhLkdlb2dDaXRhdGlvbkdlb0tleSA9ICdXR1MgODQnO1xuICAgIG1ldGFkYXRhLkdUTW9kZWxUeXBlR2VvS2V5ID0gMjtcbiAgfVxuXG4gIGNvbnN0IGdlb0tleXMgPSBPYmplY3Qua2V5cyhtZXRhZGF0YSlcbiAgICAuZmlsdGVyKChrZXkpID0+IGVuZHNXaXRoKGtleSwgJ0dlb0tleScpKVxuICAgIC5zb3J0KChhLCBiKSA9PiBuYW1lMmNvZGVbYV0gLSBuYW1lMmNvZGVbYl0pO1xuXG4gIGlmICghbWV0YWRhdGEuR2VvQXNjaWlQYXJhbXMpIHtcbiAgICBsZXQgZ2VvQXNjaWlQYXJhbXMgPSAnJztcbiAgICBnZW9LZXlzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGNvZGUgPSBOdW1iZXIobmFtZTJjb2RlW25hbWVdKTtcbiAgICAgIGNvbnN0IHRhZ1R5cGUgPSBmaWVsZFRhZ1R5cGVzW2NvZGVdO1xuICAgICAgaWYgKHRhZ1R5cGUgPT09ICdBU0NJSScpIHtcbiAgICAgICAgZ2VvQXNjaWlQYXJhbXMgKz0gYCR7bWV0YWRhdGFbbmFtZV0udG9TdHJpbmcoKX1cXHUwMDAwYDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZ2VvQXNjaWlQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgbWV0YWRhdGEuR2VvQXNjaWlQYXJhbXMgPSBnZW9Bc2NpaVBhcmFtcztcbiAgICB9XG4gIH1cblxuICBpZiAoIW1ldGFkYXRhLkdlb0tleURpcmVjdG9yeSkge1xuICAgIGNvbnN0IE51bWJlck9mS2V5cyA9IGdlb0tleXMubGVuZ3RoO1xuXG4gICAgY29uc3QgR2VvS2V5RGlyZWN0b3J5ID0gWzEsIDEsIDAsIE51bWJlck9mS2V5c107XG4gICAgZ2VvS2V5cy5mb3JFYWNoKChnZW9LZXkpID0+IHtcbiAgICAgIGNvbnN0IEtleUlEID0gTnVtYmVyKG5hbWUyY29kZVtnZW9LZXldKTtcbiAgICAgIEdlb0tleURpcmVjdG9yeS5wdXNoKEtleUlEKTtcblxuICAgICAgbGV0IENvdW50O1xuICAgICAgbGV0IFRJRkZUYWdMb2NhdGlvbjtcbiAgICAgIGxldCB2YWx1ZU9mZnNldDtcbiAgICAgIGlmIChmaWVsZFRhZ1R5cGVzW0tleUlEXSA9PT0gJ1NIT1JUJykge1xuICAgICAgICBDb3VudCA9IDE7XG4gICAgICAgIFRJRkZUYWdMb2NhdGlvbiA9IDA7XG4gICAgICAgIHZhbHVlT2Zmc2V0ID0gbWV0YWRhdGFbZ2VvS2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvS2V5ID09PSAnR2VvZ0NpdGF0aW9uR2VvS2V5Jykge1xuICAgICAgICBDb3VudCA9IG1ldGFkYXRhLkdlb0FzY2lpUGFyYW1zLmxlbmd0aDtcbiAgICAgICAgVElGRlRhZ0xvY2F0aW9uID0gTnVtYmVyKG5hbWUyY29kZS5HZW9Bc2NpaVBhcmFtcyk7XG4gICAgICAgIHZhbHVlT2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbZ2VvdGlmZi5qc10gY291bGRuJ3QgZ2V0IFRJRkZUYWdMb2NhdGlvbiBmb3IgJHtnZW9LZXl9YCk7XG4gICAgICB9XG4gICAgICBHZW9LZXlEaXJlY3RvcnkucHVzaChUSUZGVGFnTG9jYXRpb24pO1xuICAgICAgR2VvS2V5RGlyZWN0b3J5LnB1c2goQ291bnQpO1xuICAgICAgR2VvS2V5RGlyZWN0b3J5LnB1c2godmFsdWVPZmZzZXQpO1xuICAgIH0pO1xuICAgIG1ldGFkYXRhLkdlb0tleURpcmVjdG9yeSA9IEdlb0tleURpcmVjdG9yeTtcbiAgfVxuXG4gIC8vIGRlbGV0ZSBHZW9LZXlzIGZyb20gbWV0YWRhdGEsIGJlY2F1c2Ugc3RvcmVkIGluIEdlb0tleURpcmVjdG9yeSB0YWdcbiAgZm9yIChjb25zdCBnZW9LZXkgb2YgZ2VvS2V5cykge1xuICAgIGlmIChtZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eShnZW9LZXkpKSB7XG4gICAgICBkZWxldGUgbWV0YWRhdGFbZ2VvS2V5XTtcbiAgICB9XG4gIH1cblxuICBbXG4gICAgJ0NvbXByZXNzaW9uJyxcbiAgICAnRXh0cmFTYW1wbGVzJyxcbiAgICAnR2VvZ3JhcGhpY1R5cGVHZW9LZXknLFxuICAgICdHVE1vZGVsVHlwZUdlb0tleScsXG4gICAgJ0dUUmFzdGVyVHlwZUdlb0tleScsXG4gICAgJ0ltYWdlTGVuZ3RoJywgLy8gc3lub255bSBvZiBJbWFnZUhlaWdodFxuICAgICdJbWFnZVdpZHRoJyxcbiAgICAnT3JpZW50YXRpb24nLFxuICAgICdQaG90b21ldHJpY0ludGVycHJldGF0aW9uJyxcbiAgICAnUHJvamVjdGVkQ1NUeXBlR2VvS2V5JyxcbiAgICAnUGxhbmFyQ29uZmlndXJhdGlvbicsXG4gICAgJ1Jlc29sdXRpb25Vbml0JyxcbiAgICAnU2FtcGxlc1BlclBpeGVsJyxcbiAgICAnWFBvc2l0aW9uJyxcbiAgICAnWVBvc2l0aW9uJyxcbiAgICAnUm93c1BlclN0cmlwJyxcbiAgXS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgaWYgKG1ldGFkYXRhW25hbWVdKSB7XG4gICAgICBtZXRhZGF0YVtuYW1lXSA9IHRvQXJyYXkobWV0YWRhdGFbbmFtZV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgZW5jb2RlZE1ldGFkYXRhID0gY29udmVydFRvVGlkcyhtZXRhZGF0YSk7XG5cbiAgY29uc3Qgb3V0cHV0SW1hZ2UgPSBlbmNvZGVJbWFnZShmbGF0dGVuZWRWYWx1ZXMsIHdpZHRoLCBoZWlnaHQsIGVuY29kZWRNZXRhZGF0YSk7XG5cbiAgcmV0dXJuIG91dHB1dEltYWdlO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/geotiffwriter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/globals.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/globals.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtraSamplesValues: () => (/* binding */ ExtraSamplesValues),\n/* harmony export */   LercAddCompression: () => (/* binding */ LercAddCompression),\n/* harmony export */   LercParameters: () => (/* binding */ LercParameters),\n/* harmony export */   arrayFields: () => (/* binding */ arrayFields),\n/* harmony export */   fieldTagNames: () => (/* binding */ fieldTagNames),\n/* harmony export */   fieldTagTypes: () => (/* binding */ fieldTagTypes),\n/* harmony export */   fieldTags: () => (/* binding */ fieldTags),\n/* harmony export */   fieldTypeNames: () => (/* binding */ fieldTypeNames),\n/* harmony export */   fieldTypes: () => (/* binding */ fieldTypes),\n/* harmony export */   geoKeyNames: () => (/* binding */ geoKeyNames),\n/* harmony export */   geoKeys: () => (/* binding */ geoKeys),\n/* harmony export */   photometricInterpretations: () => (/* binding */ photometricInterpretations)\n/* harmony export */ });\nconst fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nconst fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nconst fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nconst arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nconst fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nconst fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nconst photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nconst ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nconst LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nconst LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nconst geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nconst geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nbG9iYWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZ2xvYmFscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgZmllbGRUYWdOYW1lcyA9IHtcbiAgLy8gVElGRiBCYXNlbGluZVxuICAweDAxM0I6ICdBcnRpc3QnLFxuICAweDAxMDI6ICdCaXRzUGVyU2FtcGxlJyxcbiAgMHgwMTA5OiAnQ2VsbExlbmd0aCcsXG4gIDB4MDEwODogJ0NlbGxXaWR0aCcsXG4gIDB4MDE0MDogJ0NvbG9yTWFwJyxcbiAgMHgwMTAzOiAnQ29tcHJlc3Npb24nLFxuICAweDgyOTg6ICdDb3B5cmlnaHQnLFxuICAweDAxMzI6ICdEYXRlVGltZScsXG4gIDB4MDE1MjogJ0V4dHJhU2FtcGxlcycsXG4gIDB4MDEwQTogJ0ZpbGxPcmRlcicsXG4gIDB4MDEyMTogJ0ZyZWVCeXRlQ291bnRzJyxcbiAgMHgwMTIwOiAnRnJlZU9mZnNldHMnLFxuICAweDAxMjM6ICdHcmF5UmVzcG9uc2VDdXJ2ZScsXG4gIDB4MDEyMjogJ0dyYXlSZXNwb25zZVVuaXQnLFxuICAweDAxM0M6ICdIb3N0Q29tcHV0ZXInLFxuICAweDAxMEU6ICdJbWFnZURlc2NyaXB0aW9uJyxcbiAgMHgwMTAxOiAnSW1hZ2VMZW5ndGgnLFxuICAweDAxMDA6ICdJbWFnZVdpZHRoJyxcbiAgMHgwMTBGOiAnTWFrZScsXG4gIDB4MDExOTogJ01heFNhbXBsZVZhbHVlJyxcbiAgMHgwMTE4OiAnTWluU2FtcGxlVmFsdWUnLFxuICAweDAxMTA6ICdNb2RlbCcsXG4gIDB4MDBGRTogJ05ld1N1YmZpbGVUeXBlJyxcbiAgMHgwMTEyOiAnT3JpZW50YXRpb24nLFxuICAweDAxMDY6ICdQaG90b21ldHJpY0ludGVycHJldGF0aW9uJyxcbiAgMHgwMTFDOiAnUGxhbmFyQ29uZmlndXJhdGlvbicsXG4gIDB4MDEyODogJ1Jlc29sdXRpb25Vbml0JyxcbiAgMHgwMTE2OiAnUm93c1BlclN0cmlwJyxcbiAgMHgwMTE1OiAnU2FtcGxlc1BlclBpeGVsJyxcbiAgMHgwMTMxOiAnU29mdHdhcmUnLFxuICAweDAxMTc6ICdTdHJpcEJ5dGVDb3VudHMnLFxuICAweDAxMTE6ICdTdHJpcE9mZnNldHMnLFxuICAweDAwRkY6ICdTdWJmaWxlVHlwZScsXG4gIDB4MDEwNzogJ1RocmVzaGhvbGRpbmcnLFxuICAweDAxMUE6ICdYUmVzb2x1dGlvbicsXG4gIDB4MDExQjogJ1lSZXNvbHV0aW9uJyxcblxuICAvLyBUSUZGIEV4dGVuZGVkXG4gIDB4MDE0NjogJ0JhZEZheExpbmVzJyxcbiAgMHgwMTQ3OiAnQ2xlYW5GYXhEYXRhJyxcbiAgMHgwMTU3OiAnQ2xpcFBhdGgnLFxuICAweDAxNDg6ICdDb25zZWN1dGl2ZUJhZEZheExpbmVzJyxcbiAgMHgwMUIxOiAnRGVjb2RlJyxcbiAgMHgwMUIyOiAnRGVmYXVsdEltYWdlQ29sb3InLFxuICAweDAxMEQ6ICdEb2N1bWVudE5hbWUnLFxuICAweDAxNTA6ICdEb3RSYW5nZScsXG4gIDB4MDE0MTogJ0hhbGZ0b25lSGludHMnLFxuICAweDAxNUE6ICdJbmRleGVkJyxcbiAgMHgwMTVCOiAnSlBFR1RhYmxlcycsXG4gIDB4MDExRDogJ1BhZ2VOYW1lJyxcbiAgMHgwMTI5OiAnUGFnZU51bWJlcicsXG4gIDB4MDEzRDogJ1ByZWRpY3RvcicsXG4gIDB4MDEzRjogJ1ByaW1hcnlDaHJvbWF0aWNpdGllcycsXG4gIDB4MDIxNDogJ1JlZmVyZW5jZUJsYWNrV2hpdGUnLFxuICAweDAxNTM6ICdTYW1wbGVGb3JtYXQnLFxuICAweDAxNTQ6ICdTTWluU2FtcGxlVmFsdWUnLFxuICAweDAxNTU6ICdTTWF4U2FtcGxlVmFsdWUnLFxuICAweDAyMkY6ICdTdHJpcFJvd0NvdW50cycsXG4gIDB4MDE0QTogJ1N1YklGRHMnLFxuICAweDAxMjQ6ICdUNE9wdGlvbnMnLFxuICAweDAxMjU6ICdUNk9wdGlvbnMnLFxuICAweDAxNDU6ICdUaWxlQnl0ZUNvdW50cycsXG4gIDB4MDE0MzogJ1RpbGVMZW5ndGgnLFxuICAweDAxNDQ6ICdUaWxlT2Zmc2V0cycsXG4gIDB4MDE0MjogJ1RpbGVXaWR0aCcsXG4gIDB4MDEyRDogJ1RyYW5zZmVyRnVuY3Rpb24nLFxuICAweDAxM0U6ICdXaGl0ZVBvaW50JyxcbiAgMHgwMTU4OiAnWENsaXBQYXRoVW5pdHMnLFxuICAweDAxMUU6ICdYUG9zaXRpb24nLFxuICAweDAyMTE6ICdZQ2JDckNvZWZmaWNpZW50cycsXG4gIDB4MDIxMzogJ1lDYkNyUG9zaXRpb25pbmcnLFxuICAweDAyMTI6ICdZQ2JDclN1YlNhbXBsaW5nJyxcbiAgMHgwMTU5OiAnWUNsaXBQYXRoVW5pdHMnLFxuICAweDAxMUY6ICdZUG9zaXRpb24nLFxuXG4gIC8vIEVYSUZcbiAgMHg5MjAyOiAnQXBlcnR1cmVWYWx1ZScsXG4gIDB4QTAwMTogJ0NvbG9yU3BhY2UnLFxuICAweDkwMDQ6ICdEYXRlVGltZURpZ2l0aXplZCcsXG4gIDB4OTAwMzogJ0RhdGVUaW1lT3JpZ2luYWwnLFxuICAweDg3Njk6ICdFeGlmIElGRCcsXG4gIDB4OTAwMDogJ0V4aWZWZXJzaW9uJyxcbiAgMHg4MjlBOiAnRXhwb3N1cmVUaW1lJyxcbiAgMHhBMzAwOiAnRmlsZVNvdXJjZScsXG4gIDB4OTIwOTogJ0ZsYXNoJyxcbiAgMHhBMDAwOiAnRmxhc2hwaXhWZXJzaW9uJyxcbiAgMHg4MjlEOiAnRk51bWJlcicsXG4gIDB4QTQyMDogJ0ltYWdlVW5pcXVlSUQnLFxuICAweDkyMDg6ICdMaWdodFNvdXJjZScsXG4gIDB4OTI3QzogJ01ha2VyTm90ZScsXG4gIDB4OTIwMTogJ1NodXR0ZXJTcGVlZFZhbHVlJyxcbiAgMHg5Mjg2OiAnVXNlckNvbW1lbnQnLFxuXG4gIC8vIElQVENcbiAgMHg4M0JCOiAnSVBUQycsXG5cbiAgLy8gSUNDXG4gIDB4ODc3MzogJ0lDQyBQcm9maWxlJyxcblxuICAvLyBYTVBcbiAgMHgwMkJDOiAnWE1QJyxcblxuICAvLyBHREFMXG4gIDB4QTQ4MDogJ0dEQUxfTUVUQURBVEEnLFxuICAweEE0ODE6ICdHREFMX05PREFUQScsXG5cbiAgLy8gUGhvdG9zaG9wXG4gIDB4ODY0OTogJ1Bob3Rvc2hvcCcsXG5cbiAgLy8gR2VvVGlmZlxuICAweDgzMEU6ICdNb2RlbFBpeGVsU2NhbGUnLFxuICAweDg0ODI6ICdNb2RlbFRpZXBvaW50JyxcbiAgMHg4NUQ4OiAnTW9kZWxUcmFuc2Zvcm1hdGlvbicsXG4gIDB4ODdBRjogJ0dlb0tleURpcmVjdG9yeScsXG4gIDB4ODdCMDogJ0dlb0RvdWJsZVBhcmFtcycsXG4gIDB4ODdCMTogJ0dlb0FzY2lpUGFyYW1zJyxcblxuICAvLyBMRVJDXG4gIDB4QzVGMjogJ0xlcmNQYXJhbWV0ZXJzJyxcbn07XG5cbmV4cG9ydCBjb25zdCBmaWVsZFRhZ3MgPSB7fTtcbmZvciAoY29uc3Qga2V5IGluIGZpZWxkVGFnTmFtZXMpIHtcbiAgaWYgKGZpZWxkVGFnTmFtZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIGZpZWxkVGFnc1tmaWVsZFRhZ05hbWVzW2tleV1dID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGZpZWxkVGFnVHlwZXMgPSB7XG4gIDI1NjogJ1NIT1JUJyxcbiAgMjU3OiAnU0hPUlQnLFxuICAyNTg6ICdTSE9SVCcsXG4gIDI1OTogJ1NIT1JUJyxcbiAgMjYyOiAnU0hPUlQnLFxuICAyNzM6ICdMT05HJyxcbiAgMjc0OiAnU0hPUlQnLFxuICAyNzc6ICdTSE9SVCcsXG4gIDI3ODogJ0xPTkcnLFxuICAyNzk6ICdMT05HJyxcbiAgMjgyOiAnUkFUSU9OQUwnLFxuICAyODM6ICdSQVRJT05BTCcsXG4gIDI4NDogJ1NIT1JUJyxcbiAgMjg2OiAnU0hPUlQnLFxuICAyODc6ICdSQVRJT05BTCcsXG4gIDI5NjogJ1NIT1JUJyxcbiAgMjk3OiAnU0hPUlQnLFxuICAzMDU6ICdBU0NJSScsXG4gIDMwNjogJ0FTQ0lJJyxcbiAgMzM4OiAnU0hPUlQnLFxuICAzMzk6ICdTSE9SVCcsXG4gIDUxMzogJ0xPTkcnLFxuICA1MTQ6ICdMT05HJyxcbiAgMTAyNDogJ1NIT1JUJyxcbiAgMTAyNTogJ1NIT1JUJyxcbiAgMjA0ODogJ1NIT1JUJyxcbiAgMjA0OTogJ0FTQ0lJJyxcbiAgMzA3MjogJ1NIT1JUJyxcbiAgMzA3MzogJ0FTQ0lJJyxcbiAgMzM1NTA6ICdET1VCTEUnLFxuICAzMzkyMjogJ0RPVUJMRScsXG4gIDM0MjY0OiAnRE9VQkxFJyxcbiAgMzQ2NjU6ICdMT05HJyxcbiAgMzQ3MzU6ICdTSE9SVCcsXG4gIDM0NzM2OiAnRE9VQkxFJyxcbiAgMzQ3Mzc6ICdBU0NJSScsXG4gIDQyMTEzOiAnQVNDSUknLFxufTtcblxuZXhwb3J0IGNvbnN0IGFycmF5RmllbGRzID0gW1xuICBmaWVsZFRhZ3MuQml0c1BlclNhbXBsZSxcbiAgZmllbGRUYWdzLkV4dHJhU2FtcGxlcyxcbiAgZmllbGRUYWdzLlNhbXBsZUZvcm1hdCxcbiAgZmllbGRUYWdzLlN0cmlwQnl0ZUNvdW50cyxcbiAgZmllbGRUYWdzLlN0cmlwT2Zmc2V0cyxcbiAgZmllbGRUYWdzLlN0cmlwUm93Q291bnRzLFxuICBmaWVsZFRhZ3MuVGlsZUJ5dGVDb3VudHMsXG4gIGZpZWxkVGFncy5UaWxlT2Zmc2V0cyxcbiAgZmllbGRUYWdzLlN1YklGRHMsXG5dO1xuXG5leHBvcnQgY29uc3QgZmllbGRUeXBlTmFtZXMgPSB7XG4gIDB4MDAwMTogJ0JZVEUnLFxuICAweDAwMDI6ICdBU0NJSScsXG4gIDB4MDAwMzogJ1NIT1JUJyxcbiAgMHgwMDA0OiAnTE9ORycsXG4gIDB4MDAwNTogJ1JBVElPTkFMJyxcbiAgMHgwMDA2OiAnU0JZVEUnLFxuICAweDAwMDc6ICdVTkRFRklORUQnLFxuICAweDAwMDg6ICdTU0hPUlQnLFxuICAweDAwMDk6ICdTTE9ORycsXG4gIDB4MDAwQTogJ1NSQVRJT05BTCcsXG4gIDB4MDAwQjogJ0ZMT0FUJyxcbiAgMHgwMDBDOiAnRE9VQkxFJyxcbiAgLy8gSUZEIG9mZnNldCwgc3VnZ2VzdGVkIGJ5IGh0dHBzOi8vb3dsLnBoeS5xdWVlbnN1LmNhL35waGlsL2V4aWZ0b29sL3N0YW5kYXJkcy5odG1sXG4gIDB4MDAwRDogJ0lGRCcsXG4gIC8vIGludHJvZHVjZWQgYnkgQmlnVElGRlxuICAweDAwMTA6ICdMT05HOCcsXG4gIDB4MDAxMTogJ1NMT05HOCcsXG4gIDB4MDAxMjogJ0lGRDgnLFxufTtcblxuZXhwb3J0IGNvbnN0IGZpZWxkVHlwZXMgPSB7fTtcbmZvciAoY29uc3Qga2V5IGluIGZpZWxkVHlwZU5hbWVzKSB7XG4gIGlmIChmaWVsZFR5cGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgZmllbGRUeXBlc1tmaWVsZFR5cGVOYW1lc1trZXldXSA9IHBhcnNlSW50KGtleSwgMTApO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucyA9IHtcbiAgV2hpdGVJc1plcm86IDAsXG4gIEJsYWNrSXNaZXJvOiAxLFxuICBSR0I6IDIsXG4gIFBhbGV0dGU6IDMsXG4gIFRyYW5zcGFyZW5jeU1hc2s6IDQsXG4gIENNWUs6IDUsXG4gIFlDYkNyOiA2LFxuXG4gIENJRUxhYjogOCxcbiAgSUNDTGFiOiA5LFxufTtcblxuZXhwb3J0IGNvbnN0IEV4dHJhU2FtcGxlc1ZhbHVlcyA9IHtcbiAgVW5zcGVjaWZpZWQ6IDAsXG4gIEFzc29jYWxwaGE6IDEsXG4gIFVuYXNzYWxwaGE6IDIsXG59O1xuXG5leHBvcnQgY29uc3QgTGVyY1BhcmFtZXRlcnMgPSB7XG4gIFZlcnNpb246IDAsXG4gIEFkZENvbXByZXNzaW9uOiAxLFxufTtcblxuZXhwb3J0IGNvbnN0IExlcmNBZGRDb21wcmVzc2lvbiA9IHtcbiAgTm9uZTogMCxcbiAgRGVmbGF0ZTogMSxcbiAgWnN0YW5kYXJkOiAyLFxufTtcblxuZXhwb3J0IGNvbnN0IGdlb0tleU5hbWVzID0ge1xuICAxMDI0OiAnR1RNb2RlbFR5cGVHZW9LZXknLFxuICAxMDI1OiAnR1RSYXN0ZXJUeXBlR2VvS2V5JyxcbiAgMTAyNjogJ0dUQ2l0YXRpb25HZW9LZXknLFxuICAyMDQ4OiAnR2VvZ3JhcGhpY1R5cGVHZW9LZXknLFxuICAyMDQ5OiAnR2VvZ0NpdGF0aW9uR2VvS2V5JyxcbiAgMjA1MDogJ0dlb2dHZW9kZXRpY0RhdHVtR2VvS2V5JyxcbiAgMjA1MTogJ0dlb2dQcmltZU1lcmlkaWFuR2VvS2V5JyxcbiAgMjA1MjogJ0dlb2dMaW5lYXJVbml0c0dlb0tleScsXG4gIDIwNTM6ICdHZW9nTGluZWFyVW5pdFNpemVHZW9LZXknLFxuICAyMDU0OiAnR2VvZ0FuZ3VsYXJVbml0c0dlb0tleScsXG4gIDIwNTU6ICdHZW9nQW5ndWxhclVuaXRTaXplR2VvS2V5JyxcbiAgMjA1NjogJ0dlb2dFbGxpcHNvaWRHZW9LZXknLFxuICAyMDU3OiAnR2VvZ1NlbWlNYWpvckF4aXNHZW9LZXknLFxuICAyMDU4OiAnR2VvZ1NlbWlNaW5vckF4aXNHZW9LZXknLFxuICAyMDU5OiAnR2VvZ0ludkZsYXR0ZW5pbmdHZW9LZXknLFxuICAyMDYwOiAnR2VvZ0F6aW11dGhVbml0c0dlb0tleScsXG4gIDIwNjE6ICdHZW9nUHJpbWVNZXJpZGlhbkxvbmdHZW9LZXknLFxuICAyMDYyOiAnR2VvZ1RPV0dTODRHZW9LZXknLFxuICAzMDcyOiAnUHJvamVjdGVkQ1NUeXBlR2VvS2V5JyxcbiAgMzA3MzogJ1BDU0NpdGF0aW9uR2VvS2V5JyxcbiAgMzA3NDogJ1Byb2plY3Rpb25HZW9LZXknLFxuICAzMDc1OiAnUHJvakNvb3JkVHJhbnNHZW9LZXknLFxuICAzMDc2OiAnUHJvakxpbmVhclVuaXRzR2VvS2V5JyxcbiAgMzA3NzogJ1Byb2pMaW5lYXJVbml0U2l6ZUdlb0tleScsXG4gIDMwNzg6ICdQcm9qU3RkUGFyYWxsZWwxR2VvS2V5JyxcbiAgMzA3OTogJ1Byb2pTdGRQYXJhbGxlbDJHZW9LZXknLFxuICAzMDgwOiAnUHJvak5hdE9yaWdpbkxvbmdHZW9LZXknLFxuICAzMDgxOiAnUHJvak5hdE9yaWdpbkxhdEdlb0tleScsXG4gIDMwODI6ICdQcm9qRmFsc2VFYXN0aW5nR2VvS2V5JyxcbiAgMzA4MzogJ1Byb2pGYWxzZU5vcnRoaW5nR2VvS2V5JyxcbiAgMzA4NDogJ1Byb2pGYWxzZU9yaWdpbkxvbmdHZW9LZXknLFxuICAzMDg1OiAnUHJvakZhbHNlT3JpZ2luTGF0R2VvS2V5JyxcbiAgMzA4NjogJ1Byb2pGYWxzZU9yaWdpbkVhc3RpbmdHZW9LZXknLFxuICAzMDg3OiAnUHJvakZhbHNlT3JpZ2luTm9ydGhpbmdHZW9LZXknLFxuICAzMDg4OiAnUHJvakNlbnRlckxvbmdHZW9LZXknLFxuICAzMDg5OiAnUHJvakNlbnRlckxhdEdlb0tleScsXG4gIDMwOTA6ICdQcm9qQ2VudGVyRWFzdGluZ0dlb0tleScsXG4gIDMwOTE6ICdQcm9qQ2VudGVyTm9ydGhpbmdHZW9LZXknLFxuICAzMDkyOiAnUHJvalNjYWxlQXROYXRPcmlnaW5HZW9LZXknLFxuICAzMDkzOiAnUHJvalNjYWxlQXRDZW50ZXJHZW9LZXknLFxuICAzMDk0OiAnUHJvakF6aW11dGhBbmdsZUdlb0tleScsXG4gIDMwOTU6ICdQcm9qU3RyYWlnaHRWZXJ0UG9sZUxvbmdHZW9LZXknLFxuICAzMDk2OiAnUHJvalJlY3RpZmllZEdyaWRBbmdsZUdlb0tleScsXG4gIDQwOTY6ICdWZXJ0aWNhbENTVHlwZUdlb0tleScsXG4gIDQwOTc6ICdWZXJ0aWNhbENpdGF0aW9uR2VvS2V5JyxcbiAgNDA5ODogJ1ZlcnRpY2FsRGF0dW1HZW9LZXknLFxuICA0MDk5OiAnVmVydGljYWxVbml0c0dlb0tleScsXG59O1xuXG5leHBvcnQgY29uc3QgZ2VvS2V5cyA9IHt9O1xuZm9yIChjb25zdCBrZXkgaW4gZ2VvS2V5TmFtZXMpIHtcbiAgaWYgKGdlb0tleU5hbWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICBnZW9LZXlzW2dlb0tleU5hbWVzW2tleV1dID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/globals.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/logging.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/logging.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   debug: () => (/* binding */ debug),\n/* harmony export */   error: () => (/* binding */ error),\n/* harmony export */   info: () => (/* binding */ info),\n/* harmony export */   log: () => (/* binding */ log),\n/* harmony export */   setLogger: () => (/* binding */ setLogger),\n/* harmony export */   time: () => (/* binding */ time),\n/* harmony export */   timeEnd: () => (/* binding */ timeEnd),\n/* harmony export */   warn: () => (/* binding */ warn)\n/* harmony export */ });\n/**\n * A no-op logger\n */\nclass DummyLogger {\n  log() {}\n\n  debug() {}\n\n  info() {}\n\n  warn() {}\n\n  error() {}\n\n  time() {}\n\n  timeEnd() {}\n}\n\nlet LOGGER = new DummyLogger();\n\n/**\n *\n * @param {object} logger the new logger. e.g `console`\n */\nfunction setLogger(logger = new DummyLogger()) {\n  LOGGER = logger;\n}\n\nfunction debug(...args) {\n  return LOGGER.debug(...args);\n}\n\nfunction log(...args) {\n  return LOGGER.log(...args);\n}\n\nfunction info(...args) {\n  return LOGGER.info(...args);\n}\n\nfunction warn(...args) {\n  return LOGGER.warn(...args);\n}\n\nfunction error(...args) {\n  return LOGGER.error(...args);\n}\n\nfunction time(...args) {\n  return LOGGER.time(...args);\n}\n\nfunction timeEnd(...args) {\n  return LOGGER.timeEnd(...args);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9sb2dnaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2xvZ2dpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIG5vLW9wIGxvZ2dlclxuICovXG5jbGFzcyBEdW1teUxvZ2dlciB7XG4gIGxvZygpIHt9XG5cbiAgZGVidWcoKSB7fVxuXG4gIGluZm8oKSB7fVxuXG4gIHdhcm4oKSB7fVxuXG4gIGVycm9yKCkge31cblxuICB0aW1lKCkge31cblxuICB0aW1lRW5kKCkge31cbn1cblxubGV0IExPR0dFUiA9IG5ldyBEdW1teUxvZ2dlcigpO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbG9nZ2VyIHRoZSBuZXcgbG9nZ2VyLiBlLmcgYGNvbnNvbGVgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRMb2dnZXIobG9nZ2VyID0gbmV3IER1bW15TG9nZ2VyKCkpIHtcbiAgTE9HR0VSID0gbG9nZ2VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuICByZXR1cm4gTE9HR0VSLmRlYnVnKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIExPR0dFUi5sb2coLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmZvKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIExPR0dFUi5pbmZvKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2FybiguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIud2FybiguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIExPR0dFUi5lcnJvciguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWUoLi4uYXJncykge1xuICByZXR1cm4gTE9HR0VSLnRpbWUoLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lRW5kKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIExPR0dFUi50aW1lRW5kKC4uLmFyZ3MpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/logging.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/pool.js":
/*!**************************************************!*\
  !*** ./node_modules/geotiff/dist-module/pool.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compression/index.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/index.js\");\n\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/geotiff\"), __webpack_require__.e(\"vendor-chunks/web-worker\"), __webpack_require__.e(\"_ssr_node_modules_web-worker_src_node_lazy_recursive\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./worker/decoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/worker/decoder.js\")).then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? (0,_compression_index_js__WEBPACK_IMPORTED_MODULE_0__.getDecoder)(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pool);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9wb29sLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9EOztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMlZBQTZCO0FBQ3JDO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyw4QkFBOEIsOEJBQThCO0FBQzVEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsSUFBSSxFQUFDIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3Bvb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0RGVjb2RlciB9IGZyb20gJy4vY29tcHJlc3Npb24vaW5kZXguanMnO1xuXG5jb25zdCBkZWZhdWx0UG9vbFNpemUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IChuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSB8fCAyKSA6IDI7XG5cbi8qKlxuICogQG1vZHVsZSBwb29sXG4gKi9cblxuLyoqXG4gKiBQb29sIGZvciB3b3JrZXJzIHRvIGRlY29kZSBjaHVua3Mgb2YgdGhlIGltYWdlcy5cbiAqL1xuY2xhc3MgUG9vbCB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtzaXplXSBUaGUgc2l6ZSBvZiB0aGUgcG9vbC4gRGVmYXVsdHMgdG8gdGhlIG51bWJlciBvZiBDUFVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZS4gV2hlbiB0aGlzIHBhcmFtZXRlciBpcyBgbnVsbGAgb3IgMCwgdGhlbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgZGVjb2Rpbmcgd2lsbCBiZSBkb25lIGluIHRoZSBtYWluIHRocmVhZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigpOiBXb3JrZXJ9IFtjcmVhdGVXb3JrZXJdIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSBkZWNvZGVyIHdvcmtlci5cbiAgICogRGVmYXVsdHMgdG8gYSB3b3JrZXIgd2l0aCBhbGwgZGVjb2RlcnMgdGhhdCBzaGlwIHdpdGggZ2VvdGlmZi5qcy4gVGhlIGBjcmVhdGVXb3JrZXIoKWBcbiAgICogZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGEgYFdvcmtlcmAgY29tcGF0aWJsZSB3aXRoIFdlYiBXb3JrZXJzLiBGb3IgY29kZSB0aGF0XG4gICAqIHJ1bnMgaW4gTm9kZSwgW3dlYi13b3JrZXJdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3dlYi13b3JrZXIpIGlzIGEgZ29vZCBjaG9pY2UuXG4gICAqXG4gICAqIEEgd29ya2VyIHRoYXQgdXNlcyBhIGN1c3RvbSBsencgZGVjb2RlciB3b3VsZCBsb29rIGxpa2UgdGhpcyBgbXktY3VzdG9tLXdvcmtlci5qc2AgZmlsZTpcbiAgICogYGBganNcbiAgICogaW1wb3J0IHsgYWRkRGVjb2RlciwgZ2V0RGVjb2RlciB9IGZyb20gJ2dlb3RpZmYnO1xuICAgKiBhZGREZWNvZGVyKDUsICgpID0+IGltcG9ydCAoJy4vbXktY3VzdG9tLWx6dycpLnRoZW4oKG0pID0+IG0uZGVmYXVsdCkpO1xuICAgKiBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBhc3luYyAoZSkgPT4ge1xuICAgKiAgIGNvbnN0IHsgaWQsIGZpbGVEaXJlY3RvcnksIGJ1ZmZlciB9ID0gZS5kYXRhO1xuICAgKiAgIGNvbnN0IGRlY29kZXIgPSBhd2FpdCBnZXREZWNvZGVyKGZpbGVEaXJlY3RvcnkpO1xuICAgKiAgIGNvbnN0IGRlY29kZWQgPSBhd2FpdCBkZWNvZGVyLmRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpO1xuICAgKiAgIHNlbGYucG9zdE1lc3NhZ2UoeyBkZWNvZGVkLCBpZCB9LCBbZGVjb2RlZF0pO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIFRoZSB3YXkgdGhlIGFib3ZlIGNvZGUgaXMgYnVpbHQgaW50byBhIHdvcmtlciBieSB0aGUgYGNyZWF0ZVdvcmtlcigpYCBmdW5jdGlvblxuICAgKiBkZXBlbmRzIG9uIHRoZSB1c2VkIGJ1bmRsZXIuIEZvciBtb3N0IGJ1bmRsZXJzLCBzb21ldGhpbmcgbGlrZSB0aGlzIHdpbGwgd29yazpcbiAgICogYGBganNcbiAgICogZnVuY3Rpb24gY3JlYXRlV29ya2VyKCkge1xuICAgKiAgIHJldHVybiBuZXcgV29ya2VyKG5ldyBVUkwoJy4vbXktY3VzdG9tLXdvcmtlci5qcycsIGltcG9ydC5tZXRhLnVybCkpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2l6ZSA9IGRlZmF1bHRQb29sU2l6ZSwgY3JlYXRlV29ya2VyKSB7XG4gICAgdGhpcy53b3JrZXJzID0gbnVsbDtcbiAgICB0aGlzLl9hd2FpdGluZ0RlY29kZXIgPSBudWxsO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5tZXNzYWdlSWQgPSAwO1xuICAgIGlmIChzaXplKSB7XG4gICAgICB0aGlzLl9hd2FpdGluZ0RlY29kZXIgPSBjcmVhdGVXb3JrZXIgPyBQcm9taXNlLnJlc29sdmUoY3JlYXRlV29ya2VyKSA6IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGltcG9ydCgnLi93b3JrZXIvZGVjb2Rlci5qcycpLnRoZW4oKG1vZHVsZSkgPT4ge1xuICAgICAgICAgIHJlc29sdmUobW9kdWxlLmNyZWF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9hd2FpdGluZ0RlY29kZXIudGhlbigoY3JlYXRlKSA9PiB7XG4gICAgICAgIHRoaXMuX2F3YWl0aW5nRGVjb2RlciA9IG51bGw7XG4gICAgICAgIHRoaXMud29ya2VycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIHRoaXMud29ya2Vycy5wdXNoKHsgd29ya2VyOiBjcmVhdGUoKSwgaWRsZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSB0aGUgZ2l2ZW4gYmxvY2sgb2YgYnl0ZXMgd2l0aCB0aGUgc2V0IGNvbXByZXNzaW9uIG1ldGhvZC5cbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIHRoZSBhcnJheSBidWZmZXIgb2YgYnl0ZXMgdG8gZGVjb2RlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59IHRoZSBkZWNvZGVkIHJlc3VsdCBhcyBhIGBQcm9taXNlYFxuICAgKi9cbiAgYXN5bmMgZGVjb2RlKGZpbGVEaXJlY3RvcnksIGJ1ZmZlcikge1xuICAgIGlmICh0aGlzLl9hd2FpdGluZ0RlY29kZXIpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2F3YWl0aW5nRGVjb2RlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gMFxuICAgICAgPyBnZXREZWNvZGVyKGZpbGVEaXJlY3RvcnkpLnRoZW4oKGRlY29kZXIpID0+IGRlY29kZXIuZGVjb2RlKGZpbGVEaXJlY3RvcnksIGJ1ZmZlcikpXG4gICAgICA6IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IHRoaXMud29ya2Vycy5maW5kKChjYW5kaWRhdGUpID0+IGNhbmRpZGF0ZS5pZGxlKVxuICAgICAgICAgIHx8IHRoaXMud29ya2Vyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnNpemUpXTtcbiAgICAgICAgd29ya2VyLmlkbGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLm1lc3NhZ2VJZCsrO1xuICAgICAgICBjb25zdCBvbk1lc3NhZ2UgPSAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlLmRhdGEuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICB3b3JrZXIuaWRsZSA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKGUuZGF0YS5kZWNvZGVkKTtcbiAgICAgICAgICAgIHdvcmtlci53b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uTWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3b3JrZXIud29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuICAgICAgICB3b3JrZXIud29ya2VyLnBvc3RNZXNzYWdlKHsgZmlsZURpcmVjdG9yeSwgYnVmZmVyLCBpZCB9LCBbYnVmZmVyXSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMud29ya2Vycykge1xuICAgICAgdGhpcy53b3JrZXJzLmZvckVhY2goKHdvcmtlcikgPT4ge1xuICAgICAgICB3b3JrZXIud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLndvcmtlcnMgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQb29sO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/predictor.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/predictor.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyPredictor: () => (/* binding */ applyPredictor)\n/* harmony export */ });\nfunction decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nfunction applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9wcmVkaWN0b3IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGtCQUFrQjtBQUM1RTtBQUNBO0FBQ0EsTUFBTSw0QkFBNEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9wcmVkaWN0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZGVjb2RlUm93QWNjKHJvdywgc3RyaWRlKSB7XG4gIGxldCBsZW5ndGggPSByb3cubGVuZ3RoIC0gc3RyaWRlO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZG8ge1xuICAgIGZvciAobGV0IGkgPSBzdHJpZGU7IGkgPiAwOyBpLS0pIHtcbiAgICAgIHJvd1tvZmZzZXQgKyBzdHJpZGVdICs9IHJvd1tvZmZzZXRdO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuXG4gICAgbGVuZ3RoIC09IHN0cmlkZTtcbiAgfSB3aGlsZSAobGVuZ3RoID4gMCk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVJvd0Zsb2F0aW5nUG9pbnQocm93LCBzdHJpZGUsIGJ5dGVzUGVyU2FtcGxlKSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBjb3VudCA9IHJvdy5sZW5ndGg7XG4gIGNvbnN0IHdjID0gY291bnQgLyBieXRlc1BlclNhbXBsZTtcblxuICB3aGlsZSAoY291bnQgPiBzdHJpZGUpIHtcbiAgICBmb3IgKGxldCBpID0gc3RyaWRlOyBpID4gMDsgLS1pKSB7XG4gICAgICByb3dbaW5kZXggKyBzdHJpZGVdICs9IHJvd1tpbmRleF07XG4gICAgICArK2luZGV4O1xuICAgIH1cbiAgICBjb3VudCAtPSBzdHJpZGU7XG4gIH1cblxuICBjb25zdCBjb3B5ID0gcm93LnNsaWNlKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYnl0ZXNQZXJTYW1wbGU7ICsrYikge1xuICAgICAgcm93WyhieXRlc1BlclNhbXBsZSAqIGkpICsgYl0gPSBjb3B5WygoYnl0ZXNQZXJTYW1wbGUgLSBiIC0gMSkgKiB3YykgKyBpXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UHJlZGljdG9yKGJsb2NrLCBwcmVkaWN0b3IsIHdpZHRoLCBoZWlnaHQsIGJpdHNQZXJTYW1wbGUsXG4gIHBsYW5hckNvbmZpZ3VyYXRpb24pIHtcbiAgaWYgKCFwcmVkaWN0b3IgfHwgcHJlZGljdG9yID09PSAxKSB7XG4gICAgcmV0dXJuIGJsb2NrO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaXRzUGVyU2FtcGxlLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGJpdHNQZXJTYW1wbGVbaV0gJSA4ICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gZGVjb2Rpbmcgd2l0aCBwcmVkaWN0b3IsIG9ubHkgbXVsdGlwbGUgb2YgOCBiaXRzIGFyZSBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIGlmIChiaXRzUGVyU2FtcGxlW2ldICE9PSBiaXRzUGVyU2FtcGxlWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gZGVjb2Rpbmcgd2l0aCBwcmVkaWN0b3IsIGFsbCBzYW1wbGVzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaXplLicpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ5dGVzUGVyU2FtcGxlID0gYml0c1BlclNhbXBsZVswXSAvIDg7XG4gIGNvbnN0IHN0cmlkZSA9IHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDIgPyAxIDogYml0c1BlclNhbXBsZS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7ICsraSkge1xuICAgIC8vIExhc3Qgc3RyaXAgd2lsbCBiZSB0cnVuY2F0ZWQgaWYgaGVpZ2h0ICUgc3RyaXBIZWlnaHQgIT0gMFxuICAgIGlmIChpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSA+PSBibG9jay5ieXRlTGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IHJvdztcbiAgICBpZiAocHJlZGljdG9yID09PSAyKSB7IC8vIGhvcml6b250YWwgcHJlZGljdGlvblxuICAgICAgc3dpdGNoIChiaXRzUGVyU2FtcGxlWzBdKSB7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByb3cgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJvdyA9IG5ldyBVaW50MTZBcnJheShcbiAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSAvIDIsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICByb3cgPSBuZXcgVWludDMyQXJyYXkoXG4gICAgICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUgLyA0LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcmVkaWN0b3IgMiBub3QgYWxsb3dlZCB3aXRoICR7Yml0c1BlclNhbXBsZVswXX0gYml0cyBwZXIgc2FtcGxlLmApO1xuICAgICAgfVxuICAgICAgZGVjb2RlUm93QWNjKHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSk7XG4gICAgfSBlbHNlIGlmIChwcmVkaWN0b3IgPT09IDMpIHsgLy8gaG9yaXpvbnRhbCBmbG9hdGluZyBwb2ludFxuICAgICAgcm93ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSxcbiAgICAgICk7XG4gICAgICBkZWNvZGVSb3dGbG9hdGluZ1BvaW50KHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBibG9jaztcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/predictor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/resample.js":
/*!******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/resample.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resample: () => (/* binding */ resample),\n/* harmony export */   resampleBilinear: () => (/* binding */ resampleBilinear),\n/* harmony export */   resampleBilinearInterleaved: () => (/* binding */ resampleBilinearInterleaved),\n/* harmony export */   resampleInterleaved: () => (/* binding */ resampleInterleaved),\n/* harmony export */   resampleNearest: () => (/* binding */ resampleNearest),\n/* harmony export */   resampleNearestInterleaved: () => (/* binding */ resampleNearestInterleaved)\n/* harmony export */ });\n/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nfunction resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nfunction resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nfunction resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZXNhbXBsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsY0FBYztBQUMzQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsY0FBYztBQUMzQjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGNBQWM7QUFDM0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZXNhbXBsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgcmVzYW1wbGVcbiAqL1xuXG5mdW5jdGlvbiBjb3B5TmV3U2l6ZShhcnJheSwgd2lkdGgsIGhlaWdodCwgc2FtcGxlc1BlclBpeGVsID0gMSkge1xuICByZXR1cm4gbmV3IChPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXJyYXkpLmNvbnN0cnVjdG9yKSh3aWR0aCAqIGhlaWdodCAqIHNhbXBsZXNQZXJQaXhlbCk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIGlucHV0IGFycmF5cyB1c2luZyBuZWFyZXN0IG5laWdoYm9yIHZhbHVlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheVtdfSB2YWx1ZUFycmF5cyBUaGUgaW5wdXQgYXJyYXlzIHRvIHJlc2FtcGxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5XaWR0aCBUaGUgd2lkdGggb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbkhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0V2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0SGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEByZXR1cm5zIHtUeXBlZEFycmF5W119IFRoZSByZXNhbXBsZWQgcmFzdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGVOZWFyZXN0KHZhbHVlQXJyYXlzLCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCkge1xuICBjb25zdCByZWxYID0gaW5XaWR0aCAvIG91dFdpZHRoO1xuICBjb25zdCByZWxZID0gaW5IZWlnaHQgLyBvdXRIZWlnaHQ7XG4gIHJldHVybiB2YWx1ZUFycmF5cy5tYXAoKGFycmF5KSA9PiB7XG4gICAgY29uc3QgbmV3QXJyYXkgPSBjb3B5TmV3U2l6ZShhcnJheSwgb3V0V2lkdGgsIG91dEhlaWdodCk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRIZWlnaHQ7ICsreSkge1xuICAgICAgY29uc3QgY3kgPSBNYXRoLm1pbihNYXRoLnJvdW5kKHJlbFkgKiB5KSwgaW5IZWlnaHQgLSAxKTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgICBjb25zdCBjeCA9IE1hdGgubWluKE1hdGgucm91bmQocmVsWCAqIHgpLCBpbldpZHRoIC0gMSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbKGN5ICogaW5XaWR0aCkgKyBjeF07XG4gICAgICAgIG5ld0FycmF5Wyh5ICogb3V0V2lkdGgpICsgeF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9KTtcbn1cblxuLy8gc2ltcGxlIGxpbmVhciBpbnRlcnBvbGF0aW9uLCBjb2RlIGZyb206XG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfaW50ZXJwb2xhdGlvbiNQcm9ncmFtbWluZ19sYW5ndWFnZV9zdXBwb3J0XG5mdW5jdGlvbiBsZXJwKHYwLCB2MSwgdCkge1xuICByZXR1cm4gKCgxIC0gdCkgKiB2MCkgKyAodCAqIHYxKTtcbn1cblxuLyoqXG4gKiBSZXNhbXBsZSB0aGUgaW5wdXQgYXJyYXlzIHVzaW5nIGJpbGluZWFyIGludGVycG9sYXRpb24uXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlbXX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcmV0dXJucyB7VHlwZWRBcnJheVtdfSBUaGUgcmVzYW1wbGVkIHJhc3RlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2FtcGxlQmlsaW5lYXIodmFsdWVBcnJheXMsIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0KSB7XG4gIGNvbnN0IHJlbFggPSBpbldpZHRoIC8gb3V0V2lkdGg7XG4gIGNvbnN0IHJlbFkgPSBpbkhlaWdodCAvIG91dEhlaWdodDtcblxuICByZXR1cm4gdmFsdWVBcnJheXMubWFwKChhcnJheSkgPT4ge1xuICAgIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUoYXJyYXksIG91dFdpZHRoLCBvdXRIZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICAgIGNvbnN0IHJhd1kgPSByZWxZICogeTtcblxuICAgICAgY29uc3QgeWwgPSBNYXRoLmZsb29yKHJhd1kpO1xuICAgICAgY29uc3QgeWggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WSksIChpbkhlaWdodCAtIDEpKTtcblxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBvdXRXaWR0aDsgKyt4KSB7XG4gICAgICAgIGNvbnN0IHJhd1ggPSByZWxYICogeDtcbiAgICAgICAgY29uc3QgdHggPSByYXdYICUgMTtcblxuICAgICAgICBjb25zdCB4bCA9IE1hdGguZmxvb3IocmF3WCk7XG4gICAgICAgIGNvbnN0IHhoID0gTWF0aC5taW4oTWF0aC5jZWlsKHJhd1gpLCAoaW5XaWR0aCAtIDEpKTtcblxuICAgICAgICBjb25zdCBsbCA9IGFycmF5Wyh5bCAqIGluV2lkdGgpICsgeGxdO1xuICAgICAgICBjb25zdCBobCA9IGFycmF5Wyh5bCAqIGluV2lkdGgpICsgeGhdO1xuICAgICAgICBjb25zdCBsaCA9IGFycmF5Wyh5aCAqIGluV2lkdGgpICsgeGxdO1xuICAgICAgICBjb25zdCBoaCA9IGFycmF5Wyh5aCAqIGluV2lkdGgpICsgeGhdO1xuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGVycChcbiAgICAgICAgICBsZXJwKGxsLCBobCwgdHgpLFxuICAgICAgICAgIGxlcnAobGgsIGhoLCB0eCksXG4gICAgICAgICAgcmF3WSAlIDEsXG4gICAgICAgICk7XG4gICAgICAgIG5ld0FycmF5Wyh5ICogb3V0V2lkdGgpICsgeF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXNhbXBsZSB0aGUgaW5wdXQgYXJyYXlzIHVzaW5nIHRoZSBzZWxlY3RlZCByZXNhbXBsaW5nIG1ldGhvZC5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheVtdfSB2YWx1ZUFycmF5cyBUaGUgaW5wdXQgYXJyYXlzIHRvIHJlc2FtcGxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5XaWR0aCBUaGUgd2lkdGggb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbkhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0V2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0SGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kID0gJ25lYXJlc3QnXSBUaGUgZGVzaXJlZCByZXNhbXBsaW5nIG1ldGhvZFxuICogQHJldHVybnMge1R5cGVkQXJyYXlbXX0gVGhlIHJlc2FtcGxlZCByYXN0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNhbXBsZSh2YWx1ZUFycmF5cywgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIG1ldGhvZCA9ICduZWFyZXN0Jykge1xuICBzd2l0Y2ggKG1ldGhvZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnbmVhcmVzdCc6XG4gICAgICByZXR1cm4gcmVzYW1wbGVOZWFyZXN0KHZhbHVlQXJyYXlzLCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCk7XG4gICAgY2FzZSAnYmlsaW5lYXInOlxuICAgIGNhc2UgJ2xpbmVhcic6XG4gICAgICByZXR1cm4gcmVzYW1wbGVCaWxpbmVhcih2YWx1ZUFycmF5cywgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHJlc2FtcGxpbmcgbWV0aG9kOiAnJHttZXRob2R9J2ApO1xuICB9XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIHBpeGVsIGludGVybGVhdmVkIGlucHV0IGFycmF5IHVzaW5nIG5lYXJlc3QgbmVpZ2hib3IgdmFsdWUgc2VsZWN0aW9uLlxuICogQHBhcmFtIHtUeXBlZEFycmF5fSB2YWx1ZUFycmF5cyBUaGUgaW5wdXQgYXJyYXlzIHRvIHJlc2FtcGxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5XaWR0aCBUaGUgd2lkdGggb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbkhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0V2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0SGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVzIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwgZm9yIHBpeGVsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmxlYXZlZCBkYXRhXG4gKiBAcmV0dXJucyB7VHlwZWRBcnJheX0gVGhlIHJlc2FtcGxlZCByYXN0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2FtcGxlTmVhcmVzdEludGVybGVhdmVkKFxuICB2YWx1ZUFycmF5LCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcykge1xuICBjb25zdCByZWxYID0gaW5XaWR0aCAvIG91dFdpZHRoO1xuICBjb25zdCByZWxZID0gaW5IZWlnaHQgLyBvdXRIZWlnaHQ7XG5cbiAgY29uc3QgbmV3QXJyYXkgPSBjb3B5TmV3U2l6ZSh2YWx1ZUFycmF5LCBvdXRXaWR0aCwgb3V0SGVpZ2h0LCBzYW1wbGVzKTtcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRIZWlnaHQ7ICsreSkge1xuICAgIGNvbnN0IGN5ID0gTWF0aC5taW4oTWF0aC5yb3VuZChyZWxZICogeSksIGluSGVpZ2h0IC0gMSk7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBvdXRXaWR0aDsgKyt4KSB7XG4gICAgICBjb25zdCBjeCA9IE1hdGgubWluKE1hdGgucm91bmQocmVsWCAqIHgpLCBpbldpZHRoIC0gMSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXM7ICsraSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlQXJyYXlbKGN5ICogaW5XaWR0aCAqIHNhbXBsZXMpICsgKGN4ICogc2FtcGxlcykgKyBpXTtcbiAgICAgICAgbmV3QXJyYXlbKHkgKiBvdXRXaWR0aCAqIHNhbXBsZXMpICsgKHggKiBzYW1wbGVzKSArIGldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdBcnJheTtcbn1cblxuLyoqXG4gKiBSZXNhbXBsZSB0aGUgcGl4ZWwgaW50ZXJsZWF2ZWQgaW5wdXQgYXJyYXkgdXNpbmcgYmlsaW5lYXIgaW50ZXJwb2xhdGlvbi5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlcyBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsIGZvciBwaXhlbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJsZWF2ZWQgZGF0YVxuICogQHJldHVybnMge1R5cGVkQXJyYXl9IFRoZSByZXNhbXBsZWQgcmFzdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNhbXBsZUJpbGluZWFySW50ZXJsZWF2ZWQoXG4gIHZhbHVlQXJyYXksIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0LCBzYW1wbGVzKSB7XG4gIGNvbnN0IHJlbFggPSBpbldpZHRoIC8gb3V0V2lkdGg7XG4gIGNvbnN0IHJlbFkgPSBpbkhlaWdodCAvIG91dEhlaWdodDtcbiAgY29uc3QgbmV3QXJyYXkgPSBjb3B5TmV3U2l6ZSh2YWx1ZUFycmF5LCBvdXRXaWR0aCwgb3V0SGVpZ2h0LCBzYW1wbGVzKTtcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRIZWlnaHQ7ICsreSkge1xuICAgIGNvbnN0IHJhd1kgPSByZWxZICogeTtcblxuICAgIGNvbnN0IHlsID0gTWF0aC5mbG9vcihyYXdZKTtcbiAgICBjb25zdCB5aCA9IE1hdGgubWluKE1hdGguY2VpbChyYXdZKSwgKGluSGVpZ2h0IC0gMSkpO1xuXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBvdXRXaWR0aDsgKyt4KSB7XG4gICAgICBjb25zdCByYXdYID0gcmVsWCAqIHg7XG4gICAgICBjb25zdCB0eCA9IHJhd1ggJSAxO1xuXG4gICAgICBjb25zdCB4bCA9IE1hdGguZmxvb3IocmF3WCk7XG4gICAgICBjb25zdCB4aCA9IE1hdGgubWluKE1hdGguY2VpbChyYXdYKSwgKGluV2lkdGggLSAxKSk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlczsgKytpKSB7XG4gICAgICAgIGNvbnN0IGxsID0gdmFsdWVBcnJheVsoeWwgKiBpbldpZHRoICogc2FtcGxlcykgKyAoeGwgKiBzYW1wbGVzKSArIGldO1xuICAgICAgICBjb25zdCBobCA9IHZhbHVlQXJyYXlbKHlsICogaW5XaWR0aCAqIHNhbXBsZXMpICsgKHhoICogc2FtcGxlcykgKyBpXTtcbiAgICAgICAgY29uc3QgbGggPSB2YWx1ZUFycmF5Wyh5aCAqIGluV2lkdGggKiBzYW1wbGVzKSArICh4bCAqIHNhbXBsZXMpICsgaV07XG4gICAgICAgIGNvbnN0IGhoID0gdmFsdWVBcnJheVsoeWggKiBpbldpZHRoICogc2FtcGxlcykgKyAoeGggKiBzYW1wbGVzKSArIGldO1xuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGVycChcbiAgICAgICAgICBsZXJwKGxsLCBobCwgdHgpLFxuICAgICAgICAgIGxlcnAobGgsIGhoLCB0eCksXG4gICAgICAgICAgcmF3WSAlIDEsXG4gICAgICAgICk7XG4gICAgICAgIG5ld0FycmF5Wyh5ICogb3V0V2lkdGggKiBzYW1wbGVzKSArICh4ICogc2FtcGxlcykgKyBpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIHBpeGVsIGludGVybGVhdmVkIGlucHV0IGFycmF5IHVzaW5nIHRoZSBzZWxlY3RlZCByZXNhbXBsaW5nIG1ldGhvZC5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheX0gdmFsdWVBcnJheSBUaGUgaW5wdXQgYXJyYXkgdG8gcmVzYW1wbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGluSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRXaWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRIZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZXMgVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbCBmb3IgcGl4ZWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJsZWF2ZWQgZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IFttZXRob2QgPSAnbmVhcmVzdCddIFRoZSBkZXNpcmVkIHJlc2FtcGxpbmcgbWV0aG9kXG4gKiBAcmV0dXJucyB7VHlwZWRBcnJheX0gVGhlIHJlc2FtcGxlZCByYXN0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNhbXBsZUludGVybGVhdmVkKHZhbHVlQXJyYXksIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0LCBzYW1wbGVzLCBtZXRob2QgPSAnbmVhcmVzdCcpIHtcbiAgc3dpdGNoIChtZXRob2QudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ25lYXJlc3QnOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlTmVhcmVzdEludGVybGVhdmVkKFxuICAgICAgICB2YWx1ZUFycmF5LCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcyxcbiAgICAgICk7XG4gICAgY2FzZSAnYmlsaW5lYXInOlxuICAgIGNhc2UgJ2xpbmVhcic6XG4gICAgICByZXR1cm4gcmVzYW1wbGVCaWxpbmVhckludGVybGVhdmVkKFxuICAgICAgICB2YWx1ZUFycmF5LCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcyxcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcmVzYW1wbGluZyBtZXRob2Q6ICcke21ldGhvZH0nYCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/resample.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/rgb.js":
/*!*************************************************!*\
  !*** ./node_modules/geotiff/dist-module/rgb.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromBlackIsZero: () => (/* binding */ fromBlackIsZero),\n/* harmony export */   fromCIELab: () => (/* binding */ fromCIELab),\n/* harmony export */   fromCMYK: () => (/* binding */ fromCMYK),\n/* harmony export */   fromPalette: () => (/* binding */ fromPalette),\n/* harmony export */   fromWhiteIsZero: () => (/* binding */ fromWhiteIsZero),\n/* harmony export */   fromYCbCr: () => (/* binding */ fromYCbCr)\n/* harmony export */ });\nfunction fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nfunction fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nfunction fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nfunction fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nfunction fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nfunction fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZ2IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQU87QUFDUCxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUCxVQUFVLGdCQUFnQjtBQUMxQjs7QUFFQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0EsZ0RBQWdEO0FBQ2hELGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZ2IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGZyb21XaGl0ZUlzWmVybyhyYXN0ZXIsIG1heCkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJhc3RlcjtcbiAgY29uc3QgcmdiUmFzdGVyID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcbiAgbGV0IHZhbHVlO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCByYXN0ZXIubGVuZ3RoOyArK2ksIGogKz0gMykge1xuICAgIHZhbHVlID0gMjU2IC0gKHJhc3RlcltpXSAvIG1heCAqIDI1Nik7XG4gICAgcmdiUmFzdGVyW2pdID0gdmFsdWU7XG4gICAgcmdiUmFzdGVyW2ogKyAxXSA9IHZhbHVlO1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmdiUmFzdGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJsYWNrSXNaZXJvKHJhc3RlciwgbWF4KSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmFzdGVyO1xuICBjb25zdCByZ2JSYXN0ZXIgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpO1xuICBsZXQgdmFsdWU7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHJhc3Rlci5sZW5ndGg7ICsraSwgaiArPSAzKSB7XG4gICAgdmFsdWUgPSByYXN0ZXJbaV0gLyBtYXggKiAyNTY7XG4gICAgcmdiUmFzdGVyW2pdID0gdmFsdWU7XG4gICAgcmdiUmFzdGVyW2ogKyAxXSA9IHZhbHVlO1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmdiUmFzdGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVBhbGV0dGUocmFzdGVyLCBjb2xvck1hcCkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJhc3RlcjtcbiAgY29uc3QgcmdiUmFzdGVyID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcbiAgY29uc3QgZ3JlZW5PZmZzZXQgPSBjb2xvck1hcC5sZW5ndGggLyAzO1xuICBjb25zdCBibHVlT2Zmc2V0ID0gY29sb3JNYXAubGVuZ3RoIC8gMyAqIDI7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHJhc3Rlci5sZW5ndGg7ICsraSwgaiArPSAzKSB7XG4gICAgY29uc3QgbWFwSW5kZXggPSByYXN0ZXJbaV07XG4gICAgcmdiUmFzdGVyW2pdID0gY29sb3JNYXBbbWFwSW5kZXhdIC8gNjU1MzYgKiAyNTY7XG4gICAgcmdiUmFzdGVyW2ogKyAxXSA9IGNvbG9yTWFwW21hcEluZGV4ICsgZ3JlZW5PZmZzZXRdIC8gNjU1MzYgKiAyNTY7XG4gICAgcmdiUmFzdGVyW2ogKyAyXSA9IGNvbG9yTWFwW21hcEluZGV4ICsgYmx1ZU9mZnNldF0gLyA2NTUzNiAqIDI1NjtcbiAgfVxuICByZXR1cm4gcmdiUmFzdGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUNNWUsoY215a1Jhc3Rlcikge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNteWtSYXN0ZXI7XG4gIGNvbnN0IHJnYlJhc3RlciA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogMyk7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGNteWtSYXN0ZXIubGVuZ3RoOyBpICs9IDQsIGogKz0gMykge1xuICAgIGNvbnN0IGMgPSBjbXlrUmFzdGVyW2ldO1xuICAgIGNvbnN0IG0gPSBjbXlrUmFzdGVyW2kgKyAxXTtcbiAgICBjb25zdCB5ID0gY215a1Jhc3RlcltpICsgMl07XG4gICAgY29uc3QgayA9IGNteWtSYXN0ZXJbaSArIDNdO1xuXG4gICAgcmdiUmFzdGVyW2pdID0gMjU1ICogKCgyNTUgLSBjKSAvIDI1NikgKiAoKDI1NSAtIGspIC8gMjU2KTtcbiAgICByZ2JSYXN0ZXJbaiArIDFdID0gMjU1ICogKCgyNTUgLSBtKSAvIDI1NikgKiAoKDI1NSAtIGspIC8gMjU2KTtcbiAgICByZ2JSYXN0ZXJbaiArIDJdID0gMjU1ICogKCgyNTUgLSB5KSAvIDI1NikgKiAoKDI1NSAtIGspIC8gMjU2KTtcbiAgfVxuICByZXR1cm4gcmdiUmFzdGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVlDYkNyKHlDYkNyUmFzdGVyKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0geUNiQ3JSYXN0ZXI7XG4gIGNvbnN0IHJnYlJhc3RlciA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB5Q2JDclJhc3Rlci5sZW5ndGg7IGkgKz0gMywgaiArPSAzKSB7XG4gICAgY29uc3QgeSA9IHlDYkNyUmFzdGVyW2ldO1xuICAgIGNvbnN0IGNiID0geUNiQ3JSYXN0ZXJbaSArIDFdO1xuICAgIGNvbnN0IGNyID0geUNiQ3JSYXN0ZXJbaSArIDJdO1xuXG4gICAgcmdiUmFzdGVyW2pdID0gKHkgKyAoMS40MDIwMCAqIChjciAtIDB4ODApKSk7XG4gICAgcmdiUmFzdGVyW2ogKyAxXSA9ICh5IC0gKDAuMzQ0MTQgKiAoY2IgLSAweDgwKSkgLSAoMC43MTQxNCAqIChjciAtIDB4ODApKSk7XG4gICAgcmdiUmFzdGVyW2ogKyAyXSA9ICh5ICsgKDEuNzcyMDAgKiAoY2IgLSAweDgwKSkpO1xuICB9XG4gIHJldHVybiByZ2JSYXN0ZXI7XG59XG5cbmNvbnN0IFhuID0gMC45NTA0NztcbmNvbnN0IFluID0gMS4wMDAwMDtcbmNvbnN0IFpuID0gMS4wODg4MztcblxuLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYW50aW1hdHRlcjE1L3JnYi1sYWIvYmxvYi9tYXN0ZXIvY29sb3IuanNcblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21DSUVMYWIoY2llTGFiUmFzdGVyKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2llTGFiUmFzdGVyO1xuICBjb25zdCByZ2JSYXN0ZXIgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpO1xuXG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGNpZUxhYlJhc3Rlci5sZW5ndGg7IGkgKz0gMywgaiArPSAzKSB7XG4gICAgY29uc3QgTCA9IGNpZUxhYlJhc3RlcltpICsgMF07XG4gICAgY29uc3QgYV8gPSBjaWVMYWJSYXN0ZXJbaSArIDFdIDw8IDI0ID4+IDI0OyAvLyBjb252ZXJzaW9uIGZyb20gdWludDggdG8gaW50OFxuICAgIGNvbnN0IGJfID0gY2llTGFiUmFzdGVyW2kgKyAyXSA8PCAyNCA+PiAyNDsgLy8gc2FtZVxuXG4gICAgbGV0IHkgPSAoTCArIDE2KSAvIDExNjtcbiAgICBsZXQgeCA9IChhXyAvIDUwMCkgKyB5O1xuICAgIGxldCB6ID0geSAtIChiXyAvIDIwMCk7XG4gICAgbGV0IHI7XG4gICAgbGV0IGc7XG4gICAgbGV0IGI7XG5cbiAgICB4ID0gWG4gKiAoKHggKiB4ICogeCA+IDAuMDA4ODU2KSA/IHggKiB4ICogeCA6ICh4IC0gKDE2IC8gMTE2KSkgLyA3Ljc4Nyk7XG4gICAgeSA9IFluICogKCh5ICogeSAqIHkgPiAwLjAwODg1NikgPyB5ICogeSAqIHkgOiAoeSAtICgxNiAvIDExNikpIC8gNy43ODcpO1xuICAgIHogPSBabiAqICgoeiAqIHogKiB6ID4gMC4wMDg4NTYpID8geiAqIHogKiB6IDogKHogLSAoMTYgLyAxMTYpKSAvIDcuNzg3KTtcblxuICAgIHIgPSAoeCAqIDMuMjQwNikgKyAoeSAqIC0xLjUzNzIpICsgKHogKiAtMC40OTg2KTtcbiAgICBnID0gKHggKiAtMC45Njg5KSArICh5ICogMS44NzU4KSArICh6ICogMC4wNDE1KTtcbiAgICBiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuICAgIHIgPSAociA+IDAuMDAzMTMwOCkgPyAoKDEuMDU1ICogKHIgKiogKDEgLyAyLjQpKSkgLSAwLjA1NSkgOiAxMi45MiAqIHI7XG4gICAgZyA9IChnID4gMC4wMDMxMzA4KSA/ICgoMS4wNTUgKiAoZyAqKiAoMSAvIDIuNCkpKSAtIDAuMDU1KSA6IDEyLjkyICogZztcbiAgICBiID0gKGIgPiAwLjAwMzEzMDgpID8gKCgxLjA1NSAqIChiICoqICgxIC8gMi40KSkpIC0gMC4wNTUpIDogMTIuOTIgKiBiO1xuXG4gICAgcmdiUmFzdGVyW2pdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgcikpICogMjU1O1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBnKSkgKiAyNTU7XG4gICAgcmdiUmFzdGVyW2ogKyAyXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGIpKSAqIDI1NTtcbiAgfVxuICByZXR1cm4gcmdiUmFzdGVyO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/rgb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/arraybuffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/arraybuffer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeBufferSource: () => (/* binding */ makeBufferSource)\n/* harmony export */ });\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/geotiff/dist-module/utils.js\");\n\n\n\nclass ArrayBufferSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  constructor(arrayBuffer) {\n    super();\n    this.arrayBuffer = arrayBuffer;\n  }\n\n  fetchSlice(slice, signal) {\n    if (signal && signal.aborted) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AbortError('Request aborted');\n    }\n    return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);\n  }\n}\n\nfunction makeBufferSource(arrayBuffer) {\n  return new ArrayBufferSource(arrayBuffer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYXJyYXlidWZmZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZDO0FBQ0o7O0FBRXpDLGdDQUFnQyxzREFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYXJyYXlidWZmZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZVNvdXJjZSB9IGZyb20gJy4vYmFzZXNvdXJjZS5qcyc7XG5pbXBvcnQgeyBBYm9ydEVycm9yIH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuXG5jbGFzcyBBcnJheUJ1ZmZlclNvdXJjZSBleHRlbmRzIEJhc2VTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihhcnJheUJ1ZmZlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hcnJheUJ1ZmZlciA9IGFycmF5QnVmZmVyO1xuICB9XG5cbiAgZmV0Y2hTbGljZShzbGljZSwgc2lnbmFsKSB7XG4gICAgaWYgKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hcnJheUJ1ZmZlci5zbGljZShzbGljZS5vZmZzZXQsIHNsaWNlLm9mZnNldCArIHNsaWNlLmxlbmd0aCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VCdWZmZXJTb3VyY2UoYXJyYXlCdWZmZXIpIHtcbiAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlclNvdXJjZShhcnJheUJ1ZmZlcik7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/arraybuffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/basesource.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/basesource.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseSource: () => (/* binding */ BaseSource)\n/* harmony export */ });\n/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nclass BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYmFzZXNvdXJjZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7O0FBRU87QUFDUDtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYmFzZXNvdXJjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIFNsaWNlXG4gKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0XG4gKiBAcHJvcGVydHkge251bWJlcn0gbGVuZ3RoXG4gKi9cblxuZXhwb3J0IGNsYXNzIEJhc2VTb3VyY2Uge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtTbGljZVtdfSBzbGljZXNcbiAgICogQHJldHVybnMge0FycmF5QnVmZmVyW119XG4gICAqL1xuICBhc3luYyBmZXRjaChzbGljZXMsIHNpZ25hbCA9IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIHNsaWNlcy5tYXAoKHNsaWNlKSA9PiB0aGlzLmZldGNoU2xpY2Uoc2xpY2UsIHNpZ25hbCkpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtTbGljZX0gc2xpY2VcbiAgICogQHJldHVybnMge0FycmF5QnVmZmVyfVxuICAgKi9cbiAgYXN5bmMgZmV0Y2hTbGljZShzbGljZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgZmV0Y2hpbmcgb2Ygc2xpY2UgJHtzbGljZX0gbm90IHBvc3NpYmxlLCBub3QgaW1wbGVtZW50ZWRgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaWxlc2l6ZSBpZiBhbHJlYWR5IGRldGVybWluZWQgYW5kIG51bGwgb3RoZXJ3aXNlXG4gICAqL1xuICBnZXQgZmlsZVNpemUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBhc3luYyBjbG9zZSgpIHtcbiAgICAvLyBuby1vcCBieSBkZWZhdWx0XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/basesource.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/blockedsource.js":
/*!******************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/blockedsource.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockedSource: () => (/* binding */ BlockedSource)\n/* harmony export */ });\n/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! quick-lru */ \"(ssr)/./node_modules/quick-lru/index.js\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/geotiff/dist-module/utils.js\");\n\n\n\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nclass BlockedSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new quick_lru__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wait)();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_2__.AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_2__.AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.zip)(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYmxvY2tlZHNvdXJjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlDO0FBQ1k7QUFDdUI7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLDRCQUE0QixzREFBVTtBQUM3QztBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esd0JBQXdCLHFDQUFxQyxJQUFJO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsaURBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUwsZUFBZSxvQkFBb0I7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGdDQUFnQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQzs7QUFFQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLCtDQUFJO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFVO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBYztBQUM5Qjs7QUFFQTtBQUNBLG1DQUFtQyw4Q0FBRzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQiw0QkFBNEI7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyx3QkFBd0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL2Jsb2NrZWRzb3VyY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFF1aWNrTFJVIGZyb20gJ3F1aWNrLWxydSc7XG5pbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcbmltcG9ydCB7IEFib3J0RXJyb3IsIEFnZ3JlZ2F0ZUVycm9yLCB3YWl0LCB6aXAgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cbmNsYXNzIEJsb2NrIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBbZGF0YV1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9mZnNldCwgbGVuZ3RoLCBkYXRhID0gbnVsbCkge1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge251bWJlcn0gdGhlIHRvcCBieXRlIGJvcmRlclxuICAgKi9cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQgKyB0aGlzLmxlbmd0aDtcbiAgfVxufVxuXG5jbGFzcyBCbG9ja0dyb3VwIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKiBAcGFyYW0ge251bWJlcltdfSBibG9ja0lkc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob2Zmc2V0LCBsZW5ndGgsIGJsb2NrSWRzKSB7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5ibG9ja0lkcyA9IGJsb2NrSWRzO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCbG9ja2VkU291cmNlIGV4dGVuZHMgQmFzZVNvdXJjZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0Jhc2VTb3VyY2V9IHNvdXJjZSBUaGUgdW5kZXJseWluZyBzb3VyY2UgdGhhdCBzaGFsbCBiZSBibG9ja2VkIGFuZCBjYWNoZWRcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJsb2NrU2l6ZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNhY2hlU2l6ZV1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgeyBibG9ja1NpemUgPSA2NTUzNiwgY2FjaGVTaXplID0gMTAwIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5ibG9ja1NpemUgPSBibG9ja1NpemU7XG5cbiAgICB0aGlzLmJsb2NrQ2FjaGUgPSBuZXcgUXVpY2tMUlUoe1xuICAgICAgbWF4U2l6ZTogY2FjaGVTaXplLFxuICAgICAgb25FdmljdGlvbjogKGJsb2NrSWQsIGJsb2NrKSA9PiB7XG4gICAgICAgIHRoaXMuZXZpY3RlZEJsb2Nrcy5zZXQoYmxvY2tJZCwgYmxvY2spO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8qKiBAdHlwZSB7TWFwPG51bWJlciwgQmxvY2s+fSAqL1xuICAgIHRoaXMuZXZpY3RlZEJsb2NrcyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIG1hcHBpbmcgYmxvY2tJZCAtPiBCbG9jayBpbnN0YW5jZVxuICAgIHRoaXMuYmxvY2tSZXF1ZXN0cyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIHNldCBvZiBibG9ja0lkcyBtaXNzaW5nIGZvciB0aGUgY3VycmVudCByZXF1ZXN0c1xuICAgIHRoaXMuYmxvY2tJZHNUb0ZldGNoID0gbmV3IFNldCgpO1xuXG4gICAgdGhpcy5hYm9ydGVkQmxvY2tJZHMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICBnZXQgZmlsZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLmZpbGVTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9iYXNlc291cmNlXCIpLlNsaWNlW119IHNsaWNlc1xuICAgKi9cbiAgYXN5bmMgZmV0Y2goc2xpY2VzLCBzaWduYWwpIHtcbiAgICBjb25zdCBibG9ja1JlcXVlc3RzID0gW107XG4gICAgY29uc3QgbWlzc2luZ0Jsb2NrSWRzID0gW107XG4gICAgY29uc3QgYWxsQmxvY2tJZHMgPSBbXTtcbiAgICB0aGlzLmV2aWN0ZWRCbG9ja3MuY2xlYXIoKTtcblxuICAgIGZvciAoY29uc3QgeyBvZmZzZXQsIGxlbmd0aCB9IG9mIHNsaWNlcykge1xuICAgICAgbGV0IHRvcCA9IG9mZnNldCArIGxlbmd0aDtcblxuICAgICAgY29uc3QgeyBmaWxlU2l6ZSB9ID0gdGhpcztcbiAgICAgIGlmIChmaWxlU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICB0b3AgPSBNYXRoLm1pbih0b3AsIGZpbGVTaXplKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlyc3RCbG9ja09mZnNldCA9IE1hdGguZmxvb3Iob2Zmc2V0IC8gdGhpcy5ibG9ja1NpemUpICogdGhpcy5ibG9ja1NpemU7XG5cbiAgICAgIGZvciAobGV0IGN1cnJlbnQgPSBmaXJzdEJsb2NrT2Zmc2V0OyBjdXJyZW50IDwgdG9wOyBjdXJyZW50ICs9IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrSWQgPSBNYXRoLmZsb29yKGN1cnJlbnQgLyB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICAgIGlmICghdGhpcy5ibG9ja0NhY2hlLmhhcyhibG9ja0lkKSAmJiAhdGhpcy5ibG9ja1JlcXVlc3RzLmhhcyhibG9ja0lkKSkge1xuICAgICAgICAgIHRoaXMuYmxvY2tJZHNUb0ZldGNoLmFkZChibG9ja0lkKTtcbiAgICAgICAgICBtaXNzaW5nQmxvY2tJZHMucHVzaChibG9ja0lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ibG9ja1JlcXVlc3RzLmhhcyhibG9ja0lkKSkge1xuICAgICAgICAgIGJsb2NrUmVxdWVzdHMucHVzaCh0aGlzLmJsb2NrUmVxdWVzdHMuZ2V0KGJsb2NrSWQpKTtcbiAgICAgICAgfVxuICAgICAgICBhbGxCbG9ja0lkcy5wdXNoKGJsb2NrSWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFsbG93IGFkZGl0aW9uYWwgYmxvY2sgcmVxdWVzdHMgdG8gYWNjdW11bGF0ZVxuICAgIGF3YWl0IHdhaXQoKTtcbiAgICB0aGlzLmZldGNoQmxvY2tzKHNpZ25hbCk7XG5cbiAgICAvLyBHYXRoZXIgYWxsIG9mIHRoZSBuZXcgcmVxdWVzdHMgdGhhdCB0aGlzIGZldGNoIGNhbGwgaXMgY29udHJpYnV0aW5nIHRvIGBmZXRjaGAuXG4gICAgY29uc3QgbWlzc2luZ1JlcXVlc3RzID0gW107XG4gICAgZm9yIChjb25zdCBibG9ja0lkIG9mIG1pc3NpbmdCbG9ja0lkcykge1xuICAgICAgLy8gVGhlIHJlcXVlc3RlZCBtaXNzaW5nIGJsb2NrIGNvdWxkIGFscmVhZHkgYmUgaW4gdGhlIGNhY2hlXG4gICAgICAvLyBpbnN0ZWFkIG9mIGhhdmluZyBpdHMgcmVxdWVzdCBzdGlsbCBiZSBvdXRzdGFuZGluZy5cbiAgICAgIGlmICh0aGlzLmJsb2NrUmVxdWVzdHMuaGFzKGJsb2NrSWQpKSB7XG4gICAgICAgIG1pc3NpbmdSZXF1ZXN0cy5wdXNoKHRoaXMuYmxvY2tSZXF1ZXN0cy5nZXQoYmxvY2tJZCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFjdHVhbGx5IGF3YWl0IGFsbCBwZW5kaW5nIHJlcXVlc3RzIHRoYXQgYXJlIG5lZWRlZCBmb3IgdGhpcyBgZmV0Y2hgLlxuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChibG9ja1JlcXVlc3RzKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQobWlzc2luZ1JlcXVlc3RzKTtcblxuICAgIC8vIFBlcmZvcm0gcmV0cmllcyBpZiBhIGJsb2NrIHdhcyBpbnRlcnJ1cHRlZCBieSBhIHByZXZpb3VzIHNpZ25hbFxuICAgIGNvbnN0IGFib3J0ZWRCbG9ja1JlcXVlc3RzID0gW107XG4gICAgY29uc3QgYWJvcnRlZEJsb2NrSWRzID0gYWxsQmxvY2tJZHNcbiAgICAgIC5maWx0ZXIoKGlkKSA9PiB0aGlzLmFib3J0ZWRCbG9ja0lkcy5oYXMoaWQpIHx8ICF0aGlzLmJsb2NrQ2FjaGUuaGFzKGlkKSk7XG4gICAgYWJvcnRlZEJsb2NrSWRzLmZvckVhY2goKGlkKSA9PiB0aGlzLmJsb2NrSWRzVG9GZXRjaC5hZGQoaWQpKTtcbiAgICAvLyBzdGFydCB0aGUgcmV0cnkgb2Ygc29tZSBibG9ja3MgaWYgcmVxdWlyZWRcbiAgICBpZiAoYWJvcnRlZEJsb2NrSWRzLmxlbmd0aCA+IDAgJiYgc2lnbmFsICYmICFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgdGhpcy5mZXRjaEJsb2NrcyhudWxsKTtcbiAgICAgIGZvciAoY29uc3QgYmxvY2tJZCBvZiBhYm9ydGVkQmxvY2tJZHMpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLmJsb2NrUmVxdWVzdHMuZ2V0KGJsb2NrSWQpO1xuICAgICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9jayAke2Jsb2NrSWR9IGlzIG5vdCBpbiB0aGUgYmxvY2sgcmVxdWVzdHNgKTtcbiAgICAgICAgfVxuICAgICAgICBhYm9ydGVkQmxvY2tSZXF1ZXN0cy5wdXNoKGJsb2NrKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChhYm9ydGVkQmxvY2tSZXF1ZXN0cyk7XG4gICAgfVxuXG4gICAgLy8gdGhyb3cgYW4gIGFib3J0IGVycm9yXG4gICAgaWYgKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IoJ1JlcXVlc3Qgd2FzIGFib3J0ZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBibG9ja3MgPSBhbGxCbG9ja0lkcy5tYXAoKGlkKSA9PiB0aGlzLmJsb2NrQ2FjaGUuZ2V0KGlkKSB8fCB0aGlzLmV2aWN0ZWRCbG9ja3MuZ2V0KGlkKSk7XG4gICAgY29uc3QgZmFpbGVkQmxvY2tzID0gYmxvY2tzLmZpbHRlcigoaSkgPT4gIWkpO1xuICAgIGlmIChmYWlsZWRCbG9ja3MubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgQWdncmVnYXRlRXJyb3IoZmFpbGVkQmxvY2tzLCAnUmVxdWVzdCBmYWlsZWQnKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYSBmaW5hbCBNYXAsIHdpdGggYWxsIHJlcXVpcmVkIGJsb2NrcyBmb3IgdGhpcyByZXF1ZXN0IHRvIHNhdGlzZnlcbiAgICBjb25zdCByZXF1aXJlZEJsb2NrcyA9IG5ldyBNYXAoemlwKGFsbEJsb2NrSWRzLCBibG9ja3MpKTtcblxuICAgIC8vIFRPRE86IHNhdGlzZnkgZWFjaCBzbGljZVxuICAgIHJldHVybiB0aGlzLnJlYWRTbGljZURhdGEoc2xpY2VzLCByZXF1aXJlZEJsb2Nrcyk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gc2lnbmFsXG4gICAqL1xuICBmZXRjaEJsb2NrcyhzaWduYWwpIHtcbiAgICAvLyBjaGVjayBpZiB3ZSBzdGlsbCBuZWVkIHRvXG4gICAgaWYgKHRoaXMuYmxvY2tJZHNUb0ZldGNoLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBncm91cHMgPSB0aGlzLmdyb3VwQmxvY2tzKHRoaXMuYmxvY2tJZHNUb0ZldGNoKTtcblxuICAgICAgLy8gc3RhcnQgcmVxdWVzdGluZyBzbGljZXMgb2YgZGF0YVxuICAgICAgY29uc3QgZ3JvdXBSZXF1ZXN0cyA9IHRoaXMuc291cmNlLmZldGNoKGdyb3Vwcywgc2lnbmFsKTtcblxuICAgICAgZm9yIChsZXQgZ3JvdXBJbmRleCA9IDA7IGdyb3VwSW5kZXggPCBncm91cHMubGVuZ3RoOyArK2dyb3VwSW5kZXgpIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHNbZ3JvdXBJbmRleF07XG5cbiAgICAgICAgZm9yIChjb25zdCBibG9ja0lkIG9mIGdyb3VwLmJsb2NrSWRzKSB7XG4gICAgICAgICAgLy8gbWFrZSBhbiBhc3luYyBJSUZFIGZvciBlYWNoIGJsb2NrXG4gICAgICAgICAgdGhpcy5ibG9ja1JlcXVlc3RzLnNldChibG9ja0lkLCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgZ3JvdXBSZXF1ZXN0cylbZ3JvdXBJbmRleF07XG4gICAgICAgICAgICAgIGNvbnN0IGJsb2NrT2Zmc2V0ID0gYmxvY2tJZCAqIHRoaXMuYmxvY2tTaXplO1xuICAgICAgICAgICAgICBjb25zdCBvID0gYmxvY2tPZmZzZXQgLSByZXNwb25zZS5vZmZzZXQ7XG4gICAgICAgICAgICAgIGNvbnN0IHQgPSBNYXRoLm1pbihvICsgdGhpcy5ibG9ja1NpemUsIHJlc3BvbnNlLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhLnNsaWNlKG8sIHQpO1xuICAgICAgICAgICAgICBjb25zdCBibG9jayA9IG5ldyBCbG9jayhcbiAgICAgICAgICAgICAgICBibG9ja09mZnNldCxcbiAgICAgICAgICAgICAgICBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBibG9ja0lkLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0aGlzLmJsb2NrQ2FjaGUuc2V0KGJsb2NrSWQsIGJsb2NrKTtcbiAgICAgICAgICAgICAgdGhpcy5hYm9ydGVkQmxvY2tJZHMuZGVsZXRlKGJsb2NrSWQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHNpZ25hbCBoZXJlLCB3ZSBuZWVkIGl0IHRvIGRldGVybWluZSBsYXRlciBpZiBhblxuICAgICAgICAgICAgICAgIC8vIGVycm9yIHdhcyBjYXVzZWQgYnkgdGhpcyBzaWduYWxcbiAgICAgICAgICAgICAgICBlcnIuc2lnbmFsID0gc2lnbmFsO1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tDYWNoZS5kZWxldGUoYmxvY2tJZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydGVkQmxvY2tJZHMuYWRkKGJsb2NrSWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdGhpcy5ibG9ja1JlcXVlc3RzLmRlbGV0ZShibG9ja0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5ibG9ja0lkc1RvRmV0Y2guY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtTZXR9IGJsb2NrSWRzXG4gICAqIEByZXR1cm5zIHtCbG9ja0dyb3VwW119XG4gICAqL1xuICBncm91cEJsb2NrcyhibG9ja0lkcykge1xuICAgIGNvbnN0IHNvcnRlZEJsb2NrSWRzID0gQXJyYXkuZnJvbShibG9ja0lkcykuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIGlmIChzb3J0ZWRCbG9ja0lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnQgPSBbXTtcbiAgICBsZXQgbGFzdEJsb2NrSWQgPSBudWxsO1xuICAgIGNvbnN0IGdyb3VwcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBibG9ja0lkIG9mIHNvcnRlZEJsb2NrSWRzKSB7XG4gICAgICBpZiAobGFzdEJsb2NrSWQgPT09IG51bGwgfHwgbGFzdEJsb2NrSWQgKyAxID09PSBibG9ja0lkKSB7XG4gICAgICAgIGN1cnJlbnQucHVzaChibG9ja0lkKTtcbiAgICAgICAgbGFzdEJsb2NrSWQgPSBibG9ja0lkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JvdXBzLnB1c2gobmV3IEJsb2NrR3JvdXAoXG4gICAgICAgICAgY3VycmVudFswXSAqIHRoaXMuYmxvY2tTaXplLFxuICAgICAgICAgIGN1cnJlbnQubGVuZ3RoICogdGhpcy5ibG9ja1NpemUsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgKSk7XG4gICAgICAgIGN1cnJlbnQgPSBbYmxvY2tJZF07XG4gICAgICAgIGxhc3RCbG9ja0lkID0gYmxvY2tJZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBncm91cHMucHVzaChuZXcgQmxvY2tHcm91cChcbiAgICAgIGN1cnJlbnRbMF0gKiB0aGlzLmJsb2NrU2l6ZSxcbiAgICAgIGN1cnJlbnQubGVuZ3RoICogdGhpcy5ibG9ja1NpemUsXG4gICAgICBjdXJyZW50LFxuICAgICkpO1xuXG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vYmFzZXNvdXJjZVwiKS5TbGljZVtdfSBzbGljZXNcbiAgICogQHBhcmFtIHtNYXB9IGJsb2Nrc1xuICAgKi9cbiAgcmVhZFNsaWNlRGF0YShzbGljZXMsIGJsb2Nrcykge1xuICAgIHJldHVybiBzbGljZXMubWFwKChzbGljZSkgPT4ge1xuICAgICAgbGV0IHRvcCA9IHNsaWNlLm9mZnNldCArIHNsaWNlLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmZpbGVTaXplICE9PSBudWxsKSB7XG4gICAgICAgIHRvcCA9IE1hdGgubWluKHRoaXMuZmlsZVNpemUsIHRvcCk7XG4gICAgICB9XG4gICAgICBjb25zdCBibG9ja0lkTG93ID0gTWF0aC5mbG9vcihzbGljZS5vZmZzZXQgLyB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICBjb25zdCBibG9ja0lkSGlnaCA9IE1hdGguZmxvb3IodG9wIC8gdGhpcy5ibG9ja1NpemUpO1xuICAgICAgY29uc3Qgc2xpY2VEYXRhID0gbmV3IEFycmF5QnVmZmVyKHNsaWNlLmxlbmd0aCk7XG4gICAgICBjb25zdCBzbGljZVZpZXcgPSBuZXcgVWludDhBcnJheShzbGljZURhdGEpO1xuXG4gICAgICBmb3IgKGxldCBibG9ja0lkID0gYmxvY2tJZExvdzsgYmxvY2tJZCA8PSBibG9ja0lkSGlnaDsgKytibG9ja0lkKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYmxvY2tzLmdldChibG9ja0lkKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBibG9jay5vZmZzZXQgLSBzbGljZS5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHRvcERlbHRhID0gYmxvY2sudG9wIC0gdG9wO1xuICAgICAgICBsZXQgYmxvY2tJbm5lck9mZnNldCA9IDA7XG4gICAgICAgIGxldCByYW5nZUlubmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IHVzZWRCbG9ja0xlbmd0aDtcblxuICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgYmxvY2tJbm5lck9mZnNldCA9IC1kZWx0YTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICByYW5nZUlubmVyT2Zmc2V0ID0gZGVsdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9wRGVsdGEgPCAwKSB7XG4gICAgICAgICAgdXNlZEJsb2NrTGVuZ3RoID0gYmxvY2subGVuZ3RoIC0gYmxvY2tJbm5lck9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1c2VkQmxvY2tMZW5ndGggPSB0b3AgLSBibG9jay5vZmZzZXQgLSBibG9ja0lubmVyT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmxvY2tWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2suZGF0YSwgYmxvY2tJbm5lck9mZnNldCwgdXNlZEJsb2NrTGVuZ3RoKTtcbiAgICAgICAgc2xpY2VWaWV3LnNldChibG9ja1ZpZXcsIHJhbmdlSW5uZXJPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2xpY2VEYXRhO1xuICAgIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/blockedsource.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/client/base.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/base.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseClient: () => (/* binding */ BaseClient),\n/* harmony export */   BaseResponse: () => (/* binding */ BaseResponse)\n/* harmony export */ });\nclass BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nclass BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDRDQUE0QyxXQUFXO0FBQ3JFLGVBQWU7QUFDZjtBQUNBLGtCQUFrQixrQkFBa0IsSUFBSSxJQUFJO0FBQzVDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2Jhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEJhc2VSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHJlc3BvbnNlIGhhcyBhbiBvaydpc2ggc3RhdHVzIGNvZGVcbiAgICovXG4gIGdldCBvaygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDw9IDI5OTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGF0dXMgY29kZSBvZiB0aGUgcmVzcG9uc2VcbiAgICovXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGhlYWRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyTmFtZSB0aGUgaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMge3N0cmluZ30gdGhlIGhlYWRlciB2YWx1ZVxuICAgKi9cbiAgZ2V0SGVhZGVyKGhlYWRlck5hbWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSB0aGUgcmVzcG9uc2UgZGF0YSBvZiB0aGUgcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgZ2V0RGF0YSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCYXNlQ2xpZW50IHtcbiAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHJlcXVlc3Qgd2l0aCB0aGUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge3toZWFkZXJzOiBIZWFkZXJzSW5pdCwgc2lnbmFsOiBBYm9ydFNpZ25hbH19IFtvcHRpb25zPXt9XVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCYXNlUmVzcG9uc2U+fVxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdCh7IGhlYWRlcnMsIHNpZ25hbCB9ID0ge30pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHRocm93IG5ldyBFcnJvcigncmVxdWVzdCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/client/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/client/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/fetch.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchClient: () => (/* binding */ FetchClient)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/client/base.js\");\n\n\nclass FetchResponse extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nclass FetchClient extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFEOztBQUVyRCw0QkFBNEIsa0RBQVk7QUFDeEM7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sMEJBQTBCLGdEQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyw0Q0FBNEMsV0FBVztBQUNyRSxlQUFlO0FBQ2Y7QUFDQSxrQkFBa0Isa0JBQWtCLElBQUk7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL2NsaWVudC9mZXRjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ2xpZW50LCBCYXNlUmVzcG9uc2UgfSBmcm9tICcuL2Jhc2UuanMnO1xuXG5jbGFzcyBGZXRjaFJlc3BvbnNlIGV4dGVuZHMgQmFzZVJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEJhc2VSZXNwb25zZSBmYWNhZGUgZm9yIGZldGNoIEFQSSBSZXNwb25zZVxuICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZVxuICAgKi9cbiAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgfVxuXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2Uuc3RhdHVzO1xuICB9XG5cbiAgZ2V0SGVhZGVyKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZS5oZWFkZXJzLmdldChuYW1lKTtcbiAgfVxuXG4gIGFzeW5jIGdldERhdGEoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzcG9uc2UuYXJyYXlCdWZmZXJcbiAgICAgID8gYXdhaXQgdGhpcy5yZXNwb25zZS5hcnJheUJ1ZmZlcigpXG4gICAgICA6IChhd2FpdCB0aGlzLnJlc3BvbnNlLmJ1ZmZlcigpKS5idWZmZXI7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZldGNoQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKHVybCwgY3JlZGVudGlhbHMpIHtcbiAgICBzdXBlcih1cmwpO1xuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3toZWFkZXJzOiBIZWFkZXJzSW5pdCwgc2lnbmFsOiBBYm9ydFNpZ25hbH19IFtvcHRpb25zPXt9XVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFJlc3BvbnNlPn1cbiAgICovXG4gIGFzeW5jIHJlcXVlc3QoeyBoZWFkZXJzLCBzaWduYWwgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLnVybCwge1xuICAgICAgaGVhZGVycywgY3JlZGVudGlhbHM6IHRoaXMuY3JlZGVudGlhbHMsIHNpZ25hbCxcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/client/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/client/http.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/http.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpClient: () => (/* binding */ HttpClient)\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils.js */ \"(ssr)/./node_modules/geotiff/dist-module/utils.js\");\n\n\n\n\n\n\n\nclass HttpResponse extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nclass HttpClient extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = url__WEBPACK_IMPORTED_MODULE_2__.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http__WEBPACK_IMPORTED_MODULE_0__ : https__WEBPACK_IMPORTED_MODULE_1__);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__.AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__.AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2h0dHAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXdCO0FBQ0U7QUFDRDs7QUFFNEI7QUFDVDs7QUFFNUMsMkJBQTJCLGtEQUFZO0FBQ3ZDO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLHlCQUF5QixnREFBVTtBQUMxQztBQUNBO0FBQ0EscUJBQXFCLHNDQUFZO0FBQ2pDLDBEQUEwRCxpQ0FBSSxHQUFHLGtDQUFLO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsaURBQVU7QUFDeEM7QUFDQSxtRUFBbUUsaURBQVU7QUFDN0U7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsa0JBQWtCLGtCQUFrQixJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQvaHR0cC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaHR0cCBmcm9tICdodHRwJztcbmltcG9ydCBodHRwcyBmcm9tICdodHRwcyc7XG5pbXBvcnQgdXJsTW9kIGZyb20gJ3VybCc7XG5cbmltcG9ydCB7IEJhc2VDbGllbnQsIEJhc2VSZXNwb25zZSB9IGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQgeyBBYm9ydEVycm9yIH0gZnJvbSAnLi4vLi4vdXRpbHMuanMnO1xuXG5jbGFzcyBIdHRwUmVzcG9uc2UgZXh0ZW5kcyBCYXNlUmVzcG9uc2Uge1xuICAvKipcbiAgICogQmFzZVJlc3BvbnNlIGZhY2FkZSBmb3Igbm9kZSBIVFRQL0hUVFBTIEFQSSBSZXNwb25zZVxuICAgKiBAcGFyYW0ge2h0dHAuU2VydmVyUmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZSwgZGF0YVByb21pc2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLmRhdGFQcm9taXNlID0gZGF0YVByb21pc2U7XG4gIH1cblxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gIH1cblxuICBnZXRIZWFkZXIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLmhlYWRlcnNbbmFtZV07XG4gIH1cblxuICBhc3luYyBnZXREYXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmRhdGFQcm9taXNlO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBIdHRwQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHN1cGVyKHVybCk7XG4gICAgdGhpcy5wYXJzZWRVcmwgPSB1cmxNb2QucGFyc2UodGhpcy51cmwpO1xuICAgIHRoaXMuaHR0cEFwaSA9ICh0aGlzLnBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6JyA/IGh0dHAgOiBodHRwcyk7XG4gIH1cblxuICBjb25zdHJ1Y3RSZXF1ZXN0KGhlYWRlcnMsIHNpZ25hbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5odHRwQXBpLmdldChcbiAgICAgICAge1xuICAgICAgICAgIC4uLnRoaXMucGFyc2VkVXJsLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH0sXG4gICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGFQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmVEYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcblxuICAgICAgICAgICAgLy8gY29sbGVjdCBjaHVua3NcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjb25jYXRlbmF0ZSBhbGwgY2h1bmtzIGFuZCByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggdGhlIHJlc3VsdGluZyBidWZmZXJcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuY29uY2F0KGNodW5rcykuYnVmZmVyO1xuICAgICAgICAgICAgICByZXNvbHZlRGF0YShkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNvbHZlKG5ldyBIdHRwUmVzcG9uc2UocmVzcG9uc2UsIGRhdGFQcm9taXNlKSk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgcmVxdWVzdC5vbignZXJyb3InLCByZWplY3QpO1xuXG4gICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJlcXVlc3QuZGVzdHJveShuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJykpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHJlcXVlc3QuZGVzdHJveShuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJykpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3QoeyBoZWFkZXJzLCBzaWduYWwgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNvbnN0cnVjdFJlcXVlc3QoaGVhZGVycywgc2lnbmFsKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/client/http.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/client/xhr.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/xhr.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   XHRClient: () => (/* binding */ XHRClient)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils.js */ \"(ssr)/./node_modules/geotiff/dist-module/utils.js\");\n\n\n\nclass XHRResponse extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nclass XHRClient extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L3hoci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7QUFDVDs7QUFFNUMsMEJBQTBCLGtEQUFZO0FBQ3RDO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sd0JBQXdCLGdEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlEQUFVO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxrQkFBa0Isa0JBQWtCLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL2NsaWVudC94aHIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNsaWVudCwgQmFzZVJlc3BvbnNlIH0gZnJvbSAnLi9iYXNlLmpzJztcbmltcG9ydCB7IEFib3J0RXJyb3IgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5cbmNsYXNzIFhIUlJlc3BvbnNlIGV4dGVuZHMgQmFzZVJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEJhc2VSZXNwb25zZSBmYWNhZGUgZm9yIFhNTEh0dHBSZXF1ZXN0XG4gICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IHhoclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4aHIsIGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMueGhyID0geGhyO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnhoci5zdGF0dXM7XG4gIH1cblxuICBnZXRIZWFkZXIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcihuYW1lKTtcbiAgfVxuXG4gIGFzeW5jIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgWEhSQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gIGNvbnN0cnVjdFJlcXVlc3QoaGVhZGVycywgc2lnbmFsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHRoaXMudXJsKTtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhvb2sgc2lnbmFsc1xuICAgICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgcmVzb2x2ZShuZXcgWEhSUmVzcG9uc2UoeGhyLCBkYXRhKSk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICB4aHIub25hYm9ydCA9ICgpID0+IHJlamVjdChuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJykpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB4aHIuYWJvcnQoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZXF1ZXN0KHsgaGVhZGVycywgc2lnbmFsIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25zdHJ1Y3RSZXF1ZXN0KGhlYWRlcnMsIHNpZ25hbCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/client/xhr.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/file.js":
/*!*********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/file.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeFileSource: () => (/* binding */ makeFileSource)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/basesource.js\");\n\n\n\nfunction closeAsync(fd) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.close(fd, (err) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction openAsync(path, flags, mode = undefined) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.open(path, flags, mode, (err, fd) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(fd);\n      }\n    });\n  });\n}\n\nfunction readAsync(...args) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.read(...args, (err, bytesRead, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({ bytesRead, buffer });\n      }\n    });\n  });\n}\n\nclass FileSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource {\n  constructor(path) {\n    super();\n    this.path = path;\n    this.openRequest = openAsync(path, 'r');\n  }\n\n  async fetchSlice(slice) {\n    // TODO: use `signal`\n    const fd = await this.openRequest;\n    const { buffer } = await readAsync(\n      fd,\n      Buffer.alloc(slice.length),\n      0,\n      slice.length,\n      slice.offset,\n    );\n    return buffer.buffer;\n  }\n\n  async close() {\n    const fd = await this.openRequest;\n    await closeAsync(fd);\n  }\n}\n\nfunction makeFileSource(path) {\n  return new FileSource(path);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvZmlsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0I7QUFDeUI7O0FBRTdDO0FBQ0E7QUFDQSxJQUFJLHFDQUFRO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxvQ0FBTztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLElBQUksb0NBQU87QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLHlCQUF5QixzREFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9maWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcblxuZnVuY3Rpb24gY2xvc2VBc3luYyhmZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLmNsb3NlKGZkLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb3BlbkFzeW5jKHBhdGgsIGZsYWdzLCBtb2RlID0gdW5kZWZpbmVkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMub3BlbihwYXRoLCBmbGFncywgbW9kZSwgKGVyciwgZmQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKGZkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRBc3luYyguLi5hcmdzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMucmVhZCguLi5hcmdzLCAoZXJyLCBieXRlc1JlYWQsIGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoeyBieXRlc1JlYWQsIGJ1ZmZlciB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmNsYXNzIEZpbGVTb3VyY2UgZXh0ZW5kcyBCYXNlU291cmNlIHtcbiAgY29uc3RydWN0b3IocGF0aCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLm9wZW5SZXF1ZXN0ID0gb3BlbkFzeW5jKHBhdGgsICdyJyk7XG4gIH1cblxuICBhc3luYyBmZXRjaFNsaWNlKHNsaWNlKSB7XG4gICAgLy8gVE9ETzogdXNlIGBzaWduYWxgXG4gICAgY29uc3QgZmQgPSBhd2FpdCB0aGlzLm9wZW5SZXF1ZXN0O1xuICAgIGNvbnN0IHsgYnVmZmVyIH0gPSBhd2FpdCByZWFkQXN5bmMoXG4gICAgICBmZCxcbiAgICAgIEJ1ZmZlci5hbGxvYyhzbGljZS5sZW5ndGgpLFxuICAgICAgMCxcbiAgICAgIHNsaWNlLmxlbmd0aCxcbiAgICAgIHNsaWNlLm9mZnNldCxcbiAgICApO1xuICAgIHJldHVybiBidWZmZXIuYnVmZmVyO1xuICB9XG5cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgY29uc3QgZmQgPSBhd2FpdCB0aGlzLm9wZW5SZXF1ZXN0O1xuICAgIGF3YWl0IGNsb3NlQXN5bmMoZmQpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRmlsZVNvdXJjZShwYXRoKSB7XG4gIHJldHVybiBuZXcgRmlsZVNvdXJjZShwYXRoKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/file.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/filereader.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/filereader.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeFileReaderSource: () => (/* binding */ makeFileReaderSource)\n/* harmony export */ });\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/basesource.js\");\n\n\nclass FileReaderSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nfunction makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvZmlsZXJlYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2Qzs7QUFFN0MsK0JBQStCLHNEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9maWxlcmVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VTb3VyY2UgfSBmcm9tICcuL2Jhc2Vzb3VyY2UuanMnO1xuXG5jbGFzcyBGaWxlUmVhZGVyU291cmNlIGV4dGVuZHMgQmFzZVNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKGZpbGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gIH1cblxuICBhc3luYyBmZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgYmxvYiA9IHRoaXMuZmlsZS5zbGljZShzbGljZS5vZmZzZXQsIHNsaWNlLm9mZnNldCArIHNsaWNlLmxlbmd0aCk7XG4gICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IChldmVudCkgPT4gcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgcmVhZGVyLm9uYWJvcnQgPSByZWplY3Q7XG4gICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG5cbiAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gcmVhZGVyLmFib3J0KCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHNvdXJjZSBmcm9tIGEgZ2l2ZW4gZmlsZS9ibG9iLlxuICogQHBhcmFtIHtCbG9ifSBmaWxlIFRoZSBmaWxlIG9yIGJsb2IgdG8gcmVhZCBmcm9tLlxuICogQHJldHVybnMgVGhlIGNvbnN0cnVjdGVkIHNvdXJjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUZpbGVSZWFkZXJTb3VyY2UoZmlsZSkge1xuICByZXR1cm4gbmV3IEZpbGVSZWFkZXJTb3VyY2UoZmlsZSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/filereader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/httputils.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/httputils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseByteRanges: () => (/* binding */ parseByteRanges),\n/* harmony export */   parseContentRange: () => (/* binding */ parseContentRange),\n/* harmony export */   parseContentType: () => (/* binding */ parseContentType)\n/* harmony export */ });\nconst CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nfunction parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nfunction parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nfunction parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvaHR0cHV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDTztBQUNQLHNEQUFzRDtBQUN0RDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsVUFBVTtBQUN2QjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixTQUFTO0FBQ3RDLHlCQUF5QixjQUFjOztBQUV2QztBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3Qvbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL2h0dHB1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBDUkxGQ1JMRiA9ICdcXHJcXG5cXHJcXG4nO1xuXG4vKlxuICogU2hpbSBmb3IgJ09iamVjdC5mcm9tRW50cmllcydcbiAqL1xuZnVuY3Rpb24gaXRlbXNUb09iamVjdChpdGVtcykge1xuICBpZiAodHlwZW9mIE9iamVjdC5mcm9tRW50cmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGl0ZW1zKTtcbiAgfVxuICBjb25zdCBvYmogPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaXRlbXMpIHtcbiAgICBvYmpba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBQYXJzZSBIVFRQIGhlYWRlcnMgZnJvbSBhIGdpdmVuIHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRoZSB0ZXh0IHRvIHBhcnNlIHRoZSBoZWFkZXJzIGZyb21cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBwYXJzZWQgaGVhZGVycyB3aXRoIGxvd2VyY2FzZSBrZXlzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyh0ZXh0KSB7XG4gIGNvbnN0IGl0ZW1zID0gdGV4dFxuICAgIC5zcGxpdCgnXFxyXFxuJylcbiAgICAubWFwKChsaW5lKSA9PiB7XG4gICAgICBjb25zdCBrdiA9IGxpbmUuc3BsaXQoJzonKS5tYXAoKHN0cikgPT4gc3RyLnRyaW0oKSk7XG4gICAgICBrdlswXSA9IGt2WzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4ga3Y7XG4gICAgfSk7XG5cbiAgcmV0dXJuIGl0ZW1zVG9PYmplY3QoaXRlbXMpO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgJ0NvbnRlbnQtVHlwZScgaGVhZGVyIHZhbHVlIHRvIHRoZSBjb250ZW50LXR5cGUgYW5kIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdDb250ZW50VHlwZSB0aGUgcmF3IHN0cmluZyB0byBwYXJzZSBmcm9tXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcGFyc2VkIGNvbnRlbnQgdHlwZSB3aXRoIHRoZSBmaWVsZHM6IHR5cGUgYW5kIHBhcmFtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb250ZW50VHlwZShyYXdDb250ZW50VHlwZSkge1xuICBjb25zdCBbdHlwZSwgLi4ucmF3UGFyYW1zXSA9IHJhd0NvbnRlbnRUeXBlLnNwbGl0KCc7JykubWFwKChzKSA9PiBzLnRyaW0oKSk7XG4gIGNvbnN0IHBhcmFtc0l0ZW1zID0gcmF3UGFyYW1zLm1hcCgocGFyYW0pID0+IHBhcmFtLnNwbGl0KCc9JykpO1xuICByZXR1cm4geyB0eXBlLCBwYXJhbXM6IGl0ZW1zVG9PYmplY3QocGFyYW1zSXRlbXMpIH07XG59XG5cbi8qKlxuICogUGFyc2UgYSAnQ29udGVudC1SYW5nZScgaGVhZGVyIHZhbHVlIHRvIGl0cyBzdGFydCwgZW5kLCBhbmQgdG90YWwgcGFydHNcbiAqIEBwYXJhbSB7U3RyaW5nfSByYXdDb250ZW50UmFuZ2UgdGhlIHJhdyBzdHJpbmcgdG8gcGFyc2UgZnJvbVxuICogQHJldHVybnMge09iamVjdH0gdGhlIHBhcnNlZCBwYXJ0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb250ZW50UmFuZ2UocmF3Q29udGVudFJhbmdlKSB7XG4gIGxldCBzdGFydDtcbiAgbGV0IGVuZDtcbiAgbGV0IHRvdGFsO1xuXG4gIGlmIChyYXdDb250ZW50UmFuZ2UpIHtcbiAgICBbLCBzdGFydCwgZW5kLCB0b3RhbF0gPSByYXdDb250ZW50UmFuZ2UubWF0Y2goL2J5dGVzIChcXGQrKS0oXFxkKylcXC8oXFxkKykvKTtcbiAgICBzdGFydCA9IHBhcnNlSW50KHN0YXJ0LCAxMCk7XG4gICAgZW5kID0gcGFyc2VJbnQoZW5kLCAxMCk7XG4gICAgdG90YWwgPSBwYXJzZUludCh0b3RhbCwgMTApO1xuICB9XG5cbiAgcmV0dXJuIHsgc3RhcnQsIGVuZCwgdG90YWwgfTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBsaXN0IG9mIGJ5dGVyYW5nZXMgZnJvbSB0aGUgZ2l2ZW4gJ211bHRpcGFydC9ieXRlcmFuZ2VzJyBIVFRQIHJlc3BvbnNlLlxuICogRWFjaCBpdGVtIGluIHRoZSBsaXN0IGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAtIGhlYWRlcnM6IHRoZSBIVFRQIGhlYWRlcnNcbiAqIC0gZGF0YTogdGhlIHNsaWNlZCBBcnJheUJ1ZmZlciBmb3IgdGhhdCBzcGVjaWZpYyBwYXJ0XG4gKiAtIG9mZnNldDogdGhlIG9mZnNldCBvZiB0aGUgYnl0ZXJhbmdlIHdpdGhpbiBpdHMgb3JpZ2luYXRpbmcgZmlsZVxuICogLSBsZW5ndGg6IHRoZSBsZW5ndGggb2YgdGhlIGJ5dGVyYW5nZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gcmVzcG9uc2VBcnJheUJ1ZmZlciB0aGUgcmVzcG9uc2UgdG8gYmUgcGFyc2VkIGFuZCBzcGxpdFxuICogQHBhcmFtIHtTdHJpbmd9IGJvdW5kYXJ5IHRoZSBib3VuZGFyeSBzdHJpbmcgdXNlZCB0byBzcGxpdCB0aGUgc2VjdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3RbXX0gdGhlIHBhcnNlZCBieXRlcmFuZ2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJ5dGVSYW5nZXMocmVzcG9uc2VBcnJheUJ1ZmZlciwgYm91bmRhcnkpIHtcbiAgbGV0IG9mZnNldCA9IG51bGw7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ2FzY2lpJyk7XG4gIGNvbnN0IG91dCA9IFtdO1xuXG4gIGNvbnN0IHN0YXJ0Qm91bmRhcnkgPSBgLS0ke2JvdW5kYXJ5fWA7XG4gIGNvbnN0IGVuZEJvdW5kYXJ5ID0gYCR7c3RhcnRCb3VuZGFyeX0tLWA7XG5cbiAgLy8gc2VhcmNoIGZvciB0aGUgaW5pdGlhbCBib3VuZGFyeSwgbWF5IGJlIG9mZnNldCBieSBzb21lIGJ5dGVzXG4gIC8vIFRPRE86IG1vcmUgZWZmaWNpZW50IHRvIGNoZWNrIGZvciBgLS1gIGluIGJ5dGVzIGRpcmVjdGx5XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7ICsraSkge1xuICAgIGNvbnN0IHRleHQgPSBkZWNvZGVyLmRlY29kZShcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3BvbnNlQXJyYXlCdWZmZXIsIGksIHN0YXJ0Qm91bmRhcnkubGVuZ3RoKSxcbiAgICApO1xuICAgIGlmICh0ZXh0ID09PSBzdGFydEJvdW5kYXJ5KSB7XG4gICAgICBvZmZzZXQgPSBpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvZmZzZXQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGluaXRpYWwgYm91bmRhcnknKTtcbiAgfVxuXG4gIHdoaWxlIChvZmZzZXQgPCByZXNwb25zZUFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICBjb25zdCB0ZXh0ID0gZGVjb2Rlci5kZWNvZGUoXG4gICAgICBuZXcgVWludDhBcnJheShyZXNwb25zZUFycmF5QnVmZmVyLCBvZmZzZXQsXG4gICAgICAgIE1hdGgubWluKHN0YXJ0Qm91bmRhcnkubGVuZ3RoICsgMTAyNCwgcmVzcG9uc2VBcnJheUJ1ZmZlci5ieXRlTGVuZ3RoIC0gb2Zmc2V0KSxcbiAgICAgICksXG4gICAgKTtcblxuICAgIC8vIGJyZWFrIGlmIHdlIGFycml2ZWQgYXQgdGhlIGVuZFxuICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCB8fCB0ZXh0LnN0YXJ0c1dpdGgoZW5kQm91bmRhcnkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBhc3NlcnQgdGhhdCB3ZSBhcmUgYWN0dWFsbHkgZGVhbGluZyB3aXRoIGEgYnl0ZXJhbmdlIGFuZCBhcmUgYXQgdGhlIGNvcnJlY3Qgb2Zmc2V0XG4gICAgaWYgKCF0ZXh0LnN0YXJ0c1dpdGgoc3RhcnRCb3VuZGFyeSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFydCBkb2VzIG5vdCBzdGFydCB3aXRoIGJvdW5kYXJ5Jyk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IGEgc3Vic3RyaW5nIGZyb20gd2hlcmUgd2UgcmVhZCB0aGUgaGVhZGVyc1xuICAgIGNvbnN0IGlubmVyVGV4dCA9IHRleHQuc3Vic3RyKHN0YXJ0Qm91bmRhcnkubGVuZ3RoICsgMik7XG5cbiAgICBpZiAoaW5uZXJUZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gZmluZCB0aGUgZG91YmxlIGxpbmVicmVhayB0aGF0IGRlbm90ZXMgdGhlIGVuZCBvZiB0aGUgaGVhZGVyc1xuICAgIGNvbnN0IGVuZE9mSGVhZGVycyA9IGlubmVyVGV4dC5pbmRleE9mKENSTEZDUkxGKTtcblxuICAgIC8vIHBhcnNlIHRoZSBoZWFkZXJzIHRvIGdldCB0aGUgY29udGVudCByYW5nZSBzaXplXG4gICAgY29uc3QgaGVhZGVycyA9IHBhcnNlSGVhZGVycyhpbm5lclRleHQuc3Vic3RyKDAsIGVuZE9mSGVhZGVycykpO1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgdG90YWwgfSA9IHBhcnNlQ29udGVudFJhbmdlKGhlYWRlcnNbJ2NvbnRlbnQtcmFuZ2UnXSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB0aGUgc2xpY2UgYW5kIHRoZSBuZXh0IG9mZnNldFxuICAgIGNvbnN0IHN0YXJ0T2ZEYXRhID0gb2Zmc2V0ICsgc3RhcnRCb3VuZGFyeS5sZW5ndGggKyBlbmRPZkhlYWRlcnMgKyBDUkxGQ1JMRi5sZW5ndGg7XG4gICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoZW5kLCAxMCkgKyAxIC0gcGFyc2VJbnQoc3RhcnQsIDEwKTtcbiAgICBvdXQucHVzaCh7XG4gICAgICBoZWFkZXJzLFxuICAgICAgZGF0YTogcmVzcG9uc2VBcnJheUJ1ZmZlci5zbGljZShzdGFydE9mRGF0YSwgc3RhcnRPZkRhdGEgKyBsZW5ndGgpLFxuICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIGZpbGVTaXplOiB0b3RhbCxcbiAgICB9KTtcblxuICAgIG9mZnNldCA9IHN0YXJ0T2ZEYXRhICsgbGVuZ3RoICsgNDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/httputils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/remote.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/remote.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeCustomSource: () => (/* binding */ makeCustomSource),\n/* harmony export */   makeFetchSource: () => (/* binding */ makeFetchSource),\n/* harmony export */   makeHttpSource: () => (/* binding */ makeHttpSource),\n/* harmony export */   makeRemoteSource: () => (/* binding */ makeRemoteSource),\n/* harmony export */   makeXHRSource: () => (/* binding */ makeXHRSource)\n/* harmony export */ });\n/* harmony import */ var _httputils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./httputils.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/httputils.js\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blockedsource.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/blockedsource.js\");\n/* harmony import */ var _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./client/fetch.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/client/fetch.js\");\n/* harmony import */ var _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client/xhr.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/client/xhr.js\");\n/* harmony import */ var _client_http_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./client/http.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/client/http.js\");\n\n\n\n\n\n\n\n\nclass RemoteSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentType)(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseByteRanges)(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentRange)(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentRange)(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__.BlockedSource(source, { blockSize, cacheSize });\n}\n\nfunction makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__.FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__.XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_http_js__WEBPACK_IMPORTED_MODULE_5__.HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nfunction makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvcmVtb3RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXNGO0FBQ3pDO0FBQ007O0FBRUg7QUFDSjtBQUNFOztBQUU5QywyQkFBMkIsc0RBQVU7QUFDckM7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGtCQUFrQixnQkFBZ0IsUUFBUSxPQUFPLEdBQUcsZ0JBQWdCO0FBQ3BFO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjLGVBQWUsRUFBRSwrREFBZ0I7QUFDL0M7QUFDQSwyQkFBMkIsOERBQWU7QUFDMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsb0JBQW9CLEVBQUUsZ0VBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTyxHQUFHLGdCQUFnQjtBQUNsRCxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxjQUFjLFFBQVEsRUFBRSxnRUFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0REFBYSxXQUFXLHNCQUFzQjtBQUMzRDs7QUFFTyxnQ0FBZ0MsWUFBWSx1RUFBdUUsSUFBSTtBQUM5SCxxQkFBcUIseURBQVc7QUFDaEM7QUFDQTtBQUNBOztBQUVPLDhCQUE4QixZQUFZLDBEQUEwRCxJQUFJO0FBQy9HLHFCQUFxQixxREFBUztBQUM5QjtBQUNBO0FBQ0E7O0FBRU8sK0JBQStCLFlBQVksMERBQTBELElBQUk7QUFDaEgscUJBQXFCLHVEQUFVO0FBQy9CO0FBQ0E7QUFDQTs7QUFFTyxvQ0FBb0MsWUFBWSwwREFBMEQsSUFBSTtBQUNySDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDTyxpQ0FBaUMscUNBQXFDLElBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvcmVtb3RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlQnl0ZVJhbmdlcywgcGFyc2VDb250ZW50UmFuZ2UsIHBhcnNlQ29udGVudFR5cGUgfSBmcm9tICcuL2h0dHB1dGlscy5qcyc7XG5pbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcbmltcG9ydCB7IEJsb2NrZWRTb3VyY2UgfSBmcm9tICcuL2Jsb2NrZWRzb3VyY2UuanMnO1xuXG5pbXBvcnQgeyBGZXRjaENsaWVudCB9IGZyb20gJy4vY2xpZW50L2ZldGNoLmpzJztcbmltcG9ydCB7IFhIUkNsaWVudCB9IGZyb20gJy4vY2xpZW50L3hoci5qcyc7XG5pbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnLi9jbGllbnQvaHR0cC5qcyc7XG5cbmNsYXNzIFJlbW90ZVNvdXJjZSBleHRlbmRzIEJhc2VTb3VyY2Uge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtCYXNlQ2xpZW50fSBjbGllbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IGhlYWRlcnNcbiAgICogQHBhcmFtIHtudW1iZXJzfSBtYXhSYW5nZXNcbiAgICogQHBhcmFtIHtib29sZWFufSBhbGxvd0Z1bGxGaWxlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGhlYWRlcnMsIG1heFJhbmdlcywgYWxsb3dGdWxsRmlsZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLm1heFJhbmdlcyA9IG1heFJhbmdlcztcbiAgICB0aGlzLmFsbG93RnVsbEZpbGUgPSBhbGxvd0Z1bGxGaWxlO1xuICAgIHRoaXMuX2ZpbGVTaXplID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1NsaWNlW119IHNsaWNlc1xuICAgKi9cbiAgYXN5bmMgZmV0Y2goc2xpY2VzLCBzaWduYWwpIHtcbiAgICAvLyBpZiB3ZSBhbGxvdyBtdWx0aS1yYW5nZXMsIHNwbGl0IHRoZSBpbmNvbWluZyByZXF1ZXN0IGludG8gdGhhdCBtYW55IHN1Yi1yZXF1ZXN0c1xuICAgIC8vIGFuZCBqb2luIHRoZW0gYWZ0ZXJ3YXJkc1xuICAgIGlmICh0aGlzLm1heFJhbmdlcyA+PSBzbGljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaFNsaWNlcyhzbGljZXMsIHNpZ25hbCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1heFJhbmdlcyA+IDAgJiYgc2xpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIFRPRE86IHNwbGl0IGludG8gbXVsdGlwbGUgbXVsdGktcmFuZ2UgcmVxdWVzdHNcblxuICAgICAgLy8gY29uc3Qgc3ViU2xpY2VzUmVxdWVzdHMgPSBbXTtcbiAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpY2VzLmxlbmd0aDsgaSArPSB0aGlzLm1heFJhbmdlcykge1xuICAgICAgLy8gICBzdWJTbGljZXNSZXF1ZXN0cy5wdXNoKFxuICAgICAgLy8gICAgIHRoaXMuZmV0Y2hTbGljZXMoc2xpY2VzLnNsaWNlKGksIGkgKyB0aGlzLm1heFJhbmdlcyksIHNpZ25hbCksXG4gICAgICAvLyAgICk7XG4gICAgICAvLyB9XG4gICAgICAvLyByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKHN1YlNsaWNlc1JlcXVlc3RzKSkuZmxhdCgpO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBtYWtlIGEgc2luZ2xlIHJlcXVlc3QgZm9yIGVhY2ggc2xpY2VcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBzbGljZXMubWFwKChzbGljZSkgPT4gdGhpcy5mZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpKSxcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgZmV0Y2hTbGljZXMoc2xpY2VzLCBzaWduYWwpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgIFJhbmdlOiBgYnl0ZXM9JHtzbGljZXNcbiAgICAgICAgICAubWFwKCh7IG9mZnNldCwgbGVuZ3RoIH0pID0+IGAke29mZnNldH0tJHtvZmZzZXQgKyBsZW5ndGh9YClcbiAgICAgICAgICAuam9pbignLCcpXG4gICAgICAgIH1gLFxuICAgICAgfSxcbiAgICAgIHNpZ25hbCxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgZmV0Y2hpbmcgZGF0YS4nKTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2KSB7XG4gICAgICBjb25zdCB7IHR5cGUsIHBhcmFtcyB9ID0gcGFyc2VDb250ZW50VHlwZShyZXNwb25zZS5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpKTtcbiAgICAgIGlmICh0eXBlID09PSAnbXVsdGlwYXJ0L2J5dGVyYW5nZXMnKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVSYW5nZXMgPSBwYXJzZUJ5dGVSYW5nZXMoYXdhaXQgcmVzcG9uc2UuZ2V0RGF0YSgpLCBwYXJhbXMuYm91bmRhcnkpO1xuICAgICAgICB0aGlzLl9maWxlU2l6ZSA9IGJ5dGVSYW5nZXNbMF0uZmlsZVNpemUgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIGJ5dGVSYW5nZXM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5nZXREYXRhKCk7XG5cbiAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgdG90YWwgfSA9IHBhcnNlQ29udGVudFJhbmdlKHJlc3BvbnNlLmdldEhlYWRlcignY29udGVudC1yYW5nZScpKTtcbiAgICAgIHRoaXMuX2ZpbGVTaXplID0gdG90YWwgfHwgbnVsbDtcbiAgICAgIGNvbnN0IGZpcnN0ID0gW3tcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgICAgbGVuZ3RoOiBlbmQgLSBzdGFydCxcbiAgICAgIH1dO1xuXG4gICAgICBpZiAoc2xpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gd2UgcmVxdWVzdGVkIG1vcmUgdGhhbiBvbmUgc2xpY2UsIGJ1dCBnb3Qgb25seSB0aGUgZmlyc3RcbiAgICAgICAgLy8gdW5mb3J0dW5hdGVseSwgc29tZSBIVFRQIFNlcnZlcnMgZG9uJ3Qgc3VwcG9ydCBtdWx0aS1yYW5nZXNcbiAgICAgICAgLy8gYW5kIHJldHVybiBvbmx5IHRoZSBmaXJzdFxuXG4gICAgICAgIC8vIGdldCB0aGUgcmVzdCBvZiB0aGUgc2xpY2VzIGFuZCBmZXRjaCB0aGVtIGl0ZXJhdGl2ZWx5XG4gICAgICAgIGNvbnN0IG90aGVycyA9IGF3YWl0IFByb21pc2UuYWxsKHNsaWNlcy5zbGljZSgxKS5tYXAoKHNsaWNlKSA9PiB0aGlzLmZldGNoU2xpY2Uoc2xpY2UsIHNpZ25hbCkpKTtcbiAgICAgICAgcmV0dXJuIGZpcnN0LmNvbmNhdChvdGhlcnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuYWxsb3dGdWxsRmlsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciByZXNwb25kZWQgd2l0aCBmdWxsIGZpbGUnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5nZXREYXRhKCk7XG4gICAgICB0aGlzLl9maWxlU2l6ZSA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICBkYXRhLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGxlbmd0aDogZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgfV07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hTbGljZShzbGljZSwgc2lnbmFsKSB7XG4gICAgY29uc3QgeyBvZmZzZXQsIGxlbmd0aCB9ID0gc2xpY2U7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICBSYW5nZTogYGJ5dGVzPSR7b2Zmc2V0fS0ke29mZnNldCArIGxlbmd0aH1gLFxuICAgICAgfSxcbiAgICAgIHNpZ25hbCxcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIHRoZSByZXNwb25zZSB3YXMgb2theSBhbmQgaWYgdGhlIHNlcnZlciBhY3R1YWxseSB1bmRlcnN0YW5kcyByYW5nZSByZXF1ZXN0c1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgZmV0Y2hpbmcgZGF0YS4nKTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2KSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuZ2V0RGF0YSgpO1xuXG4gICAgICBjb25zdCB7IHRvdGFsIH0gPSBwYXJzZUNvbnRlbnRSYW5nZShyZXNwb25zZS5nZXRIZWFkZXIoJ2NvbnRlbnQtcmFuZ2UnKSk7XG4gICAgICB0aGlzLl9maWxlU2l6ZSA9IHRvdGFsIHx8IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5hbGxvd0Z1bGxGaWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyIHJlc3BvbmRlZCB3aXRoIGZ1bGwgZmlsZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuZ2V0RGF0YSgpO1xuXG4gICAgICB0aGlzLl9maWxlU2l6ZSA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgbGVuZ3RoOiBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGdldCBmaWxlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZVNpemU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVXcmFwSW5CbG9ja2VkU291cmNlKHNvdXJjZSwgeyBibG9ja1NpemUsIGNhY2hlU2l6ZSB9KSB7XG4gIGlmIChibG9ja1NpemUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIHJldHVybiBuZXcgQmxvY2tlZFNvdXJjZShzb3VyY2UsIHsgYmxvY2tTaXplLCBjYWNoZVNpemUgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRmV0Y2hTb3VyY2UodXJsLCB7IGhlYWRlcnMgPSB7fSwgY3JlZGVudGlhbHMsIG1heFJhbmdlcyA9IDAsIGFsbG93RnVsbEZpbGUgPSBmYWxzZSwgLi4uYmxvY2tPcHRpb25zIH0gPSB7fSkge1xuICBjb25zdCBjbGllbnQgPSBuZXcgRmV0Y2hDbGllbnQodXJsLCBjcmVkZW50aWFscyk7XG4gIGNvbnN0IHNvdXJjZSA9IG5ldyBSZW1vdGVTb3VyY2UoY2xpZW50LCBoZWFkZXJzLCBtYXhSYW5nZXMsIGFsbG93RnVsbEZpbGUpO1xuICByZXR1cm4gbWF5YmVXcmFwSW5CbG9ja2VkU291cmNlKHNvdXJjZSwgYmxvY2tPcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VYSFJTb3VyY2UodXJsLCB7IGhlYWRlcnMgPSB7fSwgbWF4UmFuZ2VzID0gMCwgYWxsb3dGdWxsRmlsZSA9IGZhbHNlLCAuLi5ibG9ja09wdGlvbnMgfSA9IHt9KSB7XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBYSFJDbGllbnQodXJsKTtcbiAgY29uc3Qgc291cmNlID0gbmV3IFJlbW90ZVNvdXJjZShjbGllbnQsIGhlYWRlcnMsIG1heFJhbmdlcywgYWxsb3dGdWxsRmlsZSk7XG4gIHJldHVybiBtYXliZVdyYXBJbkJsb2NrZWRTb3VyY2Uoc291cmNlLCBibG9ja09wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUh0dHBTb3VyY2UodXJsLCB7IGhlYWRlcnMgPSB7fSwgbWF4UmFuZ2VzID0gMCwgYWxsb3dGdWxsRmlsZSA9IGZhbHNlLCAuLi5ibG9ja09wdGlvbnMgfSA9IHt9KSB7XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBIdHRwQ2xpZW50KHVybCk7XG4gIGNvbnN0IHNvdXJjZSA9IG5ldyBSZW1vdGVTb3VyY2UoY2xpZW50LCBoZWFkZXJzLCBtYXhSYW5nZXMsIGFsbG93RnVsbEZpbGUpO1xuICByZXR1cm4gbWF5YmVXcmFwSW5CbG9ja2VkU291cmNlKHNvdXJjZSwgYmxvY2tPcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VDdXN0b21Tb3VyY2UoY2xpZW50LCB7IGhlYWRlcnMgPSB7fSwgbWF4UmFuZ2VzID0gMCwgYWxsb3dGdWxsRmlsZSA9IGZhbHNlLCAuLi5ibG9ja09wdGlvbnMgfSA9IHt9KSB7XG4gIGNvbnN0IHNvdXJjZSA9IG5ldyBSZW1vdGVTb3VyY2UoY2xpZW50LCBoZWFkZXJzLCBtYXhSYW5nZXMsIGFsbG93RnVsbEZpbGUpO1xuICByZXR1cm4gbWF5YmVXcmFwSW5CbG9ja2VkU291cmNlKHNvdXJjZSwgYmxvY2tPcHRpb25zKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VSZW1vdGVTb3VyY2UodXJsLCB7IGZvcmNlWEhSID0gZmFsc2UsIC4uLmNsaWVudE9wdGlvbnMgfSA9IHt9KSB7XG4gIGlmICh0eXBlb2YgZmV0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWZvcmNlWEhSKSB7XG4gICAgcmV0dXJuIG1ha2VGZXRjaFNvdXJjZSh1cmwsIGNsaWVudE9wdGlvbnMpO1xuICB9XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG1ha2VYSFJTb3VyY2UodXJsLCBjbGllbnRPcHRpb25zKTtcbiAgfVxuICByZXR1cm4gbWFrZUh0dHBTb3VyY2UodXJsLCBjbGllbnRPcHRpb25zKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/remote.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/geotiff/dist-module/utils.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   AggregateError: () => (/* binding */ AggregateError),\n/* harmony export */   CustomAggregateError: () => (/* binding */ CustomAggregateError),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   chunk: () => (/* binding */ chunk),\n/* harmony export */   endsWith: () => (/* binding */ endsWith),\n/* harmony export */   forEach: () => (/* binding */ forEach),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   parseContentRange: () => (/* binding */ parseContentRange),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   times: () => (/* binding */ times),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toArrayRecursively: () => (/* binding */ toArrayRecursively),\n/* harmony export */   wait: () => (/* binding */ wait),\n/* harmony export */   zip: () => (/* binding */ zip)\n/* harmony export */ });\nfunction assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nfunction endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nfunction forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nfunction invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nfunction range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nfunction times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nfunction toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nfunction toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nfunction parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nasync function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nfunction zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nclass AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nclass CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nconst AggregateError = CustomAggregateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxVQUFVLFNBQVM7QUFDbkIsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLFVBQVUsU0FBUztBQUNuQixrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNodW5rKGl0ZXJhYmxlLCBsZW5ndGgpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBjb25zdCBsZW5ndGhPZkl0ZXJhYmxlID0gaXRlcmFibGUubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aE9mSXRlcmFibGU7IGkgKz0gbGVuZ3RoKSB7XG4gICAgY29uc3QgY2h1bmtlZCA9IFtdO1xuICAgIGZvciAobGV0IGNpID0gaTsgY2kgPCBpICsgbGVuZ3RoOyBjaSsrKSB7XG4gICAgICBjaHVua2VkLnB1c2goaXRlcmFibGVbY2ldKTtcbiAgICB9XG4gICAgcmVzdWx0cy5wdXNoKGNodW5rZWQpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCBleHBlY3RlZEVuZGluZykge1xuICBpZiAoc3RyaW5nLmxlbmd0aCA8IGV4cGVjdGVkRW5kaW5nLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhY3R1YWxFbmRpbmcgPSBzdHJpbmcuc3Vic3RyKHN0cmluZy5sZW5ndGggLSBleHBlY3RlZEVuZGluZy5sZW5ndGgpO1xuICByZXR1cm4gYWN0dWFsRW5kaW5nID09PSBleHBlY3RlZEVuZGluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2goaXRlcmFibGUsIGZ1bmMpIHtcbiAgY29uc3QgeyBsZW5ndGggfSA9IGl0ZXJhYmxlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgZnVuYyhpdGVyYWJsZVtpXSwgaSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvbGRPYmopIHtcbiAgY29uc3QgbmV3T2JqID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9sZE9iaikge1xuICAgIGlmIChvbGRPYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvbGRPYmpba2V5XTtcbiAgICAgIG5ld09ialt2YWx1ZV0gPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdPYmo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5nZShuKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICByZXN1bHRzLnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lcyhudW1UaW1lcywgZnVuYykge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVGltZXM7IGkrKykge1xuICAgIHJlc3VsdHMucHVzaChmdW5jKGkpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXkoaXRlcmFibGUpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBjb25zdCB7IGxlbmd0aCB9ID0gaXRlcmFibGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRzLnB1c2goaXRlcmFibGVbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheVJlY3Vyc2l2ZWx5KGlucHV0KSB7XG4gIGlmIChpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gdG9BcnJheShpbnB1dCkubWFwKHRvQXJyYXlSZWN1cnNpdmVseSk7XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufVxuXG4vLyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWNhZGVtaWEtZGUtY29kaWdvL3BhcnNlLWNvbnRlbnQtcmFuZ2UtaGVhZGVyL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb250ZW50UmFuZ2UoaGVhZGVyVmFsdWUpIHtcbiAgaWYgKCFoZWFkZXJWYWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBoZWFkZXJWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGNvbnN0IHBhcnNlSW50ID0gKG51bWJlcikgPT4gTnVtYmVyLnBhcnNlSW50KG51bWJlciwgMTApO1xuXG4gIC8vIENoZWNrIGZvciBwcmVzZW5jZSBvZiB1bml0XG4gIGxldCBtYXRjaGVzID0gaGVhZGVyVmFsdWUubWF0Y2goL14oXFx3KikgLyk7XG4gIGNvbnN0IHVuaXQgPSBtYXRjaGVzICYmIG1hdGNoZXNbMV07XG5cbiAgLy8gY2hlY2sgZm9yIHN0YXJ0LWVuZC9zaXplIGhlYWRlciBmb3JtYXRcbiAgbWF0Y2hlcyA9IGhlYWRlclZhbHVlLm1hdGNoKC8oXFxkKyktKFxcZCspXFwvKFxcZCt8XFwqKS8pO1xuICBpZiAobWF0Y2hlcykge1xuICAgIHJldHVybiB7XG4gICAgICB1bml0LFxuICAgICAgZmlyc3Q6IHBhcnNlSW50KG1hdGNoZXNbMV0pLFxuICAgICAgbGFzdDogcGFyc2VJbnQobWF0Y2hlc1syXSksXG4gICAgICBsZW5ndGg6IG1hdGNoZXNbM10gPT09ICcqJyA/IG51bGwgOiBwYXJzZUludChtYXRjaGVzWzNdKSxcbiAgICB9O1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIHNpemUgaGVhZGVyIGZvcm1hdFxuICBtYXRjaGVzID0gaGVhZGVyVmFsdWUubWF0Y2goLyhcXGQrfFxcKikvKTtcbiAgaWYgKG1hdGNoZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdCxcbiAgICAgIGZpcnN0OiBudWxsLFxuICAgICAgbGFzdDogbnVsbCxcbiAgICAgIGxlbmd0aDogbWF0Y2hlc1sxXSA9PT0gJyonID8gbnVsbCA6IHBhcnNlSW50KG1hdGNoZXNbMV0pLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLypcbiAqIFByb21pc2lmaWVkIHdyYXBwZXIgYXJvdW5kICdzZXRUaW1lb3V0JyB0byBhbGxvdyAnYXdhaXQnXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0KG1pbGxpc2Vjb25kcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbWlsbGlzZWNvbmRzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB6aXAoYSwgYikge1xuICBjb25zdCBBID0gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBBcnJheS5mcm9tKGEpO1xuICBjb25zdCBCID0gQXJyYXkuaXNBcnJheShiKSA/IGIgOiBBcnJheS5mcm9tKGIpO1xuICByZXR1cm4gQS5tYXAoKGssIGkpID0+IFtrLCBCW2ldXSk7XG59XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yXG5leHBvcnQgY2xhc3MgQWJvcnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgLy8gUGFzcyByZW1haW5pbmcgYXJndW1lbnRzIChpbmNsdWRpbmcgdmVuZG9yIHNwZWNpZmljIG9uZXMpIHRvIHBhcmVudCBjb25zdHJ1Y3RvclxuICAgIHN1cGVyKHBhcmFtcyk7XG5cbiAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93biAob25seSBhdmFpbGFibGUgb24gVjgpXG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBBYm9ydEVycm9yKTtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSAnQWJvcnRFcnJvcic7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEN1c3RvbUFnZ3JlZ2F0ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlcnJvcnMsIG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9ICdBZ2dyZWdhdGVFcnJvcic7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEFnZ3JlZ2F0ZUVycm9yID0gQ3VzdG9tQWdncmVnYXRlRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/worker/decoder.js":
/*!************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/worker/decoder.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var web_worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! web-worker */ \"(ssr)/./node_modules/web-worker/src/node/index.js\");\n\n        \n        function create() {\n          const source = \"function A(A,e,t,i,r,I,g){try{var n=A[I](g),a=n.value}catch(A){return void t(A)}n.done?e(a):Promise.resolve(a).then(i,r)}function e(e){return function(){var t=this,i=arguments;return new Promise((function(r,I){var g=e.apply(t,i);function n(e){A(g,r,I,n,a,\\\"next\\\",e)}function a(e){A(g,r,I,n,a,\\\"throw\\\",e)}n(void 0)}))}}function t(A){return t=\\\"function\\\"==typeof Symbol&&\\\"symbol\\\"==typeof Symbol.iterator?function(A){return typeof A}:function(A){return A&&\\\"function\\\"==typeof Symbol&&A.constructor===Symbol&&A!==Symbol.prototype?\\\"symbol\\\":typeof A},t(A)}var i={exports:{}};!function(A){var e=function(A){var e,i=Object.prototype,r=i.hasOwnProperty,I=\\\"function\\\"==typeof Symbol?Symbol:{},g=I.iterator||\\\"@@iterator\\\",n=I.asyncIterator||\\\"@@asyncIterator\\\",a=I.toStringTag||\\\"@@toStringTag\\\";function o(A,e,t){return Object.defineProperty(A,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),A[e]}try{o({},\\\"\\\")}catch(A){o=function(A,e,t){return A[e]=t}}function B(A,e,t,i){var r=e&&e.prototype instanceof h?e:h,I=Object.create(r.prototype),g=new S(i||[]);return I._invoke=function(A,e,t){var i=Q;return function(r,I){if(i===s)throw new Error(\\\"Generator is already running\\\");if(i===f){if(\\\"throw\\\"===r)throw I;return R()}for(t.method=r,t.arg=I;;){var g=t.delegate;if(g){var n=m(g,t);if(n){if(n===c)continue;return n}}if(\\\"next\\\"===t.method)t.sent=t._sent=t.arg;else if(\\\"throw\\\"===t.method){if(i===Q)throw i=f,t.arg;t.dispatchException(t.arg)}else\\\"return\\\"===t.method&&t.abrupt(\\\"return\\\",t.arg);i=s;var a=C(A,e,t);if(\\\"normal\\\"===a.type){if(i=t.done?f:E,a.arg===c)continue;return{value:a.arg,done:t.done}}\\\"throw\\\"===a.type&&(i=f,t.method=\\\"throw\\\",t.arg=a.arg)}}}(A,t,g),I}function C(A,e,t){try{return{type:\\\"normal\\\",arg:A.call(e,t)}}catch(A){return{type:\\\"throw\\\",arg:A}}}A.wrap=B;var Q=\\\"suspendedStart\\\",E=\\\"suspendedYield\\\",s=\\\"executing\\\",f=\\\"completed\\\",c={};function h(){}function l(){}function u(){}var w={};o(w,g,(function(){return this}));var d=Object.getPrototypeOf,D=d&&d(d(v([])));D&&D!==i&&r.call(D,g)&&(w=D);var y=u.prototype=h.prototype=Object.create(w);function k(A){[\\\"next\\\",\\\"throw\\\",\\\"return\\\"].forEach((function(e){o(A,e,(function(A){return this._invoke(e,A)}))}))}function p(A,e){function i(I,g,n,a){var o=C(A[I],A,g);if(\\\"throw\\\"!==o.type){var B=o.arg,Q=B.value;return Q&&\\\"object\\\"===t(Q)&&r.call(Q,\\\"__await\\\")?e.resolve(Q.__await).then((function(A){i(\\\"next\\\",A,n,a)}),(function(A){i(\\\"throw\\\",A,n,a)})):e.resolve(Q).then((function(A){B.value=A,n(B)}),(function(A){return i(\\\"throw\\\",A,n,a)}))}a(o.arg)}var I;this._invoke=function(A,t){function r(){return new e((function(e,r){i(A,t,e,r)}))}return I=I?I.then(r,r):r()}}function m(A,t){var i=A.iterator[t.method];if(i===e){if(t.delegate=null,\\\"throw\\\"===t.method){if(A.iterator.return&&(t.method=\\\"return\\\",t.arg=e,m(A,t),\\\"throw\\\"===t.method))return c;t.method=\\\"throw\\\",t.arg=new TypeError(\\\"The iterator does not provide a 'throw' method\\\")}return c}var r=C(i,A.iterator,t.arg);if(\\\"throw\\\"===r.type)return t.method=\\\"throw\\\",t.arg=r.arg,t.delegate=null,c;var I=r.arg;return I?I.done?(t[A.resultName]=I.value,t.next=A.nextLoc,\\\"return\\\"!==t.method&&(t.method=\\\"next\\\",t.arg=e),t.delegate=null,c):I:(t.method=\\\"throw\\\",t.arg=new TypeError(\\\"iterator result is not an object\\\"),t.delegate=null,c)}function G(A){var e={tryLoc:A[0]};1 in A&&(e.catchLoc=A[1]),2 in A&&(e.finallyLoc=A[2],e.afterLoc=A[3]),this.tryEntries.push(e)}function F(A){var e=A.completion||{};e.type=\\\"normal\\\",delete e.arg,A.completion=e}function S(A){this.tryEntries=[{tryLoc:\\\"root\\\"}],A.forEach(G,this),this.reset(!0)}function v(A){if(A){var t=A[g];if(t)return t.call(A);if(\\\"function\\\"==typeof A.next)return A;if(!isNaN(A.length)){var i=-1,I=function t(){for(;++i<A.length;)if(r.call(A,i))return t.value=A[i],t.done=!1,t;return t.value=e,t.done=!0,t};return I.next=I}}return{next:R}}function R(){return{value:e,done:!0}}return l.prototype=u,o(y,\\\"constructor\\\",u),o(u,\\\"constructor\\\",l),l.displayName=o(u,a,\\\"GeneratorFunction\\\"),A.isGeneratorFunction=function(A){var e=\\\"function\\\"==typeof A&&A.constructor;return!!e&&(e===l||\\\"GeneratorFunction\\\"===(e.displayName||e.name))},A.mark=function(A){return Object.setPrototypeOf?Object.setPrototypeOf(A,u):(A.__proto__=u,o(A,a,\\\"GeneratorFunction\\\")),A.prototype=Object.create(y),A},A.awrap=function(A){return{__await:A}},k(p.prototype),o(p.prototype,n,(function(){return this})),A.AsyncIterator=p,A.async=function(e,t,i,r,I){void 0===I&&(I=Promise);var g=new p(B(e,t,i,r),I);return A.isGeneratorFunction(t)?g:g.next().then((function(A){return A.done?A.value:g.next()}))},k(y),o(y,a,\\\"Generator\\\"),o(y,g,(function(){return this})),o(y,\\\"toString\\\",(function(){return\\\"[object Generator]\\\"})),A.keys=function(A){var e=[];for(var t in A)e.push(t);return e.reverse(),function t(){for(;e.length;){var i=e.pop();if(i in A)return t.value=i,t.done=!1,t}return t.done=!0,t}},A.values=v,S.prototype={constructor:S,reset:function(A){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method=\\\"next\\\",this.arg=e,this.tryEntries.forEach(F),!A)for(var t in this)\\\"t\\\"===t.charAt(0)&&r.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=e)},stop:function(){this.done=!0;var A=this.tryEntries[0].completion;if(\\\"throw\\\"===A.type)throw A.arg;return this.rval},dispatchException:function(A){if(this.done)throw A;var t=this;function i(i,r){return n.type=\\\"throw\\\",n.arg=A,t.next=i,r&&(t.method=\\\"next\\\",t.arg=e),!!r}for(var I=this.tryEntries.length-1;I>=0;--I){var g=this.tryEntries[I],n=g.completion;if(\\\"root\\\"===g.tryLoc)return i(\\\"end\\\");if(g.tryLoc<=this.prev){var a=r.call(g,\\\"catchLoc\\\"),o=r.call(g,\\\"finallyLoc\\\");if(a&&o){if(this.prev<g.catchLoc)return i(g.catchLoc,!0);if(this.prev<g.finallyLoc)return i(g.finallyLoc)}else if(a){if(this.prev<g.catchLoc)return i(g.catchLoc,!0)}else{if(!o)throw new Error(\\\"try statement without catch or finally\\\");if(this.prev<g.finallyLoc)return i(g.finallyLoc)}}}},abrupt:function(A,e){for(var t=this.tryEntries.length-1;t>=0;--t){var i=this.tryEntries[t];if(i.tryLoc<=this.prev&&r.call(i,\\\"finallyLoc\\\")&&this.prev<i.finallyLoc){var I=i;break}}I&&(\\\"break\\\"===A||\\\"continue\\\"===A)&&I.tryLoc<=e&&e<=I.finallyLoc&&(I=null);var g=I?I.completion:{};return g.type=A,g.arg=e,I?(this.method=\\\"next\\\",this.next=I.finallyLoc,c):this.complete(g)},complete:function(A,e){if(\\\"throw\\\"===A.type)throw A.arg;return\\\"break\\\"===A.type||\\\"continue\\\"===A.type?this.next=A.arg:\\\"return\\\"===A.type?(this.rval=this.arg=A.arg,this.method=\\\"return\\\",this.next=\\\"end\\\"):\\\"normal\\\"===A.type&&e&&(this.next=e),c},finish:function(A){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===A)return this.complete(t.completion,t.afterLoc),F(t),c}},catch:function(A){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===A){var i=t.completion;if(\\\"throw\\\"===i.type){var r=i.arg;F(t)}return r}}throw new Error(\\\"illegal catch attempt\\\")},delegateYield:function(A,t,i){return this.delegate={iterator:v(A),resultName:t,nextLoc:i},\\\"next\\\"===this.method&&(this.arg=e),c}},A}(A.exports);try{regeneratorRuntime=e}catch(A){\\\"object\\\"===(\\\"undefined\\\"==typeof globalThis?\\\"undefined\\\":t(globalThis))?globalThis.regeneratorRuntime=e:Function(\\\"r\\\",\\\"regeneratorRuntime = r\\\")(e)}}(i);var r=i.exports,I=new Map;function g(A,e){Array.isArray(A)||(A=[A]),A.forEach((function(A){return I.set(A,e)}))}function n(A){return a.apply(this,arguments)}function a(){return(a=e(r.mark((function A(e){var t,i;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:if(t=I.get(e.Compression)){A.next=3;break}throw new Error(\\\"Unknown compression method identifier: \\\".concat(e.Compression));case 3:return A.next=5,t();case 5:return i=A.sent,A.abrupt(\\\"return\\\",new i(e));case 7:case\\\"end\\\":return A.stop()}}),A)})))).apply(this,arguments)}g([void 0,1],(function(){return Promise.resolve().then((function(){return y})).then((function(A){return A.default}))})),g(5,(function(){return Promise.resolve().then((function(){return F})).then((function(A){return A.default}))})),g(6,(function(){throw new Error(\\\"old style JPEG compression is not supported.\\\")})),g(7,(function(){return Promise.resolve().then((function(){return N})).then((function(A){return A.default}))})),g([8,32946],(function(){return Promise.resolve().then((function(){return OA})).then((function(A){return A.default}))})),g(32773,(function(){return Promise.resolve().then((function(){return _A})).then((function(A){return A.default}))})),g(34887,(function(){return Promise.resolve().then((function(){return le})).then(function(){var A=e(r.mark((function A(e){return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return A.next=2,e.zstd.init();case 2:return A.abrupt(\\\"return\\\",e);case 3:case\\\"end\\\":return A.stop()}}),A)})));return function(e){return A.apply(this,arguments)}}()).then((function(A){return A.default}))})),g(50001,(function(){return Promise.resolve().then((function(){return de})).then((function(A){return A.default}))}));var o=globalThis;function B(A,e){if(!(A instanceof e))throw new TypeError(\\\"Cannot call a class as a function\\\")}function C(A,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,\\\"value\\\"in i&&(i.writable=!0),Object.defineProperty(A,i.key,i)}}function Q(A,e,t){return e&&C(A.prototype,e),t&&C(A,t),A}function E(A,e){return E=Object.setPrototypeOf||function(A,e){return A.__proto__=e,A},E(A,e)}function s(A,e){if(\\\"function\\\"!=typeof e&&null!==e)throw new TypeError(\\\"Super expression must either be null or a function\\\");A.prototype=Object.create(e&&e.prototype,{constructor:{value:A,writable:!0,configurable:!0}}),e&&E(A,e)}function f(A,e){if(e&&(\\\"object\\\"===t(e)||\\\"function\\\"==typeof e))return e;if(void 0!==e)throw new TypeError(\\\"Derived constructors may only return object or undefined\\\");return function(A){if(void 0===A)throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\");return A}(A)}function c(A){return c=Object.setPrototypeOf?Object.getPrototypeOf:function(A){return A.__proto__||Object.getPrototypeOf(A)},c(A)}function h(A,e){var t=A.length-e,i=0;do{for(var r=e;r>0;r--)A[i+e]+=A[i],i++;t-=e}while(t>0)}function l(A,e,t){for(var i=0,r=A.length,I=r/t;r>e;){for(var g=e;g>0;--g)A[i+e]+=A[i],++i;r-=e}for(var n=A.slice(),a=0;a<I;++a)for(var o=0;o<t;++o)A[t*a+o]=n[(t-o-1)*I+a]}function u(A,e,t,i,r,I){if(!e||1===e)return A;for(var g=0;g<r.length;++g){if(r[g]%8!=0)throw new Error(\\\"When decoding with predictor, only multiple of 8 bits are supported.\\\");if(r[g]!==r[0])throw new Error(\\\"When decoding with predictor, all samples must have the same size.\\\")}for(var n=r[0]/8,a=2===I?1:r.length,o=0;o<i&&!(o*a*t*n>=A.byteLength);++o){var B=void 0;if(2===e){switch(r[0]){case 8:B=new Uint8Array(A,o*a*t*n,a*t*n);break;case 16:B=new Uint16Array(A,o*a*t*n,a*t*n/2);break;case 32:B=new Uint32Array(A,o*a*t*n,a*t*n/4);break;default:throw new Error(\\\"Predictor 2 not allowed with \\\".concat(r[0],\\\" bits per sample.\\\"))}h(B,a)}else 3===e&&l(B=new Uint8Array(A,o*a*t*n,a*t*n),a,n)}return A}o.addEventListener(\\\"message\\\",function(){var A=e(r.mark((function A(e){var t,i,I,g,a,B;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return t=e.data,i=t.id,I=t.fileDirectory,g=t.buffer,A.next=3,n(I);case 3:return a=A.sent,A.next=6,a.decode(I,g);case 6:B=A.sent,o.postMessage({decoded:B,id:i},[B]);case 8:case\\\"end\\\":return A.stop()}}),A)})));return function(e){return A.apply(this,arguments)}}());var w=function(){function A(){B(this,A)}var t;return Q(A,[{key:\\\"decode\\\",value:(t=e(r.mark((function A(e,t){var i,I,g,n,a;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return A.next=2,this.decodeBlock(t);case 2:if(i=A.sent,1===(I=e.Predictor||1)){A.next=9;break}return g=!e.StripOffsets,n=g?e.TileWidth:e.ImageWidth,a=g?e.TileLength:e.RowsPerStrip||e.ImageLength,A.abrupt(\\\"return\\\",u(i,I,n,a,e.BitsPerSample,e.PlanarConfiguration));case 9:return A.abrupt(\\\"return\\\",i);case 10:case\\\"end\\\":return A.stop()}}),A,this)}))),function(A,e){return t.apply(this,arguments)})}]),A}();function d(A){var e=function(){if(\\\"undefined\\\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\\\"function\\\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var D=function(A){s(t,w);var e=d(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:\\\"decodeBlock\\\",value:function(A){return A}}]),t}(),y=Object.freeze({__proto__:null,default:D});function k(A){var e=function(){if(\\\"undefined\\\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\\\"function\\\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}function p(A,e){for(var t=e.length-1;t>=0;t--)A.push(e[t]);return A}function m(A){for(var e=new Uint16Array(4093),t=new Uint8Array(4093),i=0;i<=257;i++)e[i]=4096,t[i]=i;var r=258,I=9,g=0;function n(){r=258,I=9}function a(A){var e=function(A,e,t){var i=e%8,r=Math.floor(e/8),I=8-i,g=e+t-8*(r+1),n=8*(r+2)-(e+t),a=8*(r+2)-e;if(n=Math.max(0,n),r>=A.length)return console.warn(\\\"ran off the end of the buffer before finding EOI_CODE (end on input code)\\\"),257;var o=A[r]&Math.pow(2,8-i)-1,B=o<<=t-I;if(r+1<A.length){var C=A[r+1]>>>n;B+=C<<=Math.max(0,t-a)}if(g>8&&r+2<A.length){var Q=8*(r+3)-(e+t);B+=A[r+2]>>>Q}return B}(A,g,I);return g+=I,e}function o(A,i){return t[r]=i,e[r]=A,++r-1}function B(A){for(var i=[],r=A;4096!==r;r=e[r])i.push(t[r]);return i}var C=[];n();for(var Q,E=new Uint8Array(A),s=a(E);257!==s;){if(256===s){for(n(),s=a(E);256===s;)s=a(E);if(257===s)break;if(s>256)throw new Error(\\\"corrupted code at scanline \\\".concat(s));p(C,B(s)),Q=s}else if(s<r){var f=B(s);p(C,f),o(Q,f[f.length-1]),Q=s}else{var c=B(Q);if(!c)throw new Error(\\\"Bogus entry. Not in dictionary, \\\".concat(Q,\\\" / \\\").concat(r,\\\", position: \\\").concat(g));p(C,c),C.push(c[c.length-1]),o(Q,c[c.length-1]),Q=s}r+1>=Math.pow(2,I)&&(12===I?Q=void 0:I++),s=a(E)}return new Uint8Array(C)}var G=function(A){s(t,w);var e=k(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:\\\"decodeBlock\\\",value:function(A){return m(A).buffer}}]),t}(),F=Object.freeze({__proto__:null,default:G});function S(A){var e=function(){if(\\\"undefined\\\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\\\"function\\\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var v=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]);function R(A,e){for(var t=0,i=[],r=16;r>0&&!A[r-1];)--r;i.push({children:[],index:0});for(var I,g=i[0],n=0;n<r;n++){for(var a=0;a<A[n];a++){for((g=i.pop()).children[g.index]=e[t];g.index>0;)g=i.pop();for(g.index++,i.push(g);i.length<=n;)i.push(I={children:[],index:0}),g.children[g.index]=I.children,g=I;t++}n+1<r&&(i.push(I={children:[],index:0}),g.children[g.index]=I.children,g=I)}return i[0].children}function U(A,e,i,r,I,g,n,a,o){var B=i.mcusPerLine,C=i.progressive,Q=e,E=e,s=0,f=0;function c(){if(f>0)return f--,s>>f&1;if(255===(s=A[E++])){var e=A[E++];if(e)throw new Error(\\\"unexpected marker: \\\".concat((s<<8|e).toString(16)))}return f=7,s>>>7}function h(A){for(var e,i=A;null!==(e=c());){if(\\\"number\\\"==typeof(i=i[e]))return i;if(\\\"object\\\"!==t(i))throw new Error(\\\"invalid huffman sequence\\\")}return null}function l(A){for(var e=A,t=0;e>0;){var i=c();if(null===i)return;t=t<<1|i,--e}return t}function u(A){var e=l(A);return e>=1<<A-1?e:e+(-1<<A)+1}var w=0;var d,D=0;function y(A,e,t,i,r){var I=t%B,g=(t/B|0)*A.v+i,n=I*A.h+r;e(A,A.blocks[g][n])}function k(A,e,t){var i=t/A.blocksPerLine|0,r=t%A.blocksPerLine;e(A,A.blocks[i][r])}var p,m,G,F,S,R,U=r.length;R=C?0===g?0===a?function(A,e){var t=h(A.huffmanTableDC),i=0===t?0:u(t)<<o;A.pred+=i,e[0]=A.pred}:function(A,e){e[0]|=c()<<o}:0===a?function(A,e){if(w>0)w--;else for(var t=g,i=n;t<=i;){var r=h(A.huffmanTableAC),I=15&r,a=r>>4;if(0===I){if(a<15){w=l(a)+(1<<a)-1;break}t+=16}else e[v[t+=a]]=u(I)*(1<<o),t++}}:function(A,e){for(var t=g,i=n,r=0;t<=i;){var I=v[t],a=e[I]<0?-1:1;switch(D){case 0:var B=h(A.huffmanTableAC),C=15&B;if(r=B>>4,0===C)r<15?(w=l(r)+(1<<r),D=4):(r=16,D=1);else{if(1!==C)throw new Error(\\\"invalid ACn encoding\\\");d=u(C),D=r?2:3}continue;case 1:case 2:e[I]?e[I]+=(c()<<o)*a:0==--r&&(D=2===D?3:0);break;case 3:e[I]?e[I]+=(c()<<o)*a:(e[I]=d<<o,D=0);break;case 4:e[I]&&(e[I]+=(c()<<o)*a)}t++}4===D&&0==--w&&(D=0)}:function(A,e){var t=h(A.huffmanTableDC),i=0===t?0:u(t);A.pred+=i,e[0]=A.pred;for(var r=1;r<64;){var I=h(A.huffmanTableAC),g=15&I,n=I>>4;if(0===g){if(n<15)break;r+=16}else e[v[r+=n]]=u(g),r++}};var L,b,M=0;b=1===U?r[0].blocksPerLine*r[0].blocksPerColumn:B*i.mcusPerColumn;for(var N=I||b;M<b;){for(m=0;m<U;m++)r[m].pred=0;if(w=0,1===U)for(p=r[0],S=0;S<N;S++)k(p,R,M),M++;else for(S=0;S<N;S++){for(m=0;m<U;m++){var x=p=r[m],J=x.h,q=x.v;for(G=0;G<q;G++)for(F=0;F<J;F++)y(p,R,M,G,F)}if(++M===b)break}if(f=0,(L=A[E]<<8|A[E+1])<65280)throw new Error(\\\"marker was not found\\\");if(!(L>=65488&&L<=65495))break;E+=2}return E-Q}function L(A,e){var t=[],i=e.blocksPerLine,r=e.blocksPerColumn,I=i<<3,g=new Int32Array(64),n=new Uint8Array(64);function a(A,t,i){var r,I,g,n,a,o,B,C,Q,E,s=e.quantizationTable,f=i;for(E=0;E<64;E++)f[E]=A[E]*s[E];for(E=0;E<8;++E){var c=8*E;0!==f[1+c]||0!==f[2+c]||0!==f[3+c]||0!==f[4+c]||0!==f[5+c]||0!==f[6+c]||0!==f[7+c]?(r=5793*f[0+c]+128>>8,I=5793*f[4+c]+128>>8,g=f[2+c],n=f[6+c],a=2896*(f[1+c]-f[7+c])+128>>8,C=2896*(f[1+c]+f[7+c])+128>>8,o=f[3+c]<<4,Q=r-I+1>>1,r=r+I+1>>1,I=Q,Q=3784*g+1567*n+128>>8,g=1567*g-3784*n+128>>8,n=Q,Q=a-(B=f[5+c]<<4)+1>>1,a=a+B+1>>1,B=Q,Q=C+o+1>>1,o=C-o+1>>1,C=Q,Q=r-n+1>>1,r=r+n+1>>1,n=Q,Q=I-g+1>>1,I=I+g+1>>1,g=Q,Q=2276*a+3406*C+2048>>12,a=3406*a-2276*C+2048>>12,C=Q,Q=799*o+4017*B+2048>>12,o=4017*o-799*B+2048>>12,B=Q,f[0+c]=r+C,f[7+c]=r-C,f[1+c]=I+B,f[6+c]=I-B,f[2+c]=g+o,f[5+c]=g-o,f[3+c]=n+a,f[4+c]=n-a):(Q=5793*f[0+c]+512>>10,f[0+c]=Q,f[1+c]=Q,f[2+c]=Q,f[3+c]=Q,f[4+c]=Q,f[5+c]=Q,f[6+c]=Q,f[7+c]=Q)}for(E=0;E<8;++E){var h=E;0!==f[8+h]||0!==f[16+h]||0!==f[24+h]||0!==f[32+h]||0!==f[40+h]||0!==f[48+h]||0!==f[56+h]?(r=5793*f[0+h]+2048>>12,I=5793*f[32+h]+2048>>12,g=f[16+h],n=f[48+h],a=2896*(f[8+h]-f[56+h])+2048>>12,C=2896*(f[8+h]+f[56+h])+2048>>12,o=f[24+h],Q=r-I+1>>1,r=r+I+1>>1,I=Q,Q=3784*g+1567*n+2048>>12,g=1567*g-3784*n+2048>>12,n=Q,Q=a-(B=f[40+h])+1>>1,a=a+B+1>>1,B=Q,Q=C+o+1>>1,o=C-o+1>>1,C=Q,Q=r-n+1>>1,r=r+n+1>>1,n=Q,Q=I-g+1>>1,I=I+g+1>>1,g=Q,Q=2276*a+3406*C+2048>>12,a=3406*a-2276*C+2048>>12,C=Q,Q=799*o+4017*B+2048>>12,o=4017*o-799*B+2048>>12,B=Q,f[0+h]=r+C,f[56+h]=r-C,f[8+h]=I+B,f[48+h]=I-B,f[16+h]=g+o,f[40+h]=g-o,f[24+h]=n+a,f[32+h]=n-a):(Q=5793*i[E+0]+8192>>14,f[0+h]=Q,f[8+h]=Q,f[16+h]=Q,f[24+h]=Q,f[32+h]=Q,f[40+h]=Q,f[48+h]=Q,f[56+h]=Q)}for(E=0;E<64;++E){var l=128+(f[E]+8>>4);t[E]=l<0?0:l>255?255:l}}for(var o=0;o<r;o++){for(var B=o<<3,C=0;C<8;C++)t.push(new Uint8Array(I));for(var Q=0;Q<i;Q++){a(e.blocks[o][Q],n,g);for(var E=0,s=Q<<3,f=0;f<8;f++)for(var c=t[B+f],h=0;h<8;h++)c[s+h]=n[E++]}}return t}var b=function(){function A(){B(this,A),this.jfif=null,this.adobe=null,this.quantizationTables=[],this.huffmanTablesAC=[],this.huffmanTablesDC=[],this.resetFrames()}return Q(A,[{key:\\\"resetFrames\\\",value:function(){this.frames=[]}},{key:\\\"parse\\\",value:function(A){var e=0;function t(){var t=A[e]<<8|A[e+1];return e+=2,t}function i(A){var e,t,i=0,r=0;for(t in A.components)A.components.hasOwnProperty(t)&&(i<(e=A.components[t]).h&&(i=e.h),r<e.v&&(r=e.v));var I=Math.ceil(A.samplesPerLine/8/i),g=Math.ceil(A.scanLines/8/r);for(t in A.components)if(A.components.hasOwnProperty(t)){e=A.components[t];for(var n=Math.ceil(Math.ceil(A.samplesPerLine/8)*e.h/i),a=Math.ceil(Math.ceil(A.scanLines/8)*e.v/r),o=I*e.h,B=g*e.v,C=[],Q=0;Q<B;Q++){for(var E=[],s=0;s<o;s++)E.push(new Int32Array(64));C.push(E)}e.blocksPerLine=n,e.blocksPerColumn=a,e.blocks=C}A.maxH=i,A.maxV=r,A.mcusPerLine=I,A.mcusPerColumn=g}var r,I,g=t();if(65496!==g)throw new Error(\\\"SOI not found\\\");for(g=t();65497!==g;){switch(g){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var n=(r=void 0,I=void 0,r=t(),I=A.subarray(e,e+r-2),e+=I.length,I);65504===g&&74===n[0]&&70===n[1]&&73===n[2]&&70===n[3]&&0===n[4]&&(this.jfif={version:{major:n[5],minor:n[6]},densityUnits:n[7],xDensity:n[8]<<8|n[9],yDensity:n[10]<<8|n[11],thumbWidth:n[12],thumbHeight:n[13],thumbData:n.subarray(14,14+3*n[12]*n[13])}),65518===g&&65===n[0]&&100===n[1]&&111===n[2]&&98===n[3]&&101===n[4]&&0===n[5]&&(this.adobe={version:n[6],flags0:n[7]<<8|n[8],flags1:n[9]<<8|n[10],transformCode:n[11]});break;case 65499:for(var a=t()+e-2;e<a;){var o=A[e++],B=new Int32Array(64);if(o>>4==0)for(var C=0;C<64;C++){B[v[C]]=A[e++]}else{if(o>>4!=1)throw new Error(\\\"DQT: invalid table spec\\\");for(var Q=0;Q<64;Q++){B[v[Q]]=t()}}this.quantizationTables[15&o]=B}break;case 65472:case 65473:case 65474:t();for(var E={extended:65473===g,progressive:65474===g,precision:A[e++],scanLines:t(),samplesPerLine:t(),components:{},componentsOrder:[]},s=A[e++],f=void 0,c=0;c<s;c++){f=A[e];var h=A[e+1]>>4,l=15&A[e+1],u=A[e+2];E.componentsOrder.push(f),E.components[f]={h:h,v:l,quantizationIdx:u},e+=3}i(E),this.frames.push(E);break;case 65476:for(var w=t(),d=2;d<w;){for(var D=A[e++],y=new Uint8Array(16),k=0,p=0;p<16;p++,e++)y[p]=A[e],k+=y[p];for(var m=new Uint8Array(k),G=0;G<k;G++,e++)m[G]=A[e];d+=17+k,D>>4==0?this.huffmanTablesDC[15&D]=R(y,m):this.huffmanTablesAC[15&D]=R(y,m)}break;case 65501:t(),this.resetInterval=t();break;case 65498:t();for(var F=A[e++],S=[],L=this.frames[0],b=0;b<F;b++){var M=L.components[A[e++]],N=A[e++];M.huffmanTableDC=this.huffmanTablesDC[N>>4],M.huffmanTableAC=this.huffmanTablesAC[15&N],S.push(M)}var x=A[e++],J=A[e++],q=A[e++],Y=U(A,e,L,S,this.resetInterval,x,J,q>>4,15&q);e+=Y;break;case 65535:255!==A[e]&&e--;break;default:if(255===A[e-3]&&A[e-2]>=192&&A[e-2]<=254){e-=3;break}throw new Error(\\\"unknown JPEG marker \\\".concat(g.toString(16)))}g=t()}}},{key:\\\"getResult\\\",value:function(){var A=this.frames;if(0===this.frames.length)throw new Error(\\\"no frames were decoded\\\");this.frames.length>1&&console.warn(\\\"more than one frame is not supported\\\");for(var e=0;e<this.frames.length;e++)for(var t=this.frames[e].components,i=0,r=Object.keys(t);i<r.length;i++){var I=r[i];t[I].quantizationTable=this.quantizationTables[t[I].quantizationIdx],delete t[I].quantizationIdx}for(var g=A[0],n=g.components,a=g.componentsOrder,o=[],B=g.samplesPerLine,C=g.scanLines,Q=0;Q<a.length;Q++){var E=n[a[Q]];o.push({lines:L(0,E),scaleX:E.h/g.maxH,scaleY:E.v/g.maxV})}for(var s=new Uint8Array(B*C*o.length),f=0,c=0;c<C;++c)for(var h=0;h<B;++h)for(var l=0;l<o.length;++l){var u=o[l];s[f]=u.lines[0|c*u.scaleY][0|h*u.scaleX],++f}return s}}]),A}(),M=function(A){s(t,w);var e=S(t);function t(A){var i;return B(this,t),(i=e.call(this)).reader=new b,A.JPEGTables&&i.reader.parse(A.JPEGTables),i}return Q(t,[{key:\\\"decodeBlock\\\",value:function(A){return this.reader.resetFrames(),this.reader.parse(new Uint8Array(A)),this.reader.getResult().buffer}}]),t}(),N=Object.freeze({__proto__:null,default:M});function x(A){for(var e=A.length;--e>=0;)A[e]=0}x(new Array(576)),x(new Array(60)),x(new Array(512)),x(new Array(256)),x(new Array(29)),x(new Array(30));var J=function(A,e,t,i){for(var r=65535&A|0,I=A>>>16&65535|0,g=0;0!==t;){t-=g=t>2e3?2e3:t;do{I=I+(r=r+e[i++]|0)|0}while(--g);r%=65521,I%=65521}return r|I<<16|0},q=new Uint32Array(function(){for(var A,e=[],t=0;t<256;t++){A=t;for(var i=0;i<8;i++)A=1&A?3988292384^A>>>1:A>>>1;e[t]=A}return e}()),Y=function(A,e,t,i){var r=q,I=i+t;A^=-1;for(var g=i;g<I;g++)A=A>>>8^r[255&(A^e[g])];return-1^A},K={2:\\\"need dictionary\\\",1:\\\"stream end\\\",0:\\\"\\\",\\\"-1\\\":\\\"file error\\\",\\\"-2\\\":\\\"stream error\\\",\\\"-3\\\":\\\"data error\\\",\\\"-4\\\":\\\"insufficient memory\\\",\\\"-5\\\":\\\"buffer error\\\",\\\"-6\\\":\\\"incompatible version\\\"},H={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},O=function(A,e){return Object.prototype.hasOwnProperty.call(A,e)},P=function(A){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var i=e.shift();if(i){if(\\\"object\\\"!==t(i))throw new TypeError(i+\\\"must be non-object\\\");for(var r in i)O(i,r)&&(A[r]=i[r])}}return A},T=function(A){for(var e=0,t=0,i=A.length;t<i;t++)e+=A[t].length;for(var r=new Uint8Array(e),I=0,g=0,n=A.length;I<n;I++){var a=A[I];r.set(a,g),g+=a.length}return r},V=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(A){V=!1}for(var _=new Uint8Array(256),X=0;X<256;X++)_[X]=X>=252?6:X>=248?5:X>=240?4:X>=224?3:X>=192?2:1;_[254]=_[254]=1;var Z=function(A){if(\\\"function\\\"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(A);var e,t,i,r,I,g=A.length,n=0;for(r=0;r<g;r++)55296==(64512&(t=A.charCodeAt(r)))&&r+1<g&&56320==(64512&(i=A.charCodeAt(r+1)))&&(t=65536+(t-55296<<10)+(i-56320),r++),n+=t<128?1:t<2048?2:t<65536?3:4;for(e=new Uint8Array(n),I=0,r=0;I<n;r++)55296==(64512&(t=A.charCodeAt(r)))&&r+1<g&&56320==(64512&(i=A.charCodeAt(r+1)))&&(t=65536+(t-55296<<10)+(i-56320),r++),t<128?e[I++]=t:t<2048?(e[I++]=192|t>>>6,e[I++]=128|63&t):t<65536?(e[I++]=224|t>>>12,e[I++]=128|t>>>6&63,e[I++]=128|63&t):(e[I++]=240|t>>>18,e[I++]=128|t>>>12&63,e[I++]=128|t>>>6&63,e[I++]=128|63&t);return e},j=function(A,e){var t,i,r=e||A.length;if(\\\"function\\\"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(A.subarray(0,e));var I=new Array(2*r);for(i=0,t=0;t<r;){var g=A[t++];if(g<128)I[i++]=g;else{var n=_[g];if(n>4)I[i++]=65533,t+=n-1;else{for(g&=2===n?31:3===n?15:7;n>1&&t<r;)g=g<<6|63&A[t++],n--;n>1?I[i++]=65533:g<65536?I[i++]=g:(g-=65536,I[i++]=55296|g>>10&1023,I[i++]=56320|1023&g)}}}return function(A,e){if(e<65534&&A.subarray&&V)return String.fromCharCode.apply(null,A.length===e?A:A.subarray(0,e));for(var t=\\\"\\\",i=0;i<e;i++)t+=String.fromCharCode(A[i]);return t}(I,i)},W=function(A,e){(e=e||A.length)>A.length&&(e=A.length);for(var t=e-1;t>=0&&128==(192&A[t]);)t--;return t<0||0===t?e:t+_[A[t]]>e?t:e};var z=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\\\"\\\",this.state=null,this.data_type=2,this.adler=0},$=function(A,e){var t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c,h,l,u,w,d,D,y,k,p,m=A.state;t=A.next_in,k=A.input,i=t+(A.avail_in-5),r=A.next_out,p=A.output,I=r-(e-A.avail_out),g=r+(A.avail_out-257),n=m.dmax,a=m.wsize,o=m.whave,B=m.wnext,C=m.window,Q=m.hold,E=m.bits,s=m.lencode,f=m.distcode,c=(1<<m.lenbits)-1,h=(1<<m.distbits)-1;A:do{E<15&&(Q+=k[t++]<<E,E+=8,Q+=k[t++]<<E,E+=8),l=s[Q&c];e:for(;;){if(Q>>>=u=l>>>24,E-=u,0===(u=l>>>16&255))p[r++]=65535&l;else{if(!(16&u)){if(0==(64&u)){l=s[(65535&l)+(Q&(1<<u)-1)];continue e}if(32&u){m.mode=12;break A}A.msg=\\\"invalid literal/length code\\\",m.mode=30;break A}w=65535&l,(u&=15)&&(E<u&&(Q+=k[t++]<<E,E+=8),w+=Q&(1<<u)-1,Q>>>=u,E-=u),E<15&&(Q+=k[t++]<<E,E+=8,Q+=k[t++]<<E,E+=8),l=f[Q&h];t:for(;;){if(Q>>>=u=l>>>24,E-=u,!(16&(u=l>>>16&255))){if(0==(64&u)){l=f[(65535&l)+(Q&(1<<u)-1)];continue t}A.msg=\\\"invalid distance code\\\",m.mode=30;break A}if(d=65535&l,E<(u&=15)&&(Q+=k[t++]<<E,(E+=8)<u&&(Q+=k[t++]<<E,E+=8)),(d+=Q&(1<<u)-1)>n){A.msg=\\\"invalid distance too far back\\\",m.mode=30;break A}if(Q>>>=u,E-=u,d>(u=r-I)){if((u=d-u)>o&&m.sane){A.msg=\\\"invalid distance too far back\\\",m.mode=30;break A}if(D=0,y=C,0===B){if(D+=a-u,u<w){w-=u;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}}else if(B<u){if(D+=a+B-u,(u-=B)<w){w-=u;do{p[r++]=C[D++]}while(--u);if(D=0,B<w){w-=u=B;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}}}else if(D+=B-u,u<w){w-=u;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}for(;w>2;)p[r++]=y[D++],p[r++]=y[D++],p[r++]=y[D++],w-=3;w&&(p[r++]=y[D++],w>1&&(p[r++]=y[D++]))}else{D=r-d;do{p[r++]=p[D++],p[r++]=p[D++],p[r++]=p[D++],w-=3}while(w>2);w&&(p[r++]=p[D++],w>1&&(p[r++]=p[D++]))}break}}break}}while(t<i&&r<g);t-=w=E>>3,Q&=(1<<(E-=w<<3))-1,A.next_in=t,A.next_out=r,A.avail_in=t<i?i-t+5:5-(t-i),A.avail_out=r<g?g-r+257:257-(r-g),m.hold=Q,m.bits=E},AA=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),eA=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),tA=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),iA=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),rA=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q,E,s,f,c,h=n.bits,l=0,u=0,w=0,d=0,D=0,y=0,k=0,p=0,m=0,G=0,F=null,S=0,v=new Uint16Array(16),R=new Uint16Array(16),U=null,L=0;for(l=0;l<=15;l++)v[l]=0;for(u=0;u<i;u++)v[e[t+u]]++;for(D=h,d=15;d>=1&&0===v[d];d--);if(D>d&&(D=d),0===d)return r[I++]=20971520,r[I++]=20971520,n.bits=1,0;for(w=1;w<d&&0===v[w];w++);for(D<w&&(D=w),p=1,l=1;l<=15;l++)if(p<<=1,(p-=v[l])<0)return-1;if(p>0&&(0===A||1!==d))return-1;for(R[1]=0,l=1;l<15;l++)R[l+1]=R[l]+v[l];for(u=0;u<i;u++)0!==e[t+u]&&(g[R[e[t+u]]++]=u);if(0===A?(F=U=g,E=19):1===A?(F=AA,S-=257,U=eA,L-=257,E=256):(F=tA,U=iA,E=-1),G=0,u=0,l=w,Q=I,y=D,k=0,B=-1,C=(m=1<<D)-1,1===A&&m>852||2===A&&m>592)return 1;for(;;){s=l-k,g[u]<E?(f=0,c=g[u]):g[u]>E?(f=U[L+g[u]],c=F[S+g[u]]):(f=96,c=0),a=1<<l-k,w=o=1<<y;do{r[Q+(G>>k)+(o-=a)]=s<<24|f<<16|c|0}while(0!==o);for(a=1<<l-1;G&a;)a>>=1;if(0!==a?(G&=a-1,G+=a):G=0,u++,0==--v[l]){if(l===d)break;l=e[t+g[u]]}if(l>D&&(G&C)!==B){for(0===k&&(k=D),Q+=w,p=1<<(y=l-k);y+k<d&&!((p-=v[y+k])<=0);)y++,p<<=1;if(m+=1<<y,1===A&&m>852||2===A&&m>592)return 1;r[B=G&C]=D<<24|y<<16|Q-I|0}}return 0!==G&&(r[Q+G]=l-k<<24|64<<16|0),n.bits=D,0},IA=H.Z_FINISH,gA=H.Z_BLOCK,nA=H.Z_TREES,aA=H.Z_OK,oA=H.Z_STREAM_END,BA=H.Z_NEED_DICT,CA=H.Z_STREAM_ERROR,QA=H.Z_DATA_ERROR,EA=H.Z_MEM_ERROR,sA=H.Z_BUF_ERROR,fA=H.Z_DEFLATED,cA=function(A){return(A>>>24&255)+(A>>>8&65280)+((65280&A)<<8)+((255&A)<<24)};function hA(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}var lA,uA,wA=function(A){if(!A||!A.state)return CA;var e=A.state;return A.total_in=A.total_out=e.total=0,A.msg=\\\"\\\",e.wrap&&(A.adler=1&e.wrap),e.mode=1,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new Int32Array(852),e.distcode=e.distdyn=new Int32Array(592),e.sane=1,e.back=-1,aA},dA=function(A){if(!A||!A.state)return CA;var e=A.state;return e.wsize=0,e.whave=0,e.wnext=0,wA(A)},DA=function(A,e){var t;if(!A||!A.state)return CA;var i=A.state;return e<0?(t=0,e=-e):(t=1+(e>>4),e<48&&(e&=15)),e&&(e<8||e>15)?CA:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=t,i.wbits=e,dA(A))},yA=function(A,e){if(!A)return CA;var t=new hA;A.state=t,t.window=null;var i=DA(A,e);return i!==aA&&(A.state=null),i},kA=!0,pA=function(A){if(kA){lA=new Int32Array(512),uA=new Int32Array(32);for(var e=0;e<144;)A.lens[e++]=8;for(;e<256;)A.lens[e++]=9;for(;e<280;)A.lens[e++]=7;for(;e<288;)A.lens[e++]=8;for(rA(1,A.lens,0,288,lA,0,A.work,{bits:9}),e=0;e<32;)A.lens[e++]=5;rA(2,A.lens,0,32,uA,0,A.work,{bits:5}),kA=!1}A.lencode=lA,A.lenbits=9,A.distcode=uA,A.distbits=5},mA=function(A,e,t,i){var r,I=A.state;return null===I.window&&(I.wsize=1<<I.wbits,I.wnext=0,I.whave=0,I.window=new Uint8Array(I.wsize)),i>=I.wsize?(I.window.set(e.subarray(t-I.wsize,t),0),I.wnext=0,I.whave=I.wsize):((r=I.wsize-I.wnext)>i&&(r=i),I.window.set(e.subarray(t-i,t-i+r),I.wnext),(i-=r)?(I.window.set(e.subarray(t-i,t),0),I.wnext=i,I.whave=I.wsize):(I.wnext+=r,I.wnext===I.wsize&&(I.wnext=0),I.whave<I.wsize&&(I.whave+=r))),0},GA={inflateReset:dA,inflateReset2:DA,inflateResetKeep:wA,inflateInit:function(A){return yA(A,15)},inflateInit2:yA,inflate:function(A,e){var t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c,h,l,u,w,d,D,y,k,p,m=0,G=new Uint8Array(4),F=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!A||!A.state||!A.output||!A.input&&0!==A.avail_in)return CA;12===(t=A.state).mode&&(t.mode=13),g=A.next_out,r=A.output,a=A.avail_out,I=A.next_in,i=A.input,n=A.avail_in,o=t.hold,B=t.bits,C=n,Q=a,y=aA;A:for(;;)switch(t.mode){case 1:if(0===t.wrap){t.mode=13;break}for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(2&t.wrap&&35615===o){t.check=0,G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0),o=0,B=0,t.mode=2;break}if(t.flags=0,t.head&&(t.head.done=!1),!(1&t.wrap)||(((255&o)<<8)+(o>>8))%31){A.msg=\\\"incorrect header check\\\",t.mode=30;break}if((15&o)!==fA){A.msg=\\\"unknown compression method\\\",t.mode=30;break}if(B-=4,D=8+(15&(o>>>=4)),0===t.wbits)t.wbits=D;else if(D>t.wbits){A.msg=\\\"invalid window size\\\",t.mode=30;break}t.dmax=1<<t.wbits,A.adler=t.check=1,t.mode=512&o?10:12,o=0,B=0;break;case 2:for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(t.flags=o,(255&t.flags)!==fA){A.msg=\\\"unknown compression method\\\",t.mode=30;break}if(57344&t.flags){A.msg=\\\"unknown header flags set\\\",t.mode=30;break}t.head&&(t.head.text=o>>8&1),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0,t.mode=3;case 3:for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.head&&(t.head.time=o),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,G[2]=o>>>16&255,G[3]=o>>>24&255,t.check=Y(t.check,G,4,0)),o=0,B=0,t.mode=4;case 4:for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.head&&(t.head.xflags=255&o,t.head.os=o>>8),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0,t.mode=5;case 5:if(1024&t.flags){for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.length=o,t.head&&(t.head.extra_len=o),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0}else t.head&&(t.head.extra=null);t.mode=6;case 6:if(1024&t.flags&&((E=t.length)>n&&(E=n),E&&(t.head&&(D=t.head.extra_len-t.length,t.head.extra||(t.head.extra=new Uint8Array(t.head.extra_len)),t.head.extra.set(i.subarray(I,I+E),D)),512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,t.length-=E),t.length))break A;t.length=0,t.mode=7;case 7:if(2048&t.flags){if(0===n)break A;E=0;do{D=i[I+E++],t.head&&D&&t.length<65536&&(t.head.name+=String.fromCharCode(D))}while(D&&E<n);if(512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,D)break A}else t.head&&(t.head.name=null);t.length=0,t.mode=8;case 8:if(4096&t.flags){if(0===n)break A;E=0;do{D=i[I+E++],t.head&&D&&t.length<65536&&(t.head.comment+=String.fromCharCode(D))}while(D&&E<n);if(512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,D)break A}else t.head&&(t.head.comment=null);t.mode=9;case 9:if(512&t.flags){for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o!==(65535&t.check)){A.msg=\\\"header crc mismatch\\\",t.mode=30;break}o=0,B=0}t.head&&(t.head.hcrc=t.flags>>9&1,t.head.done=!0),A.adler=t.check=0,t.mode=12;break;case 10:for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}A.adler=t.check=cA(o),o=0,B=0,t.mode=11;case 11:if(0===t.havedict)return A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,BA;A.adler=t.check=1,t.mode=12;case 12:if(e===gA||e===nA)break A;case 13:if(t.last){o>>>=7&B,B-=7&B,t.mode=27;break}for(;B<3;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}switch(t.last=1&o,B-=1,3&(o>>>=1)){case 0:t.mode=14;break;case 1:if(pA(t),t.mode=20,e===nA){o>>>=2,B-=2;break A}break;case 2:t.mode=17;break;case 3:A.msg=\\\"invalid block type\\\",t.mode=30}o>>>=2,B-=2;break;case 14:for(o>>>=7&B,B-=7&B;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if((65535&o)!=(o>>>16^65535)){A.msg=\\\"invalid stored block lengths\\\",t.mode=30;break}if(t.length=65535&o,o=0,B=0,t.mode=15,e===nA)break A;case 15:t.mode=16;case 16:if(E=t.length){if(E>n&&(E=n),E>a&&(E=a),0===E)break A;r.set(i.subarray(I,I+E),g),n-=E,I+=E,a-=E,g+=E,t.length-=E;break}t.mode=12;break;case 17:for(;B<14;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(t.nlen=257+(31&o),o>>>=5,B-=5,t.ndist=1+(31&o),o>>>=5,B-=5,t.ncode=4+(15&o),o>>>=4,B-=4,t.nlen>286||t.ndist>30){A.msg=\\\"too many length or distance symbols\\\",t.mode=30;break}t.have=0,t.mode=18;case 18:for(;t.have<t.ncode;){for(;B<3;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.lens[F[t.have++]]=7&o,o>>>=3,B-=3}for(;t.have<19;)t.lens[F[t.have++]]=0;if(t.lencode=t.lendyn,t.lenbits=7,k={bits:t.lenbits},y=rA(0,t.lens,0,19,t.lencode,0,t.work,k),t.lenbits=k.bits,y){A.msg=\\\"invalid code lengths set\\\",t.mode=30;break}t.have=0,t.mode=19;case 19:for(;t.have<t.nlen+t.ndist;){for(;h=(m=t.lencode[o&(1<<t.lenbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(l<16)o>>>=c,B-=c,t.lens[t.have++]=l;else{if(16===l){for(p=c+2;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o>>>=c,B-=c,0===t.have){A.msg=\\\"invalid bit length repeat\\\",t.mode=30;break}D=t.lens[t.have-1],E=3+(3&o),o>>>=2,B-=2}else if(17===l){for(p=c+3;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}B-=c,D=0,E=3+(7&(o>>>=c)),o>>>=3,B-=3}else{for(p=c+7;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}B-=c,D=0,E=11+(127&(o>>>=c)),o>>>=7,B-=7}if(t.have+E>t.nlen+t.ndist){A.msg=\\\"invalid bit length repeat\\\",t.mode=30;break}for(;E--;)t.lens[t.have++]=D}}if(30===t.mode)break;if(0===t.lens[256]){A.msg=\\\"invalid code -- missing end-of-block\\\",t.mode=30;break}if(t.lenbits=9,k={bits:t.lenbits},y=rA(1,t.lens,0,t.nlen,t.lencode,0,t.work,k),t.lenbits=k.bits,y){A.msg=\\\"invalid literal/lengths set\\\",t.mode=30;break}if(t.distbits=6,t.distcode=t.distdyn,k={bits:t.distbits},y=rA(2,t.lens,t.nlen,t.ndist,t.distcode,0,t.work,k),t.distbits=k.bits,y){A.msg=\\\"invalid distances set\\\",t.mode=30;break}if(t.mode=20,e===nA)break A;case 20:t.mode=21;case 21:if(n>=6&&a>=258){A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,$(A,Q),g=A.next_out,r=A.output,a=A.avail_out,I=A.next_in,i=A.input,n=A.avail_in,o=t.hold,B=t.bits,12===t.mode&&(t.back=-1);break}for(t.back=0;h=(m=t.lencode[o&(1<<t.lenbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(h&&0==(240&h)){for(u=c,w=h,d=l;h=(m=t.lencode[d+((o&(1<<u+w)-1)>>u)])>>>16&255,l=65535&m,!(u+(c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}o>>>=u,B-=u,t.back+=u}if(o>>>=c,B-=c,t.back+=c,t.length=l,0===h){t.mode=26;break}if(32&h){t.back=-1,t.mode=12;break}if(64&h){A.msg=\\\"invalid literal/length code\\\",t.mode=30;break}t.extra=15&h,t.mode=22;case 22:if(t.extra){for(p=t.extra;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.length+=o&(1<<t.extra)-1,o>>>=t.extra,B-=t.extra,t.back+=t.extra}t.was=t.length,t.mode=23;case 23:for(;h=(m=t.distcode[o&(1<<t.distbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(0==(240&h)){for(u=c,w=h,d=l;h=(m=t.distcode[d+((o&(1<<u+w)-1)>>u)])>>>16&255,l=65535&m,!(u+(c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}o>>>=u,B-=u,t.back+=u}if(o>>>=c,B-=c,t.back+=c,64&h){A.msg=\\\"invalid distance code\\\",t.mode=30;break}t.offset=l,t.extra=15&h,t.mode=24;case 24:if(t.extra){for(p=t.extra;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.offset+=o&(1<<t.extra)-1,o>>>=t.extra,B-=t.extra,t.back+=t.extra}if(t.offset>t.dmax){A.msg=\\\"invalid distance too far back\\\",t.mode=30;break}t.mode=25;case 25:if(0===a)break A;if(E=Q-a,t.offset>E){if((E=t.offset-E)>t.whave&&t.sane){A.msg=\\\"invalid distance too far back\\\",t.mode=30;break}E>t.wnext?(E-=t.wnext,s=t.wsize-E):s=t.wnext-E,E>t.length&&(E=t.length),f=t.window}else f=r,s=g-t.offset,E=t.length;E>a&&(E=a),a-=E,t.length-=E;do{r[g++]=f[s++]}while(--E);0===t.length&&(t.mode=21);break;case 26:if(0===a)break A;r[g++]=t.length,a--,t.mode=21;break;case 27:if(t.wrap){for(;B<32;){if(0===n)break A;n--,o|=i[I++]<<B,B+=8}if(Q-=a,A.total_out+=Q,t.total+=Q,Q&&(A.adler=t.check=t.flags?Y(t.check,r,Q,g-Q):J(t.check,r,Q,g-Q)),Q=a,(t.flags?o:cA(o))!==t.check){A.msg=\\\"incorrect data check\\\",t.mode=30;break}o=0,B=0}t.mode=28;case 28:if(t.wrap&&t.flags){for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o!==(4294967295&t.total)){A.msg=\\\"incorrect length check\\\",t.mode=30;break}o=0,B=0}t.mode=29;case 29:y=oA;break A;case 30:y=QA;break A;case 31:return EA;default:return CA}return A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,(t.wsize||Q!==A.avail_out&&t.mode<30&&(t.mode<27||e!==IA))&&mA(A,A.output,A.next_out,Q-A.avail_out),C-=A.avail_in,Q-=A.avail_out,A.total_in+=C,A.total_out+=Q,t.total+=Q,t.wrap&&Q&&(A.adler=t.check=t.flags?Y(t.check,r,Q,A.next_out-Q):J(t.check,r,Q,A.next_out-Q)),A.data_type=t.bits+(t.last?64:0)+(12===t.mode?128:0)+(20===t.mode||15===t.mode?256:0),(0===C&&0===Q||e===IA)&&y===aA&&(y=sA),y},inflateEnd:function(A){if(!A||!A.state)return CA;var e=A.state;return e.window&&(e.window=null),A.state=null,aA},inflateGetHeader:function(A,e){if(!A||!A.state)return CA;var t=A.state;return 0==(2&t.wrap)?CA:(t.head=e,e.done=!1,aA)},inflateSetDictionary:function(A,e){var t,i=e.length;return A&&A.state?0!==(t=A.state).wrap&&11!==t.mode?CA:11===t.mode&&J(1,e,i,0)!==t.check?QA:mA(A,e,i,i)?(t.mode=31,EA):(t.havedict=1,aA):CA},inflateInfo:\\\"pako inflate (from Nodeca project)\\\"};var FA=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name=\\\"\\\",this.comment=\\\"\\\",this.hcrc=0,this.done=!1},SA=Object.prototype.toString,vA=H.Z_NO_FLUSH,RA=H.Z_FINISH,UA=H.Z_OK,LA=H.Z_STREAM_END,bA=H.Z_NEED_DICT,MA=H.Z_STREAM_ERROR,NA=H.Z_DATA_ERROR,xA=H.Z_MEM_ERROR;function JA(A){this.options=P({chunkSize:65536,windowBits:15,to:\\\"\\\"},A||{});var e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||A&&A.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg=\\\"\\\",this.ended=!1,this.chunks=[],this.strm=new z,this.strm.avail_out=0;var t=GA.inflateInit2(this.strm,e.windowBits);if(t!==UA)throw new Error(K[t]);if(this.header=new FA,GA.inflateGetHeader(this.strm,this.header),e.dictionary&&(\\\"string\\\"==typeof e.dictionary?e.dictionary=Z(e.dictionary):\\\"[object ArrayBuffer]\\\"===SA.call(e.dictionary)&&(e.dictionary=new Uint8Array(e.dictionary)),e.raw&&(t=GA.inflateSetDictionary(this.strm,e.dictionary))!==UA))throw new Error(K[t])}function qA(A,e){var t=new JA(e);if(t.push(A),t.err)throw t.msg||K[t.err];return t.result}JA.prototype.push=function(A,e){var t,i,r,I=this.strm,g=this.options.chunkSize,n=this.options.dictionary;if(this.ended)return!1;for(i=e===~~e?e:!0===e?RA:vA,\\\"[object ArrayBuffer]\\\"===SA.call(A)?I.input=new Uint8Array(A):I.input=A,I.next_in=0,I.avail_in=I.input.length;;){for(0===I.avail_out&&(I.output=new Uint8Array(g),I.next_out=0,I.avail_out=g),(t=GA.inflate(I,i))===bA&&n&&((t=GA.inflateSetDictionary(I,n))===UA?t=GA.inflate(I,i):t===NA&&(t=bA));I.avail_in>0&&t===LA&&I.state.wrap>0&&0!==A[I.next_in];)GA.inflateReset(I),t=GA.inflate(I,i);switch(t){case MA:case NA:case bA:case xA:return this.onEnd(t),this.ended=!0,!1}if(r=I.avail_out,I.next_out&&(0===I.avail_out||t===LA))if(\\\"string\\\"===this.options.to){var a=W(I.output,I.next_out),o=I.next_out-a,B=j(I.output,a);I.next_out=o,I.avail_out=g-o,o&&I.output.set(I.output.subarray(a,a+o),0),this.onData(B)}else this.onData(I.output.length===I.next_out?I.output:I.output.subarray(0,I.next_out));if(t!==UA||0!==r){if(t===LA)return t=GA.inflateEnd(this.strm),this.onEnd(t),this.ended=!0,!0;if(0===I.avail_in)break}}return!0},JA.prototype.onData=function(A){this.chunks.push(A)},JA.prototype.onEnd=function(A){A===UA&&(\\\"string\\\"===this.options.to?this.result=this.chunks.join(\\\"\\\"):this.result=T(this.chunks)),this.chunks=[],this.err=A,this.msg=this.strm.msg};var YA={Inflate:JA,inflate:qA,inflateRaw:function(A,e){return(e=e||{}).raw=!0,qA(A,e)},ungzip:qA,constants:H}.inflate;function KA(A){var e=function(){if(\\\"undefined\\\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\\\"function\\\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var HA=function(A){s(t,w);var e=KA(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:\\\"decodeBlock\\\",value:function(A){return YA(new Uint8Array(A)).buffer}}]),t}(),OA=Object.freeze({__proto__:null,default:HA});function PA(A){var e=function(){if(\\\"undefined\\\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\\\"function\\\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var TA,VA=function(A){s(t,w);var e=PA(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:\\\"decodeBlock\\\",value:function(A){for(var e=new DataView(A),t=[],i=0;i<A.byteLength;++i){var r=e.getInt8(i);if(r<0){var I=e.getUint8(i+1);r=-r;for(var g=0;g<=r;++g)t.push(I);i+=1}else{for(var n=0;n<=r;++n)t.push(e.getUint8(i+n+1));i+=r+1}}return new Uint8Array(t).buffer}}]),t}(),_A=Object.freeze({__proto__:null,default:VA}),XA={exports:{}};TA=XA,\\n/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\\nfunction(){var A,e,t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c=(A={defaultNoDataValue:-34027999387901484e22,decode:function(I,g){var n=(g=g||{}).encodedMaskData||null===g.encodedMaskData,a=r(I,g.inputOffset||0,n),o=null!==g.noDataValue?g.noDataValue:A.defaultNoDataValue,B=e(a,g.pixelType||Float32Array,g.encodedMaskData,o,g.returnMask),C={width:a.width,height:a.height,pixelData:B.resultPixels,minValue:B.minValue,maxValue:a.pixels.maxValue,noDataValue:o};return B.resultMask&&(C.maskData=B.resultMask),g.returnEncodedMask&&a.mask&&(C.encodedMaskData=a.mask.bitset?a.mask.bitset:null),g.returnFileInfo&&(C.fileInfo=t(a),g.computeUsedBitDepths&&(C.fileInfo.bitDepths=i(a))),C}},e=function(A,e,t,i,r){var g,n,a,o=0,B=A.pixels.numBlocksX,C=A.pixels.numBlocksY,Q=Math.floor(A.width/B),E=Math.floor(A.height/C),s=2*A.maxZError,f=Number.MAX_VALUE;t=t||(A.mask?A.mask.bitset:null),n=new e(A.width*A.height),r&&t&&(a=new Uint8Array(A.width*A.height));for(var c,h,l=new Float32Array(Q*E),u=0;u<=C;u++){var w=u!==C?E:A.height%C;if(0!==w)for(var d=0;d<=B;d++){var D=d!==B?Q:A.width%B;if(0!==D){var y,k,p,m,G=u*A.width*E+d*Q,F=A.width-D,S=A.pixels.blocks[o];if(S.encoding<2?(0===S.encoding?y=S.rawData:(I(S.stuffedData,S.bitsPerPixel,S.numValidPixels,S.offset,s,l,A.pixels.maxValue),y=l),k=0):p=2===S.encoding?0:S.offset,t)for(h=0;h<w;h++){for(7&G&&(m=t[G>>3],m<<=7&G),c=0;c<D;c++)7&G||(m=t[G>>3]),128&m?(a&&(a[G]=1),f=f>(g=S.encoding<2?y[k++]:p)?g:f,n[G++]=g):(a&&(a[G]=0),n[G++]=i),m<<=1;G+=F}else if(S.encoding<2)for(h=0;h<w;h++){for(c=0;c<D;c++)f=f>(g=y[k++])?g:f,n[G++]=g;G+=F}else for(f=f>p?p:f,h=0;h<w;h++){for(c=0;c<D;c++)n[G++]=p;G+=F}if(1===S.encoding&&k!==S.numValidPixels)throw\\\"Block and Mask do not match\\\";o++}}}return{resultPixels:n,resultMask:a,minValue:f}},t=function(A){return{fileIdentifierString:A.fileIdentifierString,fileVersion:A.fileVersion,imageType:A.imageType,height:A.height,width:A.width,maxZError:A.maxZError,eofOffset:A.eofOffset,mask:A.mask?{numBlocksX:A.mask.numBlocksX,numBlocksY:A.mask.numBlocksY,numBytes:A.mask.numBytes,maxValue:A.mask.maxValue}:null,pixels:{numBlocksX:A.pixels.numBlocksX,numBlocksY:A.pixels.numBlocksY,numBytes:A.pixels.numBytes,maxValue:A.pixels.maxValue,noDataValue:A.noDataValue}}},i=function(A){for(var e=A.pixels.numBlocksX*A.pixels.numBlocksY,t={},i=0;i<e;i++){var r=A.pixels.blocks[i];0===r.encoding?t.float32=!0:1===r.encoding?t[r.bitsPerPixel]=!0:t[0]=!0}return Object.keys(t)},r=function(A,e,t){var i={},r=new Uint8Array(A,e,10);if(i.fileIdentifierString=String.fromCharCode.apply(null,r),\\\"CntZImage\\\"!==i.fileIdentifierString.trim())throw\\\"Unexpected file identifier string: \\\"+i.fileIdentifierString;e+=10;var I=new DataView(A,e,24);if(i.fileVersion=I.getInt32(0,!0),i.imageType=I.getInt32(4,!0),i.height=I.getUint32(8,!0),i.width=I.getUint32(12,!0),i.maxZError=I.getFloat64(16,!0),e+=24,!t)if(I=new DataView(A,e,16),i.mask={},i.mask.numBlocksY=I.getUint32(0,!0),i.mask.numBlocksX=I.getUint32(4,!0),i.mask.numBytes=I.getUint32(8,!0),i.mask.maxValue=I.getFloat32(12,!0),e+=16,i.mask.numBytes>0){var g=new Uint8Array(Math.ceil(i.width*i.height/8)),n=(I=new DataView(A,e,i.mask.numBytes)).getInt16(0,!0),a=2,o=0;do{if(n>0)for(;n--;)g[o++]=I.getUint8(a++);else{var B=I.getUint8(a++);for(n=-n;n--;)g[o++]=B}n=I.getInt16(a,!0),a+=2}while(a<i.mask.numBytes);if(-32768!==n||o<g.length)throw\\\"Unexpected end of mask RLE encoding\\\";i.mask.bitset=g,e+=i.mask.numBytes}else 0==(i.mask.numBytes|i.mask.numBlocksY|i.mask.maxValue)&&(i.mask.bitset=new Uint8Array(Math.ceil(i.width*i.height/8)));I=new DataView(A,e,16),i.pixels={},i.pixels.numBlocksY=I.getUint32(0,!0),i.pixels.numBlocksX=I.getUint32(4,!0),i.pixels.numBytes=I.getUint32(8,!0),i.pixels.maxValue=I.getFloat32(12,!0),e+=16;var C=i.pixels.numBlocksX,Q=i.pixels.numBlocksY,E=C+(i.width%C>0?1:0),s=Q+(i.height%Q>0?1:0);i.pixels.blocks=new Array(E*s);for(var f=0,c=0;c<s;c++)for(var h=0;h<E;h++){var l=0,u=A.byteLength-e;I=new DataView(A,e,Math.min(10,u));var w={};i.pixels.blocks[f++]=w;var d=I.getUint8(0);if(l++,w.encoding=63&d,w.encoding>3)throw\\\"Invalid block encoding (\\\"+w.encoding+\\\")\\\";if(2!==w.encoding){if(0!==d&&2!==d){if(d>>=6,w.offsetType=d,2===d)w.offset=I.getInt8(1),l++;else if(1===d)w.offset=I.getInt16(1,!0),l+=2;else{if(0!==d)throw\\\"Invalid block offset type\\\";w.offset=I.getFloat32(1,!0),l+=4}if(1===w.encoding)if(d=I.getUint8(l),l++,w.bitsPerPixel=63&d,d>>=6,w.numValidPixelsType=d,2===d)w.numValidPixels=I.getUint8(l),l++;else if(1===d)w.numValidPixels=I.getUint16(l,!0),l+=2;else{if(0!==d)throw\\\"Invalid valid pixel count type\\\";w.numValidPixels=I.getUint32(l,!0),l+=4}}var D;if(e+=l,3!==w.encoding)if(0===w.encoding){var y=(i.pixels.numBytes-1)/4;if(y!==Math.floor(y))throw\\\"uncompressed block has invalid length\\\";D=new ArrayBuffer(4*y),new Uint8Array(D).set(new Uint8Array(A,e,4*y));var k=new Float32Array(D);w.rawData=k,e+=4*y}else if(1===w.encoding){var p=Math.ceil(w.numValidPixels*w.bitsPerPixel/8),m=Math.ceil(p/4);D=new ArrayBuffer(4*m),new Uint8Array(D).set(new Uint8Array(A,e,p)),w.stuffedData=new Uint32Array(D),e+=p}}else e++}return i.eofOffset=e,i},I=function(A,e,t,i,r,I,g){var n,a,o,B=(1<<e)-1,C=0,Q=0,E=Math.ceil((g-i)/r),s=4*A.length-Math.ceil(e*t/8);for(A[A.length-1]<<=8*s,n=0;n<t;n++){if(0===Q&&(o=A[C++],Q=32),Q>=e)a=o>>>Q-e&B,Q-=e;else{var f=e-Q;a=(o&B)<<f&B,a+=(o=A[C++])>>>(Q=32-f)}I[n]=a<E?i+a*r:g}return I},A),h=(g=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q,E=(1<<t)-1,s=0,f=0,c=4*A.length-Math.ceil(t*i/8);if(A[A.length-1]<<=8*c,r)for(a=0;a<i;a++)0===f&&(B=A[s++],f=32),f>=t?(o=B>>>f-t&E,f-=t):(o=(B&E)<<(C=t-f)&E,o+=(B=A[s++])>>>(f=32-C)),e[a]=r[o];else for(Q=Math.ceil((n-I)/g),a=0;a<i;a++)0===f&&(B=A[s++],f=32),f>=t?(o=B>>>f-t&E,f-=t):(o=(B&E)<<(C=t-f)&E,o+=(B=A[s++])>>>(f=32-C)),e[a]=o<Q?I+o*g:n},n=function(A,e,t,i,r,I){var g,n=(1<<e)-1,a=0,o=0,B=0,C=0,Q=0,E=[],s=4*A.length-Math.ceil(e*t/8);A[A.length-1]<<=8*s;var f=Math.ceil((I-i)/r);for(o=0;o<t;o++)0===C&&(g=A[a++],C=32),C>=e?(Q=g>>>C-e&n,C-=e):(Q=(g&n)<<(B=e-C)&n,Q+=(g=A[a++])>>>(C=32-B)),E[o]=Q<f?i+Q*r:I;return E.unshift(i),E},a=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q=(1<<t)-1,E=0,s=0,f=0;if(r)for(a=0;a<i;a++)0===s&&(B=A[E++],s=32,f=0),s>=t?(o=B>>>f&Q,s-=t,f+=t):(o=B>>>f&Q,s=32-(C=t-s),o|=((B=A[E++])&(1<<C)-1)<<t-C,f=C),e[a]=r[o];else{var c=Math.ceil((n-I)/g);for(a=0;a<i;a++)0===s&&(B=A[E++],s=32,f=0),s>=t?(o=B>>>f&Q,s-=t,f+=t):(o=B>>>f&Q,s=32-(C=t-s),o|=((B=A[E++])&(1<<C)-1)<<t-C,f=C),e[a]=o<c?I+o*g:n}return e},o=function(A,e,t,i,r,I){var g,n=(1<<e)-1,a=0,o=0,B=0,C=0,Q=0,E=0,s=[],f=Math.ceil((I-i)/r);for(o=0;o<t;o++)0===C&&(g=A[a++],C=32,E=0),C>=e?(Q=g>>>E&n,C-=e,E+=e):(Q=g>>>E&n,C=32-(B=e-C),Q|=((g=A[a++])&(1<<B)-1)<<e-B,E=B),s[o]=Q<f?i+Q*r:I;return s.unshift(i),s},B=function(A,e,t,i){var r,I,g,n,a=(1<<t)-1,o=0,B=0,C=4*A.length-Math.ceil(t*i/8);for(A[A.length-1]<<=8*C,r=0;r<i;r++)0===B&&(g=A[o++],B=32),B>=t?(I=g>>>B-t&a,B-=t):(I=(g&a)<<(n=t-B)&a,I+=(g=A[o++])>>>(B=32-n)),e[r]=I;return e},C=function(A,e,t,i){var r,I,g,n,a=(1<<t)-1,o=0,B=0,C=0;for(r=0;r<i;r++)0===B&&(g=A[o++],B=32,C=0),B>=t?(I=g>>>C&a,B-=t,C+=t):(I=g>>>C&a,B=32-(n=t-B),I|=((g=A[o++])&(1<<n)-1)<<t-n,C=n),e[r]=I;return e},Q={HUFFMAN_LUT_BITS_MAX:12,computeChecksumFletcher32:function(A){for(var e=65535,t=65535,i=A.length,r=Math.floor(i/2),I=0;r;){var g=r>=359?359:r;r-=g;do{e+=A[I++]<<8,t+=e+=A[I++]}while(--g);e=(65535&e)+(e>>>16),t=(65535&t)+(t>>>16)}return 1&i&&(t+=e+=A[I]<<8),((t=(65535&t)+(t>>>16))<<16|(e=(65535&e)+(e>>>16)))>>>0},readHeaderInfo:function(A,e){var t=e.ptr,i=new Uint8Array(A,t,6),r={};if(r.fileIdentifierString=String.fromCharCode.apply(null,i),0!==r.fileIdentifierString.lastIndexOf(\\\"Lerc2\\\",0))throw\\\"Unexpected file identifier string (expect Lerc2 ): \\\"+r.fileIdentifierString;t+=6;var I,g=new DataView(A,t,8),n=g.getInt32(0,!0);if(r.fileVersion=n,t+=4,n>=3&&(r.checksum=g.getUint32(4,!0),t+=4),g=new DataView(A,t,12),r.height=g.getUint32(0,!0),r.width=g.getUint32(4,!0),t+=8,n>=4?(r.numDims=g.getUint32(8,!0),t+=4):r.numDims=1,g=new DataView(A,t,40),r.numValidPixel=g.getUint32(0,!0),r.microBlockSize=g.getInt32(4,!0),r.blobSize=g.getInt32(8,!0),r.imageType=g.getInt32(12,!0),r.maxZError=g.getFloat64(16,!0),r.zMin=g.getFloat64(24,!0),r.zMax=g.getFloat64(32,!0),t+=40,e.headerInfo=r,e.ptr=t,n>=3&&(I=n>=4?52:48,this.computeChecksumFletcher32(new Uint8Array(A,t-I,r.blobSize-14))!==r.checksum))throw\\\"Checksum failed.\\\";return!0},checkMinMaxRanges:function(A,e){var t=e.headerInfo,i=this.getDataTypeArray(t.imageType),r=t.numDims*this.getDataTypeSize(t.imageType),I=this.readSubArray(A,e.ptr,i,r),g=this.readSubArray(A,e.ptr+r,i,r);e.ptr+=2*r;var n,a=!0;for(n=0;n<t.numDims;n++)if(I[n]!==g[n]){a=!1;break}return t.minValues=I,t.maxValues=g,a},readSubArray:function(A,e,t,i){var r;if(t===Uint8Array)r=new Uint8Array(A,e,i);else{var I=new ArrayBuffer(i);new Uint8Array(I).set(new Uint8Array(A,e,i)),r=new t(I)}return r},readMask:function(A,e){var t,i,r=e.ptr,I=e.headerInfo,g=I.width*I.height,n=I.numValidPixel,a=new DataView(A,r,4),o={};if(o.numBytes=a.getUint32(0,!0),r+=4,(0===n||g===n)&&0!==o.numBytes)throw\\\"invalid mask\\\";if(0===n)t=new Uint8Array(Math.ceil(g/8)),o.bitset=t,i=new Uint8Array(g),e.pixels.resultMask=i,r+=o.numBytes;else if(o.numBytes>0){t=new Uint8Array(Math.ceil(g/8));var B=(a=new DataView(A,r,o.numBytes)).getInt16(0,!0),C=2,Q=0,E=0;do{if(B>0)for(;B--;)t[Q++]=a.getUint8(C++);else for(E=a.getUint8(C++),B=-B;B--;)t[Q++]=E;B=a.getInt16(C,!0),C+=2}while(C<o.numBytes);if(-32768!==B||Q<t.length)throw\\\"Unexpected end of mask RLE encoding\\\";i=new Uint8Array(g);var s=0,f=0;for(f=0;f<g;f++)7&f?(s=t[f>>3],s<<=7&f):s=t[f>>3],128&s&&(i[f]=1);e.pixels.resultMask=i,o.bitset=t,r+=o.numBytes}return e.ptr=r,e.mask=o,!0},readDataOneSweep:function(A,e,t,i){var r,I=e.ptr,g=e.headerInfo,n=g.numDims,a=g.width*g.height,o=g.imageType,B=g.numValidPixel*Q.getDataTypeSize(o)*n,C=e.pixels.resultMask;if(t===Uint8Array)r=new Uint8Array(A,I,B);else{var E=new ArrayBuffer(B);new Uint8Array(E).set(new Uint8Array(A,I,B)),r=new t(E)}if(r.length===a*n)e.pixels.resultPixels=i?Q.swapDimensionOrder(r,a,n,t,!0):r;else{e.pixels.resultPixels=new t(a*n);var s=0,f=0,c=0,h=0;if(n>1){if(i){for(f=0;f<a;f++)if(C[f])for(h=f,c=0;c<n;c++,h+=a)e.pixels.resultPixels[h]=r[s++]}else for(f=0;f<a;f++)if(C[f])for(h=f*n,c=0;c<n;c++)e.pixels.resultPixels[h+c]=r[s++]}else for(f=0;f<a;f++)C[f]&&(e.pixels.resultPixels[f]=r[s++])}return I+=B,e.ptr=I,!0},readHuffmanTree:function(A,e){var t=this.HUFFMAN_LUT_BITS_MAX,i=new DataView(A,e.ptr,16);if(e.ptr+=16,i.getInt32(0,!0)<2)throw\\\"unsupported Huffman version\\\";var r=i.getInt32(4,!0),I=i.getInt32(8,!0),g=i.getInt32(12,!0);if(I>=g)return!1;var n=new Uint32Array(g-I);Q.decodeBits(A,e,n);var a,o,B,C,s=[];for(a=I;a<g;a++)s[o=a-(a<r?0:r)]={first:n[a-I],second:null};var f=A.byteLength-e.ptr,c=Math.ceil(f/4),h=new ArrayBuffer(4*c);new Uint8Array(h).set(new Uint8Array(A,e.ptr,f));var l,u=new Uint32Array(h),w=0,d=0;for(l=u[0],a=I;a<g;a++)(C=s[o=a-(a<r?0:r)].first)>0&&(s[o].second=l<<w>>>32-C,32-w>=C?32===(w+=C)&&(w=0,l=u[++d]):(w+=C-32,l=u[++d],s[o].second|=l>>>32-w));var D=0,y=0,k=new E;for(a=0;a<s.length;a++)void 0!==s[a]&&(D=Math.max(D,s[a].first));y=D>=t?t:D;var p,m,G,F,S,v=[];for(a=I;a<g;a++)if((C=s[o=a-(a<r?0:r)].first)>0)if(p=[C,o],C<=y)for(m=s[o].second<<y-C,G=1<<y-C,B=0;B<G;B++)v[m|B]=p;else for(m=s[o].second,S=k,F=C-1;F>=0;F--)m>>>F&1?(S.right||(S.right=new E),S=S.right):(S.left||(S.left=new E),S=S.left),0!==F||S.val||(S.val=p[1]);return{decodeLut:v,numBitsLUTQick:y,numBitsLUT:D,tree:k,stuffedData:u,srcPtr:d,bitPos:w}},readHuffman:function(A,e,t,i){var r,I,g,n,a,o,B,C,E,s=e.headerInfo.numDims,f=e.headerInfo.height,c=e.headerInfo.width,h=c*f,l=this.readHuffmanTree(A,e),u=l.decodeLut,w=l.tree,d=l.stuffedData,D=l.srcPtr,y=l.bitPos,k=l.numBitsLUTQick,p=l.numBitsLUT,m=0===e.headerInfo.imageType?128:0,G=e.pixels.resultMask,F=0;y>0&&(D++,y=0);var S,v=d[D],R=1===e.encodeMode,U=new t(h*s),L=U;if(s<2||R){for(S=0;S<s;S++)if(s>1&&(L=new t(U.buffer,h*S,h),F=0),e.headerInfo.numValidPixel===c*f)for(C=0,o=0;o<f;o++)for(B=0;B<c;B++,C++){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,R?(g+=B>0?F:o>0?L[C-c]:F,g&=255,L[C]=g,F=g):L[C]=g}else for(C=0,o=0;o<f;o++)for(B=0;B<c;B++,C++)if(G[C]){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,R?(B>0&&G[C-1]?g+=F:o>0&&G[C-c]?g+=L[C-c]:g+=F,g&=255,L[C]=g,F=g):L[C]=g}}else for(C=0,o=0;o<f;o++)for(B=0;B<c;B++)if(C=o*c+B,!G||G[C])for(S=0;S<s;S++,C+=h){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,L[C]=g}e.ptr=e.ptr+4*(D+1)+(y>0?4:0),e.pixels.resultPixels=U,s>1&&!i&&(e.pixels.resultPixels=Q.swapDimensionOrder(U,h,s,t))},decodeBits:function(A,e,t,i,r){var I=e.headerInfo,Q=I.fileVersion,E=0,s=A.byteLength-e.ptr>=5?5:A.byteLength-e.ptr,f=new DataView(A,e.ptr,s),c=f.getUint8(0);E++;var h=c>>6,l=0===h?4:3-h,u=(32&c)>0,w=31&c,d=0;if(1===l)d=f.getUint8(E),E++;else if(2===l)d=f.getUint16(E,!0),E+=2;else{if(4!==l)throw\\\"Invalid valid pixel count type\\\";d=f.getUint32(E,!0),E+=4}var D,y,k,p,m,G,F,S,v,R=2*I.maxZError,U=I.numDims>1?I.maxValues[r]:I.zMax;if(u){for(e.counter.lut++,S=f.getUint8(E),E++,p=Math.ceil((S-1)*w/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),k=new Uint8Array(y),e.ptr+=E,k.set(new Uint8Array(A,e.ptr,p)),F=new Uint32Array(y),e.ptr+=p,v=0;S-1>>>v;)v++;p=Math.ceil(d*v/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),(k=new Uint8Array(y)).set(new Uint8Array(A,e.ptr,p)),D=new Uint32Array(y),e.ptr+=p,G=Q>=3?o(F,w,S-1,i,R,U):n(F,w,S-1,i,R,U),Q>=3?a(D,t,v,d,G):g(D,t,v,d,G)}else e.counter.bitstuffer++,v=w,e.ptr+=E,v>0&&(p=Math.ceil(d*v/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),(k=new Uint8Array(y)).set(new Uint8Array(A,e.ptr,p)),D=new Uint32Array(y),e.ptr+=p,Q>=3?null==i?C(D,t,v,d):a(D,t,v,d,!1,i,R,U):null==i?B(D,t,v,d):g(D,t,v,d,!1,i,R,U))},readTiles:function(A,e,t,i){var r=e.headerInfo,I=r.width,g=r.height,n=I*g,a=r.microBlockSize,o=r.imageType,B=Q.getDataTypeSize(o),C=Math.ceil(I/a),E=Math.ceil(g/a);e.pixels.numBlocksY=E,e.pixels.numBlocksX=C,e.pixels.ptr=0;var s,f,c,h,l,u,w,d,D,y,k=0,p=0,m=0,G=0,F=0,S=0,v=0,R=0,U=0,L=0,b=0,M=0,N=0,x=0,J=0,q=new t(a*a),Y=g%a||a,K=I%a||a,H=r.numDims,O=e.pixels.resultMask,P=e.pixels.resultPixels,T=r.fileVersion>=5?14:15,V=r.zMax;for(m=0;m<E;m++)for(F=m!==E-1?a:Y,G=0;G<C;G++)for(L=m*I*a+G*a,b=I-(S=G!==C-1?a:K),d=0;d<H;d++){if(H>1?(y=P,L=m*I*a+G*a,P=new t(e.pixels.resultPixels.buffer,n*d*B,n),V=r.maxValues[d]):y=null,v=A.byteLength-e.ptr,f={},J=0,R=(s=new DataView(A,e.ptr,Math.min(10,v))).getUint8(0),J++,D=r.fileVersion>=5?4&R:0,U=R>>6&255,(R>>2&T)!=(G*a>>3&T))throw\\\"integrity issue\\\";if(D&&0===d)throw\\\"integrity issue\\\";if((l=3&R)>3)throw e.ptr+=J,\\\"Invalid block encoding (\\\"+l+\\\")\\\";if(2!==l)if(0===l){if(D)throw\\\"integrity issue\\\";if(e.counter.uncompressed++,e.ptr+=J,M=(M=F*S*B)<(N=A.byteLength-e.ptr)?M:N,c=new ArrayBuffer(M%B==0?M:M+B-M%B),new Uint8Array(c).set(new Uint8Array(A,e.ptr,M)),h=new t(c),x=0,O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=h[x++]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L++]=h[x++];L+=b}e.ptr+=x*B}else if(u=Q.getDataTypeUsed(D&&o<6?4:o,U),w=Q.getOnePixel(f,J,u,s),J+=Q.getDataTypeSize(u),3===l)if(e.ptr+=J,e.counter.constantoffset++,O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=D?Math.min(V,y[L]+w):w),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L]=D?Math.min(V,y[L]+w):w,L++;L+=b}else if(e.ptr+=J,Q.decodeBits(A,e,q,w,d),J=0,D)if(O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=q[J++]+y[L]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L]=q[J++]+y[L],L++;L+=b}else if(O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=q[J++]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L++]=q[J++];L+=b}else{if(D)if(O)for(k=0;k<F;k++)for(p=0;p<S;p++)O[L]&&(P[L]=y[L]),L++;else for(k=0;k<F;k++)for(p=0;p<S;p++)P[L]=y[L],L++;e.counter.constant++,e.ptr+=J}}H>1&&!i&&(e.pixels.resultPixels=Q.swapDimensionOrder(e.pixels.resultPixels,n,H,t))},formatFileInfo:function(A){return{fileIdentifierString:A.headerInfo.fileIdentifierString,fileVersion:A.headerInfo.fileVersion,imageType:A.headerInfo.imageType,height:A.headerInfo.height,width:A.headerInfo.width,numValidPixel:A.headerInfo.numValidPixel,microBlockSize:A.headerInfo.microBlockSize,blobSize:A.headerInfo.blobSize,maxZError:A.headerInfo.maxZError,pixelType:Q.getPixelType(A.headerInfo.imageType),eofOffset:A.eofOffset,mask:A.mask?{numBytes:A.mask.numBytes}:null,pixels:{numBlocksX:A.pixels.numBlocksX,numBlocksY:A.pixels.numBlocksY,maxValue:A.headerInfo.zMax,minValue:A.headerInfo.zMin,noDataValue:A.noDataValue}}},constructConstantSurface:function(A,e){var t=A.headerInfo.zMax,i=A.headerInfo.zMin,r=A.headerInfo.maxValues,I=A.headerInfo.numDims,g=A.headerInfo.height*A.headerInfo.width,n=0,a=0,o=0,B=A.pixels.resultMask,C=A.pixels.resultPixels;if(B)if(I>1){if(e)for(n=0;n<I;n++)for(o=n*g,t=r[n],a=0;a<g;a++)B[a]&&(C[o+a]=t);else for(a=0;a<g;a++)if(B[a])for(o=a*I,n=0;n<I;n++)C[o+I]=r[n]}else for(a=0;a<g;a++)B[a]&&(C[a]=t);else if(I>1&&i!==t)if(e)for(n=0;n<I;n++)for(o=n*g,t=r[n],a=0;a<g;a++)C[o+a]=t;else for(a=0;a<g;a++)for(o=a*I,n=0;n<I;n++)C[o+n]=r[n];else for(a=0;a<g*I;a++)C[a]=t},getDataTypeArray:function(A){var e;switch(A){case 0:e=Int8Array;break;case 1:e=Uint8Array;break;case 2:e=Int16Array;break;case 3:e=Uint16Array;break;case 4:e=Int32Array;break;case 5:e=Uint32Array;break;case 6:default:e=Float32Array;break;case 7:e=Float64Array}return e},getPixelType:function(A){var e;switch(A){case 0:e=\\\"S8\\\";break;case 1:e=\\\"U8\\\";break;case 2:e=\\\"S16\\\";break;case 3:e=\\\"U16\\\";break;case 4:e=\\\"S32\\\";break;case 5:e=\\\"U32\\\";break;case 6:default:e=\\\"F32\\\";break;case 7:e=\\\"F64\\\"}return e},isValidPixelValue:function(A,e){if(null==e)return!1;var t;switch(A){case 0:t=e>=-128&&e<=127;break;case 1:t=e>=0&&e<=255;break;case 2:t=e>=-32768&&e<=32767;break;case 3:t=e>=0&&e<=65536;break;case 4:t=e>=-2147483648&&e<=2147483647;break;case 5:t=e>=0&&e<=4294967296;break;case 6:t=e>=-34027999387901484e22&&e<=34027999387901484e22;break;case 7:t=e>=-17976931348623157e292&&e<=17976931348623157e292;break;default:t=!1}return t},getDataTypeSize:function(A){var e=0;switch(A){case 0:case 1:e=1;break;case 2:case 3:e=2;break;case 4:case 5:case 6:e=4;break;case 7:e=8;break;default:e=A}return e},getDataTypeUsed:function(A,e){var t=A;switch(A){case 2:case 4:t=A-e;break;case 3:case 5:t=A-2*e;break;case 6:t=0===e?A:1===e?2:1;break;case 7:t=0===e?A:A-2*e+1;break;default:t=A}return t},getOnePixel:function(A,e,t,i){var r=0;switch(t){case 0:r=i.getInt8(e);break;case 1:r=i.getUint8(e);break;case 2:r=i.getInt16(e,!0);break;case 3:r=i.getUint16(e,!0);break;case 4:r=i.getInt32(e,!0);break;case 5:r=i.getUInt32(e,!0);break;case 6:r=i.getFloat32(e,!0);break;case 7:r=i.getFloat64(e,!0);break;default:throw\\\"the decoder does not understand this pixel type\\\"}return r},swapDimensionOrder:function(A,e,t,i,r){var I=0,g=0,n=0,a=0,o=A;if(t>1)if(o=new i(e*t),r)for(I=0;I<e;I++)for(a=I,n=0;n<t;n++,a+=e)o[a]=A[g++];else for(I=0;I<e;I++)for(a=I,n=0;n<t;n++,a+=e)o[g++]=A[a];return o}},E=function(A,e,t){this.val=A,this.left=e,this.right=t},{decode:function(A,e){var t=(e=e||{}).noDataValue,i=0,r={};r.ptr=e.inputOffset||0,r.pixels={},Q.readHeaderInfo(A,r);var I=r.headerInfo,g=I.fileVersion,n=Q.getDataTypeArray(I.imageType);if(g>5)throw\\\"unsupported lerc version 2.\\\"+g;Q.readMask(A,r),I.numValidPixel===I.width*I.height||r.pixels.resultMask||(r.pixels.resultMask=e.maskData);var a=I.width*I.height;r.pixels.resultPixels=new n(a*I.numDims),r.counter={onesweep:0,uncompressed:0,lut:0,bitstuffer:0,constant:0,constantoffset:0};var o,B=!e.returnPixelInterleavedDims;if(0!==I.numValidPixel)if(I.zMax===I.zMin)Q.constructConstantSurface(r,B);else if(g>=4&&Q.checkMinMaxRanges(A,r))Q.constructConstantSurface(r,B);else{var C=new DataView(A,r.ptr,2),E=C.getUint8(0);if(r.ptr++,E)Q.readDataOneSweep(A,r,n,B);else if(g>1&&I.imageType<=1&&Math.abs(I.maxZError-.5)<1e-5){var s=C.getUint8(1);if(r.ptr++,r.encodeMode=s,s>2||g<4&&s>1)throw\\\"Invalid Huffman flag \\\"+s;s?Q.readHuffman(A,r,n,B):Q.readTiles(A,r,n,B)}else Q.readTiles(A,r,n,B)}r.eofOffset=r.ptr,e.inputOffset?(o=r.headerInfo.blobSize+e.inputOffset-r.ptr,Math.abs(o)>=1&&(r.eofOffset=e.inputOffset+r.headerInfo.blobSize)):(o=r.headerInfo.blobSize-r.ptr,Math.abs(o)>=1&&(r.eofOffset=r.headerInfo.blobSize));var f={width:I.width,height:I.height,pixelData:r.pixels.resultPixels,minValue:I.zMin,maxValue:I.zMax,validPixelCount:I.numValidPixel,dimCount:I.numDims,dimStats:{minValues:I.minValues,maxValues:I.maxValues},maskData:r.pixels.resultMask};if(r.pixels.resultMask&&Q.isValidPixelValue(I.imageType,t)){var c=r.pixels.resultMask;for(i=0;i<a;i++)c[i]||(f.pixelData[i]=t);f.noDataValue=t}return r.noDataValue=t,e.returnFileInfo&&(f.fileInfo=Q.formatFileInfo(r)),f},getBandCount:function(A){for(var e=0,t=0,i={ptr:0,pixels:{}};t<A.byteLength-58;)Q.readHeaderInfo(A,i),t+=i.headerInfo.blobSize,e++,i.ptr=t;return e}}),l=(s=new ArrayBuffer(4),f=new Uint8Array(s),new Uint32Array(s)[0]=1,1===f[0]),u={decode:function(A,e){if(!l)throw\\\"Big endian system is not supported.\\\";var t,i,r=(e=e||{}).inputOffset||0,I=new Uint8Array(A,r,10),g=String.fromCharCode.apply(null,I);if(\\\"CntZImage\\\"===g.trim())t=c,i=1;else{if(\\\"Lerc2\\\"!==g.substring(0,5))throw\\\"Unexpected file identifier string: \\\"+g;t=h,i=2}for(var n,a,o,B,C,Q,E=0,s=A.byteLength-10,f=[],u={width:0,height:0,pixels:[],pixelType:e.pixelType,mask:null,statistics:[]},w=0;r<s;){var d=t.decode(A,{inputOffset:r,encodedMaskData:n,maskData:o,returnMask:0===E,returnEncodedMask:0===E,returnFileInfo:!0,returnPixelInterleavedDims:e.returnPixelInterleavedDims,pixelType:e.pixelType||null,noDataValue:e.noDataValue||null});r=d.fileInfo.eofOffset,o=d.maskData,0===E&&(n=d.encodedMaskData,u.width=d.width,u.height=d.height,u.dimCount=d.dimCount||1,u.pixelType=d.pixelType||d.fileInfo.pixelType,u.mask=o),i>1&&(o&&f.push(o),d.fileInfo.mask&&d.fileInfo.mask.numBytes>0&&w++),E++,u.pixels.push(d.pixelData),u.statistics.push({minValue:d.minValue,maxValue:d.maxValue,noDataValue:d.noDataValue,dimStats:d.dimStats})}if(i>1&&w>1){for(Q=u.width*u.height,u.bandMasks=f,(o=new Uint8Array(Q)).set(f[0]),B=1;B<f.length;B++)for(a=f[B],C=0;C<Q;C++)o[C]=o[C]&a[C];u.maskData=o}return u}};TA.exports?TA.exports=u:this.Lerc=u}();var ZA,jA,WA,zA=XA.exports,$A={env:{emscripten_notify_memory_growth:function(A){WA=new Uint8Array(jA.exports.memory.buffer)}}},Ae=function(){function A(){B(this,A)}return Q(A,[{key:\\\"init\\\",value:function(){return ZA||(ZA=\\\"undefined\\\"!=typeof fetch?fetch(\\\"data:application/wasm;base64,\\\"+ee).then((function(A){return A.arrayBuffer()})).then((function(A){return WebAssembly.instantiate(A,$A)})).then(this._init):WebAssembly.instantiate(Buffer.from(ee,\\\"base64\\\"),$A).then(this._init))}},{key:\\\"_init\\\",value:function(A){jA=A.instance,$A.env.emscripten_notify_memory_growth(0)}},{key:\\\"decode\\\",value:function(A){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!jA)throw new Error(\\\"ZSTDDecoder: Await .init() before decoding.\\\");var t=A.byteLength,i=jA.exports.malloc(t);WA.set(A,i),e=e||Number(jA.exports.ZSTD_findDecompressedSize(i,t));var r=jA.exports.malloc(e),I=jA.exports.ZSTD_decompress(r,e,i,t),g=WA.slice(r,r+I);return jA.exports.free(i),jA.exports.free(r),g}}]),A}(),ee=\\\"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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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\\\",te={315:\\\"Artist\\\",258:\\\"BitsPerSample\\\",265:\\\"CellLength\\\",264:\\\"CellWidth\\\",320:\\\"ColorMap\\\",259:\\\"Compression\\\",33432:\\\"Copyright\\\",306:\\\"DateTime\\\",338:\\\"ExtraSamples\\\",266:\\\"FillOrder\\\",289:\\\"FreeByteCounts\\\",288:\\\"FreeOffsets\\\",291:\\\"GrayResponseCurve\\\",290:\\\"GrayResponseUnit\\\",316:\\\"HostComputer\\\",270:\\\"ImageDescription\\\",257:\\\"ImageLength\\\",256:\\\"ImageWidth\\\",271:\\\"Make\\\",281:\\\"MaxSampleValue\\\",280:\\\"MinSampleValue\\\",272:\\\"Model\\\",254:\\\"NewSubfileType\\\",274:\\\"Orientation\\\",262:\\\"PhotometricInterpretation\\\",284:\\\"PlanarConfiguration\\\",296:\\\"ResolutionUnit\\\",278:\\\"RowsPerStrip\\\",277:\\\"SamplesPerPixel\\\",305:\\\"Software\\\",279:\\\"StripByteCounts\\\",273:\\\"StripOffsets\\\",255:\\\"SubfileType\\\",263:\\\"Threshholding\\\",282:\\\"XResolution\\\",283:\\\"YResolution\\\",326:\\\"BadFaxLines\\\",327:\\\"CleanFaxData\\\",343:\\\"ClipPath\\\",328:\\\"ConsecutiveBadFaxLines\\\",433:\\\"Decode\\\",434:\\\"DefaultImageColor\\\",269:\\\"DocumentName\\\",336:\\\"DotRange\\\",321:\\\"HalftoneHints\\\",346:\\\"Indexed\\\",347:\\\"JPEGTables\\\",285:\\\"PageName\\\",297:\\\"PageNumber\\\",317:\\\"Predictor\\\",319:\\\"PrimaryChromaticities\\\",532:\\\"ReferenceBlackWhite\\\",339:\\\"SampleFormat\\\",340:\\\"SMinSampleValue\\\",341:\\\"SMaxSampleValue\\\",559:\\\"StripRowCounts\\\",330:\\\"SubIFDs\\\",292:\\\"T4Options\\\",293:\\\"T6Options\\\",325:\\\"TileByteCounts\\\",323:\\\"TileLength\\\",324:\\\"TileOffsets\\\",322:\\\"TileWidth\\\",301:\\\"TransferFunction\\\",318:\\\"WhitePoint\\\",344:\\\"XClipPathUnits\\\",286:\\\"XPosition\\\",529:\\\"YCbCrCoefficients\\\",531:\\\"YCbCrPositioning\\\",530:\\\"YCbCrSubSampling\\\",345:\\\"YClipPathUnits\\\",287:\\\"YPosition\\\",37378:\\\"ApertureValue\\\",40961:\\\"ColorSpace\\\",36868:\\\"DateTimeDigitized\\\",36867:\\\"DateTimeOriginal\\\",34665:\\\"Exif IFD\\\",36864:\\\"ExifVersion\\\",33434:\\\"ExposureTime\\\",41728:\\\"FileSource\\\",37385:\\\"Flash\\\",40960:\\\"FlashpixVersion\\\",33437:\\\"FNumber\\\",42016:\\\"ImageUniqueID\\\",37384:\\\"LightSource\\\",37500:\\\"MakerNote\\\",37377:\\\"ShutterSpeedValue\\\",37510:\\\"UserComment\\\",33723:\\\"IPTC\\\",34675:\\\"ICC Profile\\\",700:\\\"XMP\\\",42112:\\\"GDAL_METADATA\\\",42113:\\\"GDAL_NODATA\\\",34377:\\\"Photoshop\\\",33550:\\\"ModelPixelScale\\\",33922:\\\"ModelTiepoint\\\",34264:\\\"ModelTransformation\\\",34735:\\\"GeoKeyDirectory\\\",34736:\\\"GeoDoubleParams\\\",34737:\\\"GeoAsciiParams\\\",50674:\\\"LercParameters\\\"},ie={};for(var re in te)te.hasOwnProperty(re)&&(ie[te[re]]=parseInt(re,10));ie.BitsPerSample,ie.ExtraSamples,ie.SampleFormat,ie.StripByteCounts,ie.StripOffsets,ie.StripRowCounts,ie.TileByteCounts,ie.TileOffsets,ie.SubIFDs;var Ie={1:\\\"BYTE\\\",2:\\\"ASCII\\\",3:\\\"SHORT\\\",4:\\\"LONG\\\",5:\\\"RATIONAL\\\",6:\\\"SBYTE\\\",7:\\\"UNDEFINED\\\",8:\\\"SSHORT\\\",9:\\\"SLONG\\\",10:\\\"SRATIONAL\\\",11:\\\"FLOAT\\\",12:\\\"DOUBLE\\\",13:\\\"IFD\\\",16:\\\"LONG8\\\",17:\\\"SLONG8\\\",18:\\\"IFD8\\\"},ge={};for(var ne in Ie)Ie.hasOwnProperty(ne)&&(ge[Ie[ne]]=parseInt(ne,10));var ae=1,oe=0,Be=1,Ce=2,Qe={1024:\\\"GTModelTypeGeoKey\\\",1025:\\\"GTRasterTypeGeoKey\\\",1026:\\\"GTCitationGeoKey\\\",2048:\\\"GeographicTypeGeoKey\\\",2049:\\\"GeogCitationGeoKey\\\",2050:\\\"GeogGeodeticDatumGeoKey\\\",2051:\\\"GeogPrimeMeridianGeoKey\\\",2052:\\\"GeogLinearUnitsGeoKey\\\",2053:\\\"GeogLinearUnitSizeGeoKey\\\",2054:\\\"GeogAngularUnitsGeoKey\\\",2055:\\\"GeogAngularUnitSizeGeoKey\\\",2056:\\\"GeogEllipsoidGeoKey\\\",2057:\\\"GeogSemiMajorAxisGeoKey\\\",2058:\\\"GeogSemiMinorAxisGeoKey\\\",2059:\\\"GeogInvFlatteningGeoKey\\\",2060:\\\"GeogAzimuthUnitsGeoKey\\\",2061:\\\"GeogPrimeMeridianLongGeoKey\\\",2062:\\\"GeogTOWGS84GeoKey\\\",3072:\\\"ProjectedCSTypeGeoKey\\\",3073:\\\"PCSCitationGeoKey\\\",3074:\\\"ProjectionGeoKey\\\",3075:\\\"ProjCoordTransGeoKey\\\",3076:\\\"ProjLinearUnitsGeoKey\\\",3077:\\\"ProjLinearUnitSizeGeoKey\\\",3078:\\\"ProjStdParallel1GeoKey\\\",3079:\\\"ProjStdParallel2GeoKey\\\",3080:\\\"ProjNatOriginLongGeoKey\\\",3081:\\\"ProjNatOriginLatGeoKey\\\",3082:\\\"ProjFalseEastingGeoKey\\\",3083:\\\"ProjFalseNorthingGeoKey\\\",3084:\\\"ProjFalseOriginLongGeoKey\\\",3085:\\\"ProjFalseOriginLatGeoKey\\\",3086:\\\"ProjFalseOriginEastingGeoKey\\\",3087:\\\"ProjFalseOriginNorthingGeoKey\\\",3088:\\\"ProjCenterLongGeoKey\\\",3089:\\\"ProjCenterLatGeoKey\\\",3090:\\\"ProjCenterEastingGeoKey\\\",3091:\\\"ProjCenterNorthingGeoKey\\\",3092:\\\"ProjScaleAtNatOriginGeoKey\\\",3093:\\\"ProjScaleAtCenterGeoKey\\\",3094:\\\"ProjAzimuthAngleGeoKey\\\",3095:\\\"ProjStraightVertPoleLongGeoKey\\\",3096:\\\"ProjRectifiedGridAngleGeoKey\\\",4096:\\\"VerticalCSTypeGeoKey\\\",4097:\\\"VerticalCitationGeoKey\\\",4098:\\\"VerticalDatumGeoKey\\\",4099:\\\"VerticalUnitsGeoKey\\\"},Ee={};for(var se in Qe)Qe.hasOwnProperty(se)&&(Ee[Qe[se]]=parseInt(se,10));function fe(A){var e=function(){if(\\\"undefined\\\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\\\"function\\\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var ce=new Ae,he=function(A){s(t,w);var e=fe(t);function t(A){var i;return B(this,t),(i=e.call(this)).planarConfiguration=void 0!==A.PlanarConfiguration?A.PlanarConfiguration:1,i.samplesPerPixel=void 0!==A.SamplesPerPixel?A.SamplesPerPixel:1,i.addCompression=A.LercParameters[ae],i}return Q(t,[{key:\\\"decodeBlock\\\",value:function(A){switch(this.addCompression){case oe:break;case Be:A=YA(new Uint8Array(A)).buffer;break;case Ce:A=ce.decode(new Uint8Array(A)).buffer;break;default:throw new Error(\\\"Unsupported LERC additional compression method identifier: \\\".concat(this.addCompression))}return zA.decode(A,{returnPixelInterleavedDims:1===this.planarConfiguration}).pixels[0].buffer}}]),t}(),le=Object.freeze({__proto__:null,zstd:ce,default:he});function ue(A){var e=function(){if(\\\"undefined\\\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\\\"function\\\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var we=function(A){s(I,w);var t,i=ue(I);function I(){var A;if(B(this,I),A=i.call(this),\\\"undefined\\\"==typeof createImageBitmap)throw new Error(\\\"Cannot decode WebImage as `createImageBitmap` is not available\\\");if(\\\"undefined\\\"==typeof document&&\\\"undefined\\\"==typeof OffscreenCanvas)throw new Error(\\\"Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available\\\");return A}return Q(I,[{key:\\\"decode\\\",value:(t=e(r.mark((function A(e,t){var i,I,g,n;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return i=new Blob([t]),A.next=3,createImageBitmap(i);case 3:return I=A.sent,\\\"undefined\\\"!=typeof document?((g=document.createElement(\\\"canvas\\\")).width=I.width,g.height=I.height):g=new OffscreenCanvas(I.width,I.height),(n=g.getContext(\\\"2d\\\")).drawImage(I,0,0),A.abrupt(\\\"return\\\",n.getImageData(0,0,I.width,I.height).data.buffer);case 8:case\\\"end\\\":return A.stop()}}),A)}))),function(A,e){return t.apply(this,arguments)})}]),I}(),de=Object.freeze({__proto__:null,default:we});\";\n          return new web_worker__WEBPACK_IMPORTED_MODULE_0__[\"default\"](typeof Buffer !== 'undefined' \n            ? 'data:application/javascript;base64,' + Buffer.from(source, 'binary').toString('base64')\n            : URL.createObjectURL(new Blob([source], {type: 'application/javascript'})));\n        }\n      \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS93b3JrZXIvZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSxRQUF3QztBQUN4QyxRQUFlO0FBQ2Ysb0RBQW9ELElBQUksd0JBQXdCLFNBQVMsaUJBQWlCLHlDQUF5QyxjQUFjLGtCQUFrQix1QkFBdUIsa0NBQWtDLG1CQUFtQixjQUFjLHdCQUF3QixjQUFjLHlCQUF5QixVQUFVLElBQUksY0FBYyxxRkFBcUYsZ0JBQWdCLGFBQWEsd0dBQXdHLE1BQU0sT0FBTyxZQUFZLGFBQWEsa0JBQWtCLG1GQUFtRix3R0FBd0csa0JBQWtCLGtDQUFrQyxrREFBa0QsT0FBTyxJQUFJLElBQUksT0FBTyxTQUFTLGtCQUFrQixlQUFlLG9CQUFvQixrRkFBa0YsaUNBQWlDLFFBQVEscUJBQXFCLDJEQUEyRCxVQUFVLHlCQUF5QixXQUFXLHdCQUF3QixFQUFFLGlCQUFpQixNQUFNLGFBQWEsTUFBTSxrQkFBa0IsVUFBVSw0Q0FBNEMsOEJBQThCLHlCQUF5QiwyQkFBMkIsc0RBQXNELElBQUksZUFBZSx3QkFBd0IsbUNBQW1DLE9BQU8seUJBQXlCLDJEQUEyRCxVQUFVLGtCQUFrQixJQUFJLE9BQU8saUNBQWlDLFNBQVMsT0FBTyx1QkFBdUIsU0FBUyxtRkFBbUYsY0FBYyxjQUFjLGNBQWMsU0FBUyxrQkFBa0IsWUFBWSxHQUFHLDZDQUE2Qyw2QkFBNkIsK0NBQStDLGNBQWMscURBQXFELG1CQUFtQix5QkFBeUIsR0FBRyxHQUFHLGdCQUFnQixvQkFBb0Isa0JBQWtCLHVCQUF1QixzQkFBc0IsMEZBQTBGLGtCQUFrQixlQUFlLG1CQUFtQixrQ0FBa0MsZUFBZSxlQUFlLDBCQUEwQixHQUFHLFNBQVMsTUFBTSwyQkFBMkIsYUFBYSw0QkFBNEIsV0FBVyxHQUFHLDRCQUE0QixnQkFBZ0IsMkJBQTJCLFVBQVUseUNBQXlDLHlGQUF5RiwyRkFBMkYsU0FBUyw0QkFBNEIsOEVBQThFLFlBQVksbU9BQW1PLGNBQWMsT0FBTyxhQUFhLDhGQUE4RixjQUFjLHVCQUF1Qiw4Q0FBOEMsY0FBYyxrQkFBa0IsZ0JBQWdCLG1DQUFtQyxjQUFjLE1BQU0sV0FBVyxzQkFBc0Isd0NBQXdDLHFCQUFxQix3QkFBd0IsS0FBSyxhQUFhLGdEQUFnRCw4QkFBOEIsaUJBQWlCLE9BQU8sUUFBUSxhQUFhLE9BQU8saUJBQWlCLGdKQUFnSiw0Q0FBNEMsb0VBQW9FLG9CQUFvQixvSUFBb0kscUJBQXFCLE9BQU8sV0FBVyw0Q0FBNEMsWUFBWSxpREFBaUQsd0JBQXdCLDBCQUEwQiw2REFBNkQsK0JBQStCLEdBQUcsNkNBQTZDLFlBQVksZ0NBQWdDLDZCQUE2QixzQkFBc0IsU0FBUyx5QkFBeUIsZ0NBQWdDLEtBQUssU0FBUyxFQUFFLGNBQWMsdUNBQXVDLG9CQUFvQix5QkFBeUIsZ0NBQWdDLHdPQUF3TyxpQkFBaUIsYUFBYSxvQ0FBb0Msa0NBQWtDLGlCQUFpQiwrQkFBK0IscUJBQXFCLFdBQVcsZ0JBQWdCLDRFQUE0RSxtQ0FBbUMsS0FBSyxLQUFLLHdDQUF3Qyx5Q0FBeUMsd0JBQXdCLHdEQUF3RCxTQUFTLGdEQUFnRCxpREFBaUQsV0FBVyxnREFBZ0QsS0FBSyxrRUFBa0Usb0RBQW9ELHNCQUFzQixtQ0FBbUMsS0FBSyxLQUFLLHlCQUF5QiwwRUFBMEUsUUFBUSxPQUFPLDZFQUE2RSx3QkFBd0IsMkZBQTJGLHdCQUF3QixrQ0FBa0MsZ01BQWdNLG9CQUFvQixtQ0FBbUMsS0FBSyxLQUFLLHlCQUF5QiwwRUFBMEUsbUJBQW1CLG1DQUFtQyxLQUFLLEtBQUsseUJBQXlCLGlCQUFpQixtQkFBbUIsdUJBQXVCLFlBQVksS0FBSyxVQUFVLDJDQUEyQywrQkFBK0Isc0JBQXNCLHFDQUFxQyx5Q0FBeUMsR0FBRyxZQUFZLElBQUkscUJBQXFCLFNBQVMsMkpBQTJKLElBQUksMEJBQTBCLGdCQUFnQixpREFBaUQsa0JBQWtCLEdBQUcsY0FBYywrQkFBK0IsYUFBYSxpQ0FBaUMsUUFBUSwyQkFBMkIsTUFBTSx1QkFBdUIsa0NBQWtDLFNBQVMsTUFBTSxtRkFBbUYsMkJBQTJCLHFEQUFxRCxvQ0FBb0MsS0FBSywyQkFBMkIseUJBQXlCLDBDQUEwQyxTQUFTLHFCQUFxQixpQkFBaUIsR0FBRyxtQkFBbUIsMENBQTBDLFNBQVMscUJBQXFCLGlCQUFpQixHQUFHLG1CQUFtQixrRUFBa0UsbUJBQW1CLDBDQUEwQyxTQUFTLHFCQUFxQixpQkFBaUIsR0FBRywyQkFBMkIsMENBQTBDLFVBQVUscUJBQXFCLGlCQUFpQixHQUFHLHVCQUF1QiwwQ0FBMEMsVUFBVSxxQkFBcUIsaUJBQWlCLEdBQUcsdUJBQXVCLDBDQUEwQyxVQUFVLG1CQUFtQiw4QkFBOEIsMkJBQTJCLE1BQU0sdUJBQXVCLHFDQUFxQyxxQ0FBcUMsb0NBQW9DLEtBQUssSUFBSSxtQkFBbUIsZ0NBQWdDLHNCQUFzQixpQkFBaUIsR0FBRyx1QkFBdUIsMENBQTBDLFVBQVUscUJBQXFCLGlCQUFpQixHQUFHLEdBQUcsaUJBQWlCLGdCQUFnQixnRkFBZ0YsZ0JBQWdCLFlBQVksV0FBVyxLQUFLLFdBQVcsaUhBQWlILGtCQUFrQix1Q0FBdUMsZ0JBQWdCLDhDQUE4Qyx1QkFBdUIsUUFBUSxnQkFBZ0IsZ0hBQWdILDBDQUEwQyxhQUFhLHFDQUFxQyxZQUFZLGdCQUFnQiwyREFBMkQsZ0dBQWdHLG1CQUFtQixzR0FBc0csU0FBUyxJQUFJLGNBQWMsaUVBQWlFLDZDQUE2QyxNQUFNLGdCQUFnQixxQkFBcUIsR0FBRyxZQUFZLElBQUkscUJBQXFCLEtBQUssV0FBVyxrQkFBa0IsNkJBQTZCLElBQUksRUFBRSxZQUFZLElBQUkscUJBQXFCLEtBQUssd0JBQXdCLElBQUksZ0JBQWdCLElBQUksNEJBQTRCLHdCQUF3QixzQkFBc0IsWUFBWSxXQUFXLEtBQUssdUdBQXVHLHVHQUF1Ryx3Q0FBd0MsOEJBQThCLEtBQUssYUFBYSxVQUFVLGFBQWEseUNBQXlDLE1BQU0sNkNBQTZDLE1BQU0sNkNBQTZDLE1BQU0sOEZBQThGLE9BQU8scURBQXFELFNBQVMsMENBQTBDLDhCQUE4QixnQkFBZ0IsMkJBQTJCLE1BQU0sdUJBQXVCLHlFQUF5RSw4Q0FBOEMsK0JBQStCLGVBQWUsTUFBTSxvQ0FBb0MsS0FBSyxJQUFJLG1CQUFtQixnQ0FBZ0MsSUFBSSxpQkFBaUIsYUFBYSxVQUFVLE1BQU0sYUFBYSxrREFBa0QsY0FBYywyQkFBMkIsTUFBTSx1QkFBdUIsMkNBQTJDLDJDQUEyQyxTQUFTLE1BQU0sMktBQTJLLHFDQUFxQyxxQ0FBcUMsVUFBVSxrQkFBa0IsK0JBQStCLEVBQUUsS0FBSyxHQUFHLGNBQWMsaUJBQWlCLDhEQUE4RCxtQ0FBbUMsdUNBQXVDLElBQUksZ0ZBQWdGLE9BQU8sU0FBUyxVQUFVLEdBQUcsa0JBQWtCLGFBQWEsTUFBTSwwQkFBMEIsbUNBQW1DLCtCQUErQixrQkFBa0Isa0JBQWtCLE9BQU8sV0FBVyxhQUFhLHlDQUF5QyxhQUFhLHNDQUFzQyxVQUFVLEtBQUssb0JBQW9CLHlCQUF5QixFQUFFLGNBQWMsaUJBQWlCLDhEQUE4RCxtQ0FBbUMsdUNBQXVDLElBQUksZ0ZBQWdGLE9BQU8sU0FBUyxVQUFVLEdBQUcsa0JBQWtCLGFBQWEsTUFBTSwwQkFBMEIsbUNBQW1DLCtCQUErQixrQkFBa0IsZ0JBQWdCLHFCQUFxQixLQUFLLGlCQUFpQixTQUFTLGNBQWMsMkRBQTJELE9BQU8scUJBQXFCLGtCQUFrQixhQUFhLFVBQVUsY0FBYyxzQkFBc0IsNEVBQTRFLHNJQUFzSSx1Q0FBdUMsaUJBQWlCLGlCQUFpQix1QkFBdUIsc0JBQXNCLG9CQUFvQixjQUFjLFNBQVMsUUFBUSxjQUFjLGdCQUFnQiwyQkFBMkIsY0FBYyxpQkFBaUIsU0FBUyxvQkFBb0IsU0FBUyxTQUFTLElBQUkscUNBQXFDLFFBQVEsRUFBRSxZQUFZLGVBQWUsUUFBUSxRQUFRLGlCQUFpQixvRUFBb0UsY0FBYyxhQUFhLFdBQVcsOEJBQThCLEtBQUssV0FBVyxtSEFBbUgsb0RBQW9ELGlEQUFpRCx5QkFBeUIsa0JBQWtCLE9BQU8sV0FBVyxhQUFhLHlDQUF5QyxhQUFhLHNDQUFzQyxvQkFBb0IsS0FBSyxvQkFBb0IseUJBQXlCLEVBQUUsY0FBYyxpQkFBaUIsOERBQThELG1DQUFtQyx1Q0FBdUMsSUFBSSxnRkFBZ0YsT0FBTyxTQUFTLFVBQVUsR0FBRyxrQkFBa0IsYUFBYSxNQUFNLDBCQUEwQixtQ0FBbUMsK0JBQStCLGtCQUFrQiw4TUFBOE0sZ0JBQWdCLHNCQUFzQixhQUFhLEtBQUssUUFBUSxvQkFBb0IsRUFBRSxxQkFBcUIsSUFBSSxLQUFLLFlBQVksT0FBTyxLQUFLLHVDQUF1QyxVQUFVLFdBQVcsd0JBQXdCLFlBQVksV0FBVyxvQkFBb0IscUNBQXFDLElBQUksa0JBQWtCLG9CQUFvQixzQ0FBc0MscUJBQXFCLDhCQUE4QixvREFBb0QsYUFBYSx5QkFBeUIscUJBQXFCLGFBQWEsNEVBQTRFLGlCQUFpQixjQUFjLGNBQWMsZUFBZSxFQUFFLHVDQUF1QyxtRUFBbUUsWUFBWSxjQUFjLGdCQUFnQixJQUFJLEVBQUUsVUFBVSxtQkFBbUIsYUFBYSxTQUFTLGNBQWMsV0FBVywrQkFBK0IsUUFBUSxVQUFVLHNCQUFzQixvQ0FBb0Msb0JBQW9CLGtCQUFrQiw4Q0FBOEMsb0JBQW9CLDJCQUEyQiw4QkFBOEIsNENBQTRDLHNCQUFzQixlQUFlLGFBQWEscUJBQXFCLFdBQVcscUJBQXFCLEtBQUssRUFBRSx3Q0FBd0MsVUFBVSxTQUFTLGdCQUFnQixNQUFNLE1BQU0saUNBQWlDLGVBQWUsb0JBQW9CLEtBQUssRUFBRSx5QkFBeUIsVUFBVSx3Q0FBd0Msb0RBQW9ELEtBQUssbURBQW1ELGVBQWUsU0FBUywwREFBMEQsTUFBTSw2Q0FBNkMsTUFBTSxnQ0FBZ0MsSUFBSSxxQkFBcUIsZUFBZSx5Q0FBeUMsc0JBQXNCLFlBQVksS0FBSyxFQUFFLHdDQUF3QyxVQUFVLGNBQWMsTUFBTSwyQkFBMkIsWUFBWSxrRUFBa0UsZUFBZSxJQUFJLEVBQUUsUUFBUSxJQUFJLGdCQUFnQiw0QkFBNEIsSUFBSSxpQkFBaUIsYUFBYSxJQUFJLEtBQUssUUFBUSxJQUFJLEtBQUsseUJBQXlCLFFBQVEsSUFBSSxZQUFZLElBQUksaUJBQWlCLGlCQUFpQiwwRUFBMEUsK0JBQStCLEtBQUssV0FBVyxnQkFBZ0IsZ0dBQWdHLGtCQUFrQixrREFBa0QsUUFBUSxLQUFLLG1CQUFtQixRQUFRLElBQUksS0FBSyxVQUFVLDJyQkFBMnJCLFFBQVEsSUFBSSxLQUFLLFFBQVEsMnRCQUEydEIsUUFBUSxLQUFLLEtBQUssc0JBQXNCLHdCQUF3QixZQUFZLElBQUksS0FBSyxtQkFBbUIsSUFBSSw4QkFBOEIsWUFBWSxJQUFJLEtBQUssc0JBQXNCLHVCQUF1QixJQUFJLHlCQUF5QixJQUFJLG1CQUFtQixTQUFTLGlCQUFpQixhQUFhLHVJQUF1SSxhQUFhLHFDQUFxQyxnQkFBZ0IsRUFBRSxnQ0FBZ0MsUUFBUSxhQUFhLHFCQUFxQixjQUFjLGNBQWMsZ0JBQWdCLHdHQUF3RyxtRUFBbUUseURBQXlELGtCQUFrQiw4SEFBOEgsSUFBSSxLQUFLLGlCQUFpQixJQUFJLCtCQUErQixVQUFVLGlEQUFpRCxvREFBb0QsY0FBYyxnREFBZ0QsVUFBVSxVQUFVLEVBQUUsVUFBVSxpQkFBaUIsK1BBQStQLDZFQUE2RSxTQUFTLHNCQUFzQiw4SUFBOEksOEZBQThGLDBFQUEwRSxFQUFFLE1BQU0sNkJBQTZCLElBQUksRUFBRSxrQ0FBa0MsdUJBQXVCLEtBQUssS0FBSyxlQUFlLEtBQUssd0RBQXdELFlBQVksS0FBSyxLQUFLLGFBQWEsZ0NBQWdDLE1BQU0scUNBQXFDLFdBQVcsd0dBQXdHLG9CQUFvQix1QkFBdUIsSUFBSSxLQUFLLE9BQU8scUNBQXFDLDJDQUEyQywwQkFBMEIsTUFBTSx5QkFBeUIsTUFBTSw2QkFBNkIsSUFBSSxFQUFFLDhDQUE4QyxLQUFLLDBCQUEwQixnQ0FBZ0MsSUFBSSxrQkFBa0Isb0ZBQW9GLE1BQU0sc0NBQXNDLE1BQU0sZUFBZSwyQ0FBMkMsSUFBSSxLQUFLLG9DQUFvQyxrR0FBa0csNkVBQTZFLEtBQUssTUFBTSwyQkFBMkIsTUFBTSxtREFBbUQsS0FBSyxNQUFNLGlFQUFpRSxRQUFRLEVBQUUsbUNBQW1DLGtCQUFrQixzRUFBc0UsNkVBQTZFLFlBQVkscUJBQXFCLDZEQUE2RCxXQUFXLEtBQUssV0FBVyxpR0FBaUcsNEZBQTRGLFdBQVcsS0FBSyxjQUFjLFFBQVEsaURBQWlELEVBQUUsK0NBQStDLElBQUksZ0JBQWdCLElBQUksZ0JBQWdCLFdBQVcsS0FBSyxXQUFXLDZDQUE2QyxVQUFVLEtBQUssaUJBQWlCLE9BQU8sV0FBVyxjQUFjLE1BQU0sNEZBQTRGLGFBQWEsc0NBQXNDLHNHQUFzRyxLQUFLLG9CQUFvQix5QkFBeUIsRUFBRSxjQUFjLG1CQUFtQixPQUFPLFFBQVEseUdBQXlHLHdCQUF3Qix5Q0FBeUMsTUFBTSxFQUFFLGlCQUFpQixHQUFHLHFCQUFxQixXQUFXLGtCQUFrQixpQkFBaUIsOEJBQThCLG1CQUFtQixNQUFNLEtBQUssSUFBSSxZQUFZLElBQUksaUNBQWlDLE9BQU8sU0FBUyx3QkFBd0IsY0FBYyxNQUFNLFlBQVksSUFBSSw0QkFBNEIsV0FBVyxJQUFJLHlNQUF5TSxJQUFJLDZZQUE2WSxpQkFBaUIsaURBQWlELGVBQWUsa0RBQWtELFNBQVMsRUFBRSxnQkFBZ0IsTUFBTSxtRUFBbUUsb0NBQW9DLFNBQVMsZUFBZSwyQkFBMkIsSUFBSSxtQkFBbUIsK0NBQStDLElBQUksS0FBSyxXQUFXLHVCQUF1QixTQUFTLE1BQU0sSUFBSSxrREFBa0QsU0FBUyxLQUFLLGtDQUFrQyxNQUFNLHdEQUF3RCxnQkFBZ0Isa0JBQWtCLG9HQUFvRyw2QkFBNkIsUUFBUSxJQUFJLDJKQUEySixnQ0FBZ0MsSUFBSSxpVUFBaVUsU0FBUyxpQkFBaUIsc0JBQXNCLGtIQUFrSCxxQkFBcUIsWUFBWSxJQUFJLEVBQUUsYUFBYSxrQkFBa0IsS0FBSyxXQUFXLDJCQUEyQixLQUFLLDJCQUEyQixTQUFTLHNCQUFzQiwyRkFBMkYscUJBQXFCLGdHQUFnRyxtQkFBbUIsSUFBSSxpQ0FBaUMsU0FBUyxNQUFNLGlCQUFpQix1Q0FBdUMsY0FBYyxzQkFBc0IsS0FBSyxxQ0FBcUMsaUJBQWlCLDhMQUE4TCxpQkFBaUIsOERBQThELCtPQUErTyxLQUFLLHFEQUFxRCxRQUFRLEVBQUUsd0RBQXdELEtBQUssWUFBWSxjQUFjLDRCQUE0QixXQUFXLFNBQVMsVUFBVSxRQUFRLGdEQUFnRCxRQUFRLDZIQUE2SCxRQUFRLEVBQUUsNENBQTRDLGNBQWMsNEJBQTRCLFdBQVcsMENBQTBDLFFBQVEsd0ZBQXdGLGtEQUFrRCxRQUFRLDBCQUEwQixzQkFBc0Isa0RBQWtELFFBQVEsa0JBQWtCLGVBQWUsS0FBSyxHQUFHLGNBQWMsV0FBVyxXQUFXLGFBQWEsc0JBQXNCLEtBQUssR0FBRyxjQUFjLFdBQVcsWUFBWSxPQUFPLEdBQUcsY0FBYyxXQUFXLFlBQVksb0JBQW9CLEtBQUssR0FBRyxjQUFjLFdBQVcsVUFBVSxLQUFLLElBQUksZ0RBQWdELHdDQUF3QyxLQUFLLE1BQU0sR0FBRywrQ0FBK0MsV0FBVyx3Q0FBd0MsT0FBTyxPQUFPLGdCQUFnQix3SUFBd0ksK2ZBQStmLHlJQUF5SSxRQUFRLE1BQU0sV0FBVyxRQUFRLElBQUksZ0JBQWdCLGFBQWEsZUFBZSxLQUFLLHNFQUFzRSxRQUFRLGNBQWMsS0FBSyx1QkFBdUIsTUFBTSxrQ0FBa0MsZ0NBQWdDLGVBQWUsS0FBSyxxQkFBcUIsUUFBUSxJQUFJLG1DQUFtQywySkFBMkosTUFBTSxFQUFFLHdGQUF3RixHQUFHLG1DQUFtQyxhQUFhLGFBQWEsSUFBSSxPQUFPLDBDQUEwQyxlQUFlLFlBQVksbUJBQW1CLG1DQUFtQyx5QkFBeUIsV0FBVywrQ0FBK0MsNEJBQTRCLG1EQUFtRCw2TEFBNkwsK0RBQStELGNBQWMsdWdCQUF1Z0IseUJBQXlCLDBCQUEwQixjQUFjLDhQQUE4UCxnQkFBZ0IsMEJBQTBCLGNBQWMsMkNBQTJDLGtCQUFrQixNQUFNLDBCQUEwQixjQUFjLDRJQUE0SSxrQkFBa0IsZ0JBQWdCLGFBQWEsd0JBQXdCLGNBQWMsZ0NBQWdDLHNCQUFzQixPQUFPLDZDQUE2QyxZQUFZLE1BQU0sZUFBZSxLQUFLLE1BQU0sZUFBZSxLQUFLLE1BQU0sZUFBZSxLQUFLLE1BQU0sZUFBZSxtQ0FBbUMsT0FBTyxNQUFNLEtBQUssZUFBZSw4QkFBOEIsT0FBTyxRQUFRLG9EQUFvRCxzQkFBc0IsZ0JBQWdCLDZZQUE2WSxLQUFLLDZFQUE2RSxnQkFBZ0IsdUNBQXVDLCtJQUErSSwrREFBK0QsMklBQTJJLFFBQVEsZ0JBQWdCLHNCQUFzQixVQUFVLE1BQU0sS0FBSyxLQUFLLEVBQUUsaUJBQWlCLHNCQUFzQix3QkFBd0IsOEVBQThFLE1BQU0sNkVBQTZFLDJDQUEyQyxNQUFNLGdCQUFnQiwrQ0FBK0MsTUFBTSxnREFBZ0QsbUJBQW1CLHdDQUF3QyxNQUFNLCtEQUErRCxNQUFNLFlBQVksS0FBSyxFQUFFLGlCQUFpQixzQkFBc0IsaUNBQWlDLCtDQUErQyxNQUFNLGtCQUFrQiw2Q0FBNkMsTUFBTSxnSEFBZ0gsWUFBWSxLQUFLLEVBQUUsaUJBQWlCLHNCQUFzQiwySUFBMkksWUFBWSxLQUFLLEVBQUUsaUJBQWlCLHNCQUFzQixnSUFBZ0ksd0JBQXdCLEtBQUssS0FBSyxFQUFFLGlCQUFpQixzQkFBc0Isa0hBQWtILGlDQUFpQyxTQUFTLDhRQUE4USxvQkFBb0Isd0JBQXdCLGlCQUFpQixJQUFJLEdBQUcsNEVBQTRFLGNBQWMsK0RBQStELGdDQUFnQyxvQkFBb0Isd0JBQXdCLGlCQUFpQixJQUFJLEdBQUcsK0VBQStFLGNBQWMsK0RBQStELG1DQUFtQyxTQUFTLHVCQUF1QixLQUFLLEtBQUssRUFBRSxpQkFBaUIsc0JBQXNCLHdCQUF3Qix3Q0FBd0MsTUFBTSxRQUFRLDhFQUE4RSxNQUFNLGFBQWEsS0FBSyxFQUFFLGlCQUFpQixzQkFBc0Isd0NBQXdDLDBHQUEwRyw0QkFBNEIsa0NBQWtDLG1CQUFtQiwwQkFBMEIsTUFBTSxLQUFLLElBQUksRUFBRSxpQkFBaUIsc0JBQXNCLG1DQUFtQyxpQkFBaUIsTUFBTSxrQ0FBa0MsWUFBWSxRQUFRLE1BQU0saUJBQWlCLE1BQU0sOENBQThDLFlBQVksTUFBTSw0QkFBNEIsS0FBSyxFQUFFLGlCQUFpQixzQkFBc0IsOEJBQThCLGlEQUFpRCxNQUFNLHFEQUFxRCxrQkFBa0IsdUJBQXVCLHVDQUF1QywyREFBMkQsTUFBTSxVQUFVLE1BQU0sYUFBYSxLQUFLLEVBQUUsaUJBQWlCLHNCQUFzQixtSEFBbUgsd0RBQXdELE1BQU0sbUJBQW1CLGFBQWEsZUFBZSxFQUFFLEtBQUssSUFBSSxFQUFFLGlCQUFpQixzQkFBc0Isb0NBQW9DLEtBQUssVUFBVSx1QkFBdUIscUNBQXFDLGVBQWUsOERBQThELDZDQUE2QyxNQUFNLG1CQUFtQixhQUFhLHNCQUFzQixFQUFFLEtBQUssd0VBQXdFLEVBQUUsaUJBQWlCLHNCQUFzQix1Q0FBdUMsS0FBSyxXQUFXLFVBQVUsSUFBSSxFQUFFLGlCQUFpQixzQkFBc0IsMkJBQTJCLDhDQUE4QyxNQUFNLHlDQUF5QyxnQkFBZ0IsVUFBVSxJQUFJLEVBQUUsaUJBQWlCLHNCQUFzQixzQ0FBc0MsS0FBSyxVQUFVLElBQUksRUFBRSxpQkFBaUIsc0JBQXNCLHlDQUF5Qyw0QkFBNEIsOENBQThDLE1BQU0sS0FBSyxJQUFJLHFCQUFxQixxQkFBcUIsb0JBQW9CLHlEQUF5RCxNQUFNLGtCQUFrQixlQUFlLGtFQUFrRSxnREFBZ0QsTUFBTSx3Q0FBd0MsZ0JBQWdCLDBFQUEwRSwwQ0FBMEMsTUFBTSw0QkFBNEIsa0JBQWtCLHlCQUF5QixpTUFBaU0sTUFBTSxhQUFhLHdFQUF3RSxFQUFFLGlCQUFpQixzQkFBc0Isa0JBQWtCLGdCQUFnQiw2RUFBNkUsRUFBRSxpQkFBaUIsc0JBQXNCLHNCQUFzQiwyQ0FBMkMsVUFBVSxNQUFNLFNBQVMsb0JBQW9CLE1BQU0sU0FBUyxnREFBZ0QsTUFBTSx1QkFBdUIsb0JBQW9CLGNBQWMsSUFBSSxFQUFFLGlCQUFpQixzQkFBc0IsbUVBQW1FLHlCQUF5QixhQUFhLDBFQUEwRSxFQUFFLGlCQUFpQixzQkFBc0IsZUFBZSxnQkFBZ0IsOEVBQThFLEVBQUUsaUJBQWlCLHNCQUFzQixzQkFBc0IsK0JBQStCLDBDQUEwQyxNQUFNLGtDQUFrQyxvQkFBb0IsY0FBYyxJQUFJLEVBQUUsaUJBQWlCLHNCQUFzQixtRUFBbUUsb0JBQW9CLGtEQUFrRCxNQUFNLFVBQVUseUJBQXlCLHFCQUFxQixtQ0FBbUMsa0RBQWtELE1BQU0sbUZBQW1GLGlDQUFpQyw0QkFBNEIsR0FBRyxjQUFjLFdBQVcsMEJBQTBCLE1BQU0seUJBQXlCLDhCQUE4QixNQUFNLG1CQUFtQixLQUFLLEtBQUssRUFBRSxpQkFBaUIsc0JBQXNCLHNJQUFzSSx5Q0FBeUMsTUFBTSxRQUFRLFVBQVUsNEJBQTRCLEtBQUssS0FBSyxFQUFFLGlCQUFpQixzQkFBc0IsNkJBQTZCLDJDQUEyQyxNQUFNLFFBQVEsVUFBVSxhQUFhLFFBQVEsYUFBYSxRQUFRLGtCQUFrQixrQkFBa0Isa2RBQWtkLHdCQUF3QiwwQkFBMEIsY0FBYyxpREFBaUQsZ0NBQWdDLDBCQUEwQixjQUFjLGdEQUFnRCxvQ0FBb0MsaUJBQWlCLDRJQUE0SSxxREFBcUQsa0JBQWtCLDJJQUEySSxnS0FBZ0ssZUFBZSxnQkFBZ0Isc0NBQXNDLE1BQU0sRUFBRSxtQkFBbUIsMlZBQTJWLDhDQUE4QyxnQ0FBZ0Msa1VBQWtVLGlCQUFpQixnQkFBZ0IseUNBQXlDLGdCQUFnQixnQ0FBZ0MseUVBQXlFLHVCQUF1Qiw4SUFBOEksRUFBRSxtTEFBbUwsdURBQXVELHNDQUFzQyxVQUFVLHNFQUFzRSx3RkFBd0YsNERBQTRELHdGQUF3Rix3RkFBd0Ysa0JBQWtCLDJFQUEyRSx5QkFBeUIsU0FBUyxpQ0FBaUMsb0JBQW9CLGdDQUFnQyx1SkFBdUosUUFBUSwrQ0FBK0MsY0FBYyxpQkFBaUIsdUJBQXVCLFNBQVMsZUFBZSxpQkFBaUIsOERBQThELG1DQUFtQyx1Q0FBdUMsSUFBSSxnRkFBZ0YsT0FBTyxTQUFTLFVBQVUsR0FBRyxrQkFBa0IsYUFBYSxNQUFNLDBCQUEwQixtQ0FBbUMsK0JBQStCLGtCQUFrQixtQkFBbUIsT0FBTyxZQUFZLGFBQWEseUNBQXlDLGFBQWEsc0NBQXNDLHFDQUFxQyxLQUFLLHFCQUFxQiwwQkFBMEIsRUFBRSxlQUFlLGlCQUFpQiw4REFBOEQsbUNBQW1DLHVDQUF1QyxJQUFJLGdGQUFnRixPQUFPLFNBQVMsVUFBVSxHQUFHLGtCQUFrQixhQUFhLE1BQU0sMEJBQTBCLG1DQUFtQywrQkFBK0Isa0JBQWtCLHNCQUFzQixPQUFPLFlBQVksYUFBYSx5Q0FBeUMsYUFBYSxzQ0FBc0MsbUNBQW1DLGVBQWUsS0FBSyxtQkFBbUIsUUFBUSxzQkFBc0IsS0FBSyxZQUFZLEtBQUssY0FBYyxLQUFLLEtBQUssWUFBWSxLQUFLLDhCQUE4QixRQUFRLGlDQUFpQyxLQUFLLHFCQUFxQiwwQkFBMEIsTUFBTSxZQUFZLHVHQUF1Ryw2S0FBNkssMENBQTBDLDhEQUE4RCxjQUFjLHFNQUFxTSxxSEFBcUgsNE5BQTROLHVCQUF1Qiw4SUFBOEksc0dBQXNHLHdDQUF3QyxLQUFLLEtBQUsseUJBQXlCLHFCQUFxQixLQUFLLEtBQUssd0JBQXdCLFVBQVUsK0RBQStELDZLQUE2SyxJQUFJLEtBQUssaUNBQWlDLElBQUksaUhBQWlILEtBQUssNkJBQTZCLElBQUksS0FBSyxRQUFRLElBQUksZ0NBQWdDLEtBQUssdUJBQXVCLElBQUksS0FBSyxRQUFRLElBQUksYUFBYSxLQUFLLDZFQUE2RSxNQUFNLE9BQU8sd0NBQXdDLGVBQWUsT0FBTyxtTEFBbUwsNEdBQTRHLGNBQWMsZ0pBQWdKLGVBQWUsc0RBQXNELEtBQUssSUFBSSxLQUFLLHlCQUF5Qix3RUFBd0Usc0JBQXNCLG1CQUFtQixRQUFRLDBCQUEwQiw4S0FBOEssTUFBTSwyQkFBMkIsaU1BQWlNLHdLQUF3SyxtSEFBbUgsR0FBRyxZQUFZLElBQUksd0JBQXdCLEtBQUssc0JBQXNCLFNBQVMsSUFBSSxVQUFVLHdCQUF3Qix5QkFBeUIsdUVBQXVFLG1DQUFtQywySEFBMkgsa0NBQWtDLDZKQUE2Siw2RkFBNkYsK0JBQStCLGdCQUFnQixJQUFJLGdCQUFnQixJQUFJLEtBQUsseUJBQXlCLG1DQUFtQyxTQUFTLHVCQUF1QixvQkFBb0IsdUZBQXVGLG1CQUFtQixpQkFBaUIsd0RBQXdELDZDQUE2QyxLQUFLLDRDQUE0QyxpQ0FBaUMsbUlBQW1JLHNEQUFzRCxLQUFLLGlEQUFpRCx5Q0FBeUMsTUFBTSwwQ0FBMEMsOEJBQThCLG9FQUFvRSxzRUFBc0UsMEJBQTBCLG1CQUFtQix3QkFBd0Isb0VBQW9FLDJHQUEyRyxTQUFTLHVCQUF1QiwyQkFBMkIsZ0ZBQWdGLDRCQUE0QixJQUFJLEtBQUssZ0RBQWdELEtBQUssVUFBVSxzQ0FBc0MsaUJBQWlCLFNBQVMsbUNBQW1DLCtEQUErRCxpQ0FBaUMsSUFBSSwyR0FBMkcsa0NBQWtDLElBQUksa0hBQWtILHlCQUF5Qix3RUFBd0Usb0JBQW9CLHlCQUF5QixRQUFRLElBQUksa0hBQWtILHNCQUFzQiw2QkFBNkIsbUNBQW1DLGFBQWEsSUFBSSwrSEFBK0gsS0FBSyx5QkFBeUIsUUFBUSxJQUFJLHNJQUFzSSxTQUFTLHlCQUF5QixtRUFBbUUsUUFBUSxJQUFJLHNJQUFzSSxzQkFBc0IscUJBQXFCLDZEQUE2RCw0QkFBNEIsSUFBSSx3R0FBd0csU0FBUyxxQkFBcUIsbUNBQW1DLFFBQVEsSUFBSSw0SEFBNEgsU0FBUyxJQUFJLDhEQUE4RCx5REFBeUQsRUFBRSxFQUFFLG1CQUFtQixLQUFLLEdBQUcsMEJBQTBCLFdBQVcsMENBQTBDLG9GQUFvRiw4QkFBOEIseUNBQXlDLG9NQUFvTSxLQUFLLCtDQUErQywra0JBQStrQixTQUFTLGlDQUFpQywwS0FBMEssV0FBVyxXQUFXLFFBQVEsWUFBWSxvQkFBb0IsS0FBSyxNQUFNLHFDQUFxQyxnQ0FBZ0MsTUFBTSwwQ0FBMEMsS0FBSyx5QkFBeUIsd0RBQXdELFNBQVMsd0JBQXdCLCtGQUErRiwwRkFBMEYsNkdBQTZHLHNCQUFzQixpQ0FBaUMsa0VBQWtFLEdBQUcsWUFBWSxJQUFJLHdCQUF3QixnQ0FBZ0MsSUFBSSxVQUFVLHdCQUF3QixvQkFBb0IsdUVBQXVFLG9CQUFvQixZQUFZLFFBQVEsSUFBSSxzREFBc0QsK0NBQStDLDJCQUEyQixvQ0FBb0MseUlBQXlJLDBDQUEwQyxLQUFLLHlCQUF5Qix3REFBd0QsNkVBQTZFLEtBQUssaUNBQWlDLG9CQUFvQixRQUFRLE1BQU0sUUFBUSxJQUFJLHdCQUF3QixJQUFJLHlDQUF5QyxhQUFhLElBQUksMEJBQTBCLElBQUksc0NBQXNDLGFBQWEsSUFBSSw0Q0FBNEMsdUJBQXVCLCtCQUErQiwyREFBMkQscUVBQXFFLDhEQUE4RCxpQkFBaUIsMkJBQTJCLG9CQUFvQixpQkFBaUIsUUFBUSxJQUFJLHNCQUFzQiwwQkFBMEIsaUVBQWlFLGlEQUFpRCxtQ0FBbUMsZUFBZSxJQUFJLHlJQUF5SSxvQkFBb0IsUUFBUSxXQUFXLDhDQUE4QyxXQUFXLG1CQUFtQixRQUFRLElBQUksd0ZBQXdGLElBQUksYUFBYSxpQ0FBaUMsS0FBSyw4R0FBOEcsT0FBTyxrRkFBa0YsK0JBQStCLHNSQUFzUixlQUFlLGlEQUFpRCxXQUFXLFFBQVEsSUFBSSx1RkFBdUYsSUFBSSxZQUFZLElBQUksU0FBUyxnRkFBZ0YsZ0VBQWdFLElBQUksdURBQXVELGdCQUFnQixNQUFNLGlGQUFpRixpQkFBaUIsSUFBSSxZQUFZLElBQUksaUJBQWlCLGdGQUFnRixnRUFBZ0UsSUFBSSx1REFBdUQsZ0JBQWdCLE1BQU0sd0dBQXdHLGlCQUFpQixJQUFJLFlBQVksSUFBSSxnQ0FBZ0MsSUFBSSxVQUFVLGdGQUFnRixnRUFBZ0UsSUFBSSx1REFBdUQsZ0JBQWdCLE1BQU0scUNBQXFDLHFIQUFxSCxnQ0FBZ0MsOEhBQThILElBQUksK0NBQStDLDZCQUE2Qix1Q0FBdUMsS0FBSyxpREFBaUQseUJBQXlCLDBFQUEwRSxNQUFNLHVNQUF1TSxRQUFRLEtBQUssc05BQXNOLGlSQUFpUiw2QkFBNkIsd0lBQXdJLDJEQUEyRCwrTUFBK00sUUFBUSxJQUFJLDBCQUEwQixJQUFJLDRDQUE0QyxJQUFJLEtBQUssd0hBQXdILGtKQUFrSixxQ0FBcUMsaUVBQWlFLG1CQUFtQiw4QkFBOEIsMExBQTBMLElBQUksS0FBSyxRQUFRLElBQUksNEJBQTRCLEtBQUssYUFBYSxJQUFJLEtBQUssUUFBUSxJQUFJLGtCQUFrQixLQUFLLFdBQVcsa0pBQWtKLElBQUksS0FBSyxRQUFRLElBQUksNENBQTRDLEtBQUssYUFBYSxJQUFJLEtBQUssUUFBUSxJQUFJLG9DQUFvQyxLQUFLLDREQUE0RCxJQUFJLEtBQUssUUFBUSxJQUFJLGlDQUFpQyxLQUFLLGFBQWEsSUFBSSxLQUFLLFFBQVEsSUFBSSx5QkFBeUIsS0FBSyxrQkFBa0IsSUFBSSxLQUFLLFFBQVEsSUFBSSw0QkFBNEIsS0FBSyxhQUFhLElBQUksS0FBSyxRQUFRLElBQUksa0JBQWtCLEtBQUssS0FBSyxrQkFBa0IsSUFBSSxZQUFZLElBQUksMEJBQTBCLGFBQWEsSUFBSSxZQUFZLElBQUksa0JBQWtCLCtCQUErQixtRkFBbUYsNEJBQTRCLE9BQU8seVpBQXlaLHlCQUF5QixjQUFjLGdKQUFnSix3Q0FBd0MsK0xBQStMLGFBQWEsYUFBYSxJQUFJLHlCQUF5QixJQUFJLHFCQUFxQixhQUFhLElBQUksMEJBQTBCLElBQUksZ0JBQWdCLGFBQWEsSUFBSSxtQkFBbUIsZ0NBQWdDLElBQUkseUJBQXlCLElBQUksYUFBYSxhQUFhLElBQUksa0JBQWtCLElBQUksZ0JBQWdCLGFBQWEsTUFBTSxXQUFXLDhCQUE4QixNQUFNLFVBQVUsbUJBQW1CLE1BQU0sb0JBQW9CLE1BQU0sb0JBQW9CLE1BQU0scUJBQXFCLE1BQU0sb0JBQW9CLE1BQU0scUJBQXFCLE1BQU0sOEJBQThCLE1BQU0sc0JBQXNCLFNBQVMsMEJBQTBCLE1BQU0sVUFBVSxnQkFBZ0IsTUFBTSxnQkFBZ0IsTUFBTSxpQkFBaUIsTUFBTSxpQkFBaUIsTUFBTSxpQkFBaUIsTUFBTSxpQkFBaUIsTUFBTSx5QkFBeUIsTUFBTSxpQkFBaUIsU0FBUyxpQ0FBaUMsb0JBQW9CLE1BQU0sVUFBVSx5QkFBeUIsTUFBTSxzQkFBc0IsTUFBTSw2QkFBNkIsTUFBTSx3QkFBd0IsTUFBTSx1Q0FBdUMsTUFBTSw2QkFBNkIsTUFBTSwyREFBMkQsTUFBTSw2REFBNkQsTUFBTSxhQUFhLFNBQVMsNkJBQTZCLFFBQVEsVUFBVSxrQkFBa0IsTUFBTSxrQkFBa0IsTUFBTSx5QkFBeUIsTUFBTSxXQUFXLE1BQU0sWUFBWSxTQUFTLCtCQUErQixRQUFRLFVBQVUsb0JBQW9CLE1BQU0sc0JBQXNCLE1BQU0sMkJBQTJCLE1BQU0seUJBQXlCLE1BQU0sWUFBWSxTQUFTLCtCQUErQixRQUFRLFVBQVUsc0JBQXNCLE1BQU0sdUJBQXVCLE1BQU0sMEJBQTBCLE1BQU0sMkJBQTJCLE1BQU0sMEJBQTBCLE1BQU0sMkJBQTJCLE1BQU0sNEJBQTRCLE1BQU0sNEJBQTRCLE1BQU0saUVBQWlFLFNBQVMsd0NBQXdDLHdCQUF3QixpQ0FBaUMsSUFBSSxnQkFBZ0IsSUFBSSxxQkFBcUIsYUFBYSxJQUFJLGdCQUFnQixJQUFJLHFCQUFxQixVQUFVLG1CQUFtQixvQ0FBb0MsRUFBRSxxQkFBcUIsY0FBYyx1QkFBdUIsa0NBQWtDLHVCQUF1QixxRUFBcUUsOENBQThDLDBHQUEwRyx1QkFBdUIsb0RBQW9ELDBFQUEwRSxzQ0FBc0MsMEVBQTBFLHVFQUF1RSxLQUFLLDhDQUE4Qyx5Q0FBeUMsNERBQTRELG9CQUFvQix5RUFBeUUsOENBQThDLDBCQUEwQixvT0FBb08sT0FBTywySkFBMkosNENBQTRDLCtCQUErQiw0REFBNEQsMEJBQTBCLFFBQVEsSUFBSSw2QkFBNkIsZ0JBQWdCLDRFQUE0RSwwQkFBMEIsbUJBQW1CLGlCQUFpQixrQkFBa0IsNERBQTRELFVBQVUsbUZBQW1GLHFCQUFxQixtREFBbUQsa0JBQWtCLDhFQUE4RSxvQ0FBb0MsS0FBSywrRUFBK0UsUUFBUSxrREFBa0QseUVBQXlFLEtBQUssSUFBSSxFQUFFLGtCQUFrQiwwTkFBME4sRUFBRSwwU0FBMFMsc0ZBQXNGLEVBQUUsYUFBYSx5RUFBeUUsV0FBVyxtQkFBbUIsSUFBSSxtQkFBbUIsYUFBYSxXQUFXLG9DQUFvQyxHQUFHLCtCQUErQixLQUFLLDRDQUE0Qyw4Q0FBOEMsZUFBZSxhQUFhLFVBQVUsYUFBYSw4QkFBOEIseUVBQXlFLGdDQUFnQyx1QkFBdUIscUJBQXFCLHFDQUFxQyw4RkFBOEYsRUFBRSxnQ0FBZ0MseURBQXlELEVBQUUsaUNBQWlDLCtEQUErRCx3RUFBd0UsMENBQTBDLG1FQUFtRSxtRkFBbUYsZ0RBQWdELEtBQUssK2tzQ0FBK2tzQyxpb0VBQWlvRSxPQUFPLHFFQUFxRSxrSkFBa0osUUFBUSxnTkFBZ04sT0FBTyxxRUFBcUUsNEJBQTRCLGkrQ0FBaStDLE9BQU8scUVBQXFFLGVBQWUsaUJBQWlCLDhEQUE4RCxtQ0FBbUMsdUNBQXVDLElBQUksZ0ZBQWdGLE9BQU8sU0FBUyxVQUFVLEdBQUcsa0JBQWtCLGFBQWEsTUFBTSwwQkFBMEIsbUNBQW1DLCtCQUErQixrQkFBa0IsNkJBQTZCLE9BQU8sWUFBWSxjQUFjLE1BQU0sc05BQXNOLGFBQWEsc0NBQXNDLDRCQUE0QixjQUFjLHVDQUF1QyxNQUFNLDhDQUE4QyxNQUFNLHFIQUFxSCxvQkFBb0Isd0RBQXdELG9CQUFvQixLQUFLLHFCQUFxQixrQ0FBa0MsRUFBRSxlQUFlLGlCQUFpQiw4REFBOEQsbUNBQW1DLHVDQUF1QyxJQUFJLGdGQUFnRixPQUFPLFNBQVMsVUFBVSxHQUFHLGtCQUFrQixhQUFhLE1BQU0sMEJBQTBCLG1DQUFtQywrQkFBK0Isa0JBQWtCLG1CQUFtQixPQUFPLGNBQWMsYUFBYSxNQUFNLHdKQUF3SixrTEFBa0wsU0FBUyxhQUFhLGtEQUFrRCxZQUFZLDJCQUEyQixNQUFNLHVCQUF1Qiw0REFBNEQsdVJBQXVSLG9DQUFvQyxLQUFLLGtCQUFrQiwrQkFBK0IsRUFBRSxLQUFLLHFCQUFxQiwwQkFBMEIsRUFBRTtBQUN6L2lILHFCQUFxQixrREFBTTtBQUMzQiwyQ0FBMkM7QUFDM0Msc0RBQXNELCtCQUErQjtBQUNyRjtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3dvcmtlci9kZWNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICAgICBpbXBvcnQgV29ya2VyIGZyb20gJ3dlYi13b3JrZXInO1xuICAgICAgICBleHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IFwiZnVuY3Rpb24gQShBLGUsdCxpLHIsSSxnKXt0cnl7dmFyIG49QVtJXShnKSxhPW4udmFsdWV9Y2F0Y2goQSl7cmV0dXJuIHZvaWQgdChBKX1uLmRvbmU/ZShhKTpQcm9taXNlLnJlc29sdmUoYSkudGhlbihpLHIpfWZ1bmN0aW9uIGUoZSl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxpPWFyZ3VtZW50cztyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHIsSSl7dmFyIGc9ZS5hcHBseSh0LGkpO2Z1bmN0aW9uIG4oZSl7QShnLHIsSSxuLGEsXFxcIm5leHRcXFwiLGUpfWZ1bmN0aW9uIGEoZSl7QShnLHIsSSxuLGEsXFxcInRocm93XFxcIixlKX1uKHZvaWQgMCl9KSl9fWZ1bmN0aW9uIHQoQSl7cmV0dXJuIHQ9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIFN5bWJvbCYmXFxcInN5bWJvbFxcXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oQSl7cmV0dXJuIHR5cGVvZiBBfTpmdW5jdGlvbihBKXtyZXR1cm4gQSYmXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIFN5bWJvbCYmQS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmQSE9PVN5bWJvbC5wcm90b3R5cGU/XFxcInN5bWJvbFxcXCI6dHlwZW9mIEF9LHQoQSl9dmFyIGk9e2V4cG9ydHM6e319OyFmdW5jdGlvbihBKXt2YXIgZT1mdW5jdGlvbihBKXt2YXIgZSxpPU9iamVjdC5wcm90b3R5cGUscj1pLmhhc093blByb3BlcnR5LEk9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIFN5bWJvbD9TeW1ib2w6e30sZz1JLml0ZXJhdG9yfHxcXFwiQEBpdGVyYXRvclxcXCIsbj1JLmFzeW5jSXRlcmF0b3J8fFxcXCJAQGFzeW5jSXRlcmF0b3JcXFwiLGE9SS50b1N0cmluZ1RhZ3x8XFxcIkBAdG9TdHJpbmdUYWdcXFwiO2Z1bmN0aW9uIG8oQSxlLHQpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxlLHt2YWx1ZTp0LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSksQVtlXX10cnl7byh7fSxcXFwiXFxcIil9Y2F0Y2goQSl7bz1mdW5jdGlvbihBLGUsdCl7cmV0dXJuIEFbZV09dH19ZnVuY3Rpb24gQihBLGUsdCxpKXt2YXIgcj1lJiZlLnByb3RvdHlwZSBpbnN0YW5jZW9mIGg/ZTpoLEk9T2JqZWN0LmNyZWF0ZShyLnByb3RvdHlwZSksZz1uZXcgUyhpfHxbXSk7cmV0dXJuIEkuX2ludm9rZT1mdW5jdGlvbihBLGUsdCl7dmFyIGk9UTtyZXR1cm4gZnVuY3Rpb24ocixJKXtpZihpPT09cyl0aHJvdyBuZXcgRXJyb3IoXFxcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcXFwiKTtpZihpPT09Zil7aWYoXFxcInRocm93XFxcIj09PXIpdGhyb3cgSTtyZXR1cm4gUigpfWZvcih0Lm1ldGhvZD1yLHQuYXJnPUk7Oyl7dmFyIGc9dC5kZWxlZ2F0ZTtpZihnKXt2YXIgbj1tKGcsdCk7aWYobil7aWYobj09PWMpY29udGludWU7cmV0dXJuIG59fWlmKFxcXCJuZXh0XFxcIj09PXQubWV0aG9kKXQuc2VudD10Ll9zZW50PXQuYXJnO2Vsc2UgaWYoXFxcInRocm93XFxcIj09PXQubWV0aG9kKXtpZihpPT09USl0aHJvdyBpPWYsdC5hcmc7dC5kaXNwYXRjaEV4Y2VwdGlvbih0LmFyZyl9ZWxzZVxcXCJyZXR1cm5cXFwiPT09dC5tZXRob2QmJnQuYWJydXB0KFxcXCJyZXR1cm5cXFwiLHQuYXJnKTtpPXM7dmFyIGE9QyhBLGUsdCk7aWYoXFxcIm5vcm1hbFxcXCI9PT1hLnR5cGUpe2lmKGk9dC5kb25lP2Y6RSxhLmFyZz09PWMpY29udGludWU7cmV0dXJue3ZhbHVlOmEuYXJnLGRvbmU6dC5kb25lfX1cXFwidGhyb3dcXFwiPT09YS50eXBlJiYoaT1mLHQubWV0aG9kPVxcXCJ0aHJvd1xcXCIsdC5hcmc9YS5hcmcpfX19KEEsdCxnKSxJfWZ1bmN0aW9uIEMoQSxlLHQpe3RyeXtyZXR1cm57dHlwZTpcXFwibm9ybWFsXFxcIixhcmc6QS5jYWxsKGUsdCl9fWNhdGNoKEEpe3JldHVybnt0eXBlOlxcXCJ0aHJvd1xcXCIsYXJnOkF9fX1BLndyYXA9Qjt2YXIgUT1cXFwic3VzcGVuZGVkU3RhcnRcXFwiLEU9XFxcInN1c3BlbmRlZFlpZWxkXFxcIixzPVxcXCJleGVjdXRpbmdcXFwiLGY9XFxcImNvbXBsZXRlZFxcXCIsYz17fTtmdW5jdGlvbiBoKCl7fWZ1bmN0aW9uIGwoKXt9ZnVuY3Rpb24gdSgpe312YXIgdz17fTtvKHcsZywoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pKTt2YXIgZD1PYmplY3QuZ2V0UHJvdG90eXBlT2YsRD1kJiZkKGQodihbXSkpKTtEJiZEIT09aSYmci5jYWxsKEQsZykmJih3PUQpO3ZhciB5PXUucHJvdG90eXBlPWgucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodyk7ZnVuY3Rpb24gayhBKXtbXFxcIm5leHRcXFwiLFxcXCJ0aHJvd1xcXCIsXFxcInJldHVyblxcXCJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe28oQSxlLChmdW5jdGlvbihBKXtyZXR1cm4gdGhpcy5faW52b2tlKGUsQSl9KSl9KSl9ZnVuY3Rpb24gcChBLGUpe2Z1bmN0aW9uIGkoSSxnLG4sYSl7dmFyIG89QyhBW0ldLEEsZyk7aWYoXFxcInRocm93XFxcIiE9PW8udHlwZSl7dmFyIEI9by5hcmcsUT1CLnZhbHVlO3JldHVybiBRJiZcXFwib2JqZWN0XFxcIj09PXQoUSkmJnIuY2FsbChRLFxcXCJfX2F3YWl0XFxcIik/ZS5yZXNvbHZlKFEuX19hd2FpdCkudGhlbigoZnVuY3Rpb24oQSl7aShcXFwibmV4dFxcXCIsQSxuLGEpfSksKGZ1bmN0aW9uKEEpe2koXFxcInRocm93XFxcIixBLG4sYSl9KSk6ZS5yZXNvbHZlKFEpLnRoZW4oKGZ1bmN0aW9uKEEpe0IudmFsdWU9QSxuKEIpfSksKGZ1bmN0aW9uKEEpe3JldHVybiBpKFxcXCJ0aHJvd1xcXCIsQSxuLGEpfSkpfWEoby5hcmcpfXZhciBJO3RoaXMuX2ludm9rZT1mdW5jdGlvbihBLHQpe2Z1bmN0aW9uIHIoKXtyZXR1cm4gbmV3IGUoKGZ1bmN0aW9uKGUscil7aShBLHQsZSxyKX0pKX1yZXR1cm4gST1JP0kudGhlbihyLHIpOnIoKX19ZnVuY3Rpb24gbShBLHQpe3ZhciBpPUEuaXRlcmF0b3JbdC5tZXRob2RdO2lmKGk9PT1lKXtpZih0LmRlbGVnYXRlPW51bGwsXFxcInRocm93XFxcIj09PXQubWV0aG9kKXtpZihBLml0ZXJhdG9yLnJldHVybiYmKHQubWV0aG9kPVxcXCJyZXR1cm5cXFwiLHQuYXJnPWUsbShBLHQpLFxcXCJ0aHJvd1xcXCI9PT10Lm1ldGhvZCkpcmV0dXJuIGM7dC5tZXRob2Q9XFxcInRocm93XFxcIix0LmFyZz1uZXcgVHlwZUVycm9yKFxcXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXFxcIil9cmV0dXJuIGN9dmFyIHI9QyhpLEEuaXRlcmF0b3IsdC5hcmcpO2lmKFxcXCJ0aHJvd1xcXCI9PT1yLnR5cGUpcmV0dXJuIHQubWV0aG9kPVxcXCJ0aHJvd1xcXCIsdC5hcmc9ci5hcmcsdC5kZWxlZ2F0ZT1udWxsLGM7dmFyIEk9ci5hcmc7cmV0dXJuIEk/SS5kb25lPyh0W0EucmVzdWx0TmFtZV09SS52YWx1ZSx0Lm5leHQ9QS5uZXh0TG9jLFxcXCJyZXR1cm5cXFwiIT09dC5tZXRob2QmJih0Lm1ldGhvZD1cXFwibmV4dFxcXCIsdC5hcmc9ZSksdC5kZWxlZ2F0ZT1udWxsLGMpOkk6KHQubWV0aG9kPVxcXCJ0aHJvd1xcXCIsdC5hcmc9bmV3IFR5cGVFcnJvcihcXFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcXFwiKSx0LmRlbGVnYXRlPW51bGwsYyl9ZnVuY3Rpb24gRyhBKXt2YXIgZT17dHJ5TG9jOkFbMF19OzEgaW4gQSYmKGUuY2F0Y2hMb2M9QVsxXSksMiBpbiBBJiYoZS5maW5hbGx5TG9jPUFbMl0sZS5hZnRlckxvYz1BWzNdKSx0aGlzLnRyeUVudHJpZXMucHVzaChlKX1mdW5jdGlvbiBGKEEpe3ZhciBlPUEuY29tcGxldGlvbnx8e307ZS50eXBlPVxcXCJub3JtYWxcXFwiLGRlbGV0ZSBlLmFyZyxBLmNvbXBsZXRpb249ZX1mdW5jdGlvbiBTKEEpe3RoaXMudHJ5RW50cmllcz1be3RyeUxvYzpcXFwicm9vdFxcXCJ9XSxBLmZvckVhY2goRyx0aGlzKSx0aGlzLnJlc2V0KCEwKX1mdW5jdGlvbiB2KEEpe2lmKEEpe3ZhciB0PUFbZ107aWYodClyZXR1cm4gdC5jYWxsKEEpO2lmKFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBBLm5leHQpcmV0dXJuIEE7aWYoIWlzTmFOKEEubGVuZ3RoKSl7dmFyIGk9LTEsST1mdW5jdGlvbiB0KCl7Zm9yKDsrK2k8QS5sZW5ndGg7KWlmKHIuY2FsbChBLGkpKXJldHVybiB0LnZhbHVlPUFbaV0sdC5kb25lPSExLHQ7cmV0dXJuIHQudmFsdWU9ZSx0LmRvbmU9ITAsdH07cmV0dXJuIEkubmV4dD1JfX1yZXR1cm57bmV4dDpSfX1mdW5jdGlvbiBSKCl7cmV0dXJue3ZhbHVlOmUsZG9uZTohMH19cmV0dXJuIGwucHJvdG90eXBlPXUsbyh5LFxcXCJjb25zdHJ1Y3RvclxcXCIsdSksbyh1LFxcXCJjb25zdHJ1Y3RvclxcXCIsbCksbC5kaXNwbGF5TmFtZT1vKHUsYSxcXFwiR2VuZXJhdG9yRnVuY3Rpb25cXFwiKSxBLmlzR2VuZXJhdG9yRnVuY3Rpb249ZnVuY3Rpb24oQSl7dmFyIGU9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIEEmJkEuY29uc3RydWN0b3I7cmV0dXJuISFlJiYoZT09PWx8fFxcXCJHZW5lcmF0b3JGdW5jdGlvblxcXCI9PT0oZS5kaXNwbGF5TmFtZXx8ZS5uYW1lKSl9LEEubWFyaz1mdW5jdGlvbihBKXtyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihBLHUpOihBLl9fcHJvdG9fXz11LG8oQSxhLFxcXCJHZW5lcmF0b3JGdW5jdGlvblxcXCIpKSxBLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHkpLEF9LEEuYXdyYXA9ZnVuY3Rpb24oQSl7cmV0dXJue19fYXdhaXQ6QX19LGsocC5wcm90b3R5cGUpLG8ocC5wcm90b3R5cGUsbiwoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pKSxBLkFzeW5jSXRlcmF0b3I9cCxBLmFzeW5jPWZ1bmN0aW9uKGUsdCxpLHIsSSl7dm9pZCAwPT09SSYmKEk9UHJvbWlzZSk7dmFyIGc9bmV3IHAoQihlLHQsaSxyKSxJKTtyZXR1cm4gQS5pc0dlbmVyYXRvckZ1bmN0aW9uKHQpP2c6Zy5uZXh0KCkudGhlbigoZnVuY3Rpb24oQSl7cmV0dXJuIEEuZG9uZT9BLnZhbHVlOmcubmV4dCgpfSkpfSxrKHkpLG8oeSxhLFxcXCJHZW5lcmF0b3JcXFwiKSxvKHksZywoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pKSxvKHksXFxcInRvU3RyaW5nXFxcIiwoZnVuY3Rpb24oKXtyZXR1cm5cXFwiW29iamVjdCBHZW5lcmF0b3JdXFxcIn0pKSxBLmtleXM9ZnVuY3Rpb24oQSl7dmFyIGU9W107Zm9yKHZhciB0IGluIEEpZS5wdXNoKHQpO3JldHVybiBlLnJldmVyc2UoKSxmdW5jdGlvbiB0KCl7Zm9yKDtlLmxlbmd0aDspe3ZhciBpPWUucG9wKCk7aWYoaSBpbiBBKXJldHVybiB0LnZhbHVlPWksdC5kb25lPSExLHR9cmV0dXJuIHQuZG9uZT0hMCx0fX0sQS52YWx1ZXM9dixTLnByb3RvdHlwZT17Y29uc3RydWN0b3I6UyxyZXNldDpmdW5jdGlvbihBKXtpZih0aGlzLnByZXY9MCx0aGlzLm5leHQ9MCx0aGlzLnNlbnQ9dGhpcy5fc2VudD1lLHRoaXMuZG9uZT0hMSx0aGlzLmRlbGVnYXRlPW51bGwsdGhpcy5tZXRob2Q9XFxcIm5leHRcXFwiLHRoaXMuYXJnPWUsdGhpcy50cnlFbnRyaWVzLmZvckVhY2goRiksIUEpZm9yKHZhciB0IGluIHRoaXMpXFxcInRcXFwiPT09dC5jaGFyQXQoMCkmJnIuY2FsbCh0aGlzLHQpJiYhaXNOYU4oK3Quc2xpY2UoMSkpJiYodGhpc1t0XT1lKX0sc3RvcDpmdW5jdGlvbigpe3RoaXMuZG9uZT0hMDt2YXIgQT10aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjtpZihcXFwidGhyb3dcXFwiPT09QS50eXBlKXRocm93IEEuYXJnO3JldHVybiB0aGlzLnJ2YWx9LGRpc3BhdGNoRXhjZXB0aW9uOmZ1bmN0aW9uKEEpe2lmKHRoaXMuZG9uZSl0aHJvdyBBO3ZhciB0PXRoaXM7ZnVuY3Rpb24gaShpLHIpe3JldHVybiBuLnR5cGU9XFxcInRocm93XFxcIixuLmFyZz1BLHQubmV4dD1pLHImJih0Lm1ldGhvZD1cXFwibmV4dFxcXCIsdC5hcmc9ZSksISFyfWZvcih2YXIgST10aGlzLnRyeUVudHJpZXMubGVuZ3RoLTE7ST49MDstLUkpe3ZhciBnPXRoaXMudHJ5RW50cmllc1tJXSxuPWcuY29tcGxldGlvbjtpZihcXFwicm9vdFxcXCI9PT1nLnRyeUxvYylyZXR1cm4gaShcXFwiZW5kXFxcIik7aWYoZy50cnlMb2M8PXRoaXMucHJldil7dmFyIGE9ci5jYWxsKGcsXFxcImNhdGNoTG9jXFxcIiksbz1yLmNhbGwoZyxcXFwiZmluYWxseUxvY1xcXCIpO2lmKGEmJm8pe2lmKHRoaXMucHJldjxnLmNhdGNoTG9jKXJldHVybiBpKGcuY2F0Y2hMb2MsITApO2lmKHRoaXMucHJldjxnLmZpbmFsbHlMb2MpcmV0dXJuIGkoZy5maW5hbGx5TG9jKX1lbHNlIGlmKGEpe2lmKHRoaXMucHJldjxnLmNhdGNoTG9jKXJldHVybiBpKGcuY2F0Y2hMb2MsITApfWVsc2V7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFxcXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVxcXCIpO2lmKHRoaXMucHJldjxnLmZpbmFsbHlMb2MpcmV0dXJuIGkoZy5maW5hbGx5TG9jKX19fX0sYWJydXB0OmZ1bmN0aW9uKEEsZSl7Zm9yKHZhciB0PXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTt0Pj0wOy0tdCl7dmFyIGk9dGhpcy50cnlFbnRyaWVzW3RdO2lmKGkudHJ5TG9jPD10aGlzLnByZXYmJnIuY2FsbChpLFxcXCJmaW5hbGx5TG9jXFxcIikmJnRoaXMucHJldjxpLmZpbmFsbHlMb2Mpe3ZhciBJPWk7YnJlYWt9fUkmJihcXFwiYnJlYWtcXFwiPT09QXx8XFxcImNvbnRpbnVlXFxcIj09PUEpJiZJLnRyeUxvYzw9ZSYmZTw9SS5maW5hbGx5TG9jJiYoST1udWxsKTt2YXIgZz1JP0kuY29tcGxldGlvbjp7fTtyZXR1cm4gZy50eXBlPUEsZy5hcmc9ZSxJPyh0aGlzLm1ldGhvZD1cXFwibmV4dFxcXCIsdGhpcy5uZXh0PUkuZmluYWxseUxvYyxjKTp0aGlzLmNvbXBsZXRlKGcpfSxjb21wbGV0ZTpmdW5jdGlvbihBLGUpe2lmKFxcXCJ0aHJvd1xcXCI9PT1BLnR5cGUpdGhyb3cgQS5hcmc7cmV0dXJuXFxcImJyZWFrXFxcIj09PUEudHlwZXx8XFxcImNvbnRpbnVlXFxcIj09PUEudHlwZT90aGlzLm5leHQ9QS5hcmc6XFxcInJldHVyblxcXCI9PT1BLnR5cGU/KHRoaXMucnZhbD10aGlzLmFyZz1BLmFyZyx0aGlzLm1ldGhvZD1cXFwicmV0dXJuXFxcIix0aGlzLm5leHQ9XFxcImVuZFxcXCIpOlxcXCJub3JtYWxcXFwiPT09QS50eXBlJiZlJiYodGhpcy5uZXh0PWUpLGN9LGZpbmlzaDpmdW5jdGlvbihBKXtmb3IodmFyIGU9dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xO2U+PTA7LS1lKXt2YXIgdD10aGlzLnRyeUVudHJpZXNbZV07aWYodC5maW5hbGx5TG9jPT09QSlyZXR1cm4gdGhpcy5jb21wbGV0ZSh0LmNvbXBsZXRpb24sdC5hZnRlckxvYyksRih0KSxjfX0sY2F0Y2g6ZnVuY3Rpb24oQSl7Zm9yKHZhciBlPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtlPj0wOy0tZSl7dmFyIHQ9dGhpcy50cnlFbnRyaWVzW2VdO2lmKHQudHJ5TG9jPT09QSl7dmFyIGk9dC5jb21wbGV0aW9uO2lmKFxcXCJ0aHJvd1xcXCI9PT1pLnR5cGUpe3ZhciByPWkuYXJnO0YodCl9cmV0dXJuIHJ9fXRocm93IG5ldyBFcnJvcihcXFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XFxcIil9LGRlbGVnYXRlWWllbGQ6ZnVuY3Rpb24oQSx0LGkpe3JldHVybiB0aGlzLmRlbGVnYXRlPXtpdGVyYXRvcjp2KEEpLHJlc3VsdE5hbWU6dCxuZXh0TG9jOml9LFxcXCJuZXh0XFxcIj09PXRoaXMubWV0aG9kJiYodGhpcy5hcmc9ZSksY319LEF9KEEuZXhwb3J0cyk7dHJ5e3JlZ2VuZXJhdG9yUnVudGltZT1lfWNhdGNoKEEpe1xcXCJvYmplY3RcXFwiPT09KFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZ2xvYmFsVGhpcz9cXFwidW5kZWZpbmVkXFxcIjp0KGdsb2JhbFRoaXMpKT9nbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZT1lOkZ1bmN0aW9uKFxcXCJyXFxcIixcXFwicmVnZW5lcmF0b3JSdW50aW1lID0gclxcXCIpKGUpfX0oaSk7dmFyIHI9aS5leHBvcnRzLEk9bmV3IE1hcDtmdW5jdGlvbiBnKEEsZSl7QXJyYXkuaXNBcnJheShBKXx8KEE9W0FdKSxBLmZvckVhY2goKGZ1bmN0aW9uKEEpe3JldHVybiBJLnNldChBLGUpfSkpfWZ1bmN0aW9uIG4oQSl7cmV0dXJuIGEuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIGEoKXtyZXR1cm4oYT1lKHIubWFyaygoZnVuY3Rpb24gQShlKXt2YXIgdCxpO3JldHVybiByLndyYXAoKGZ1bmN0aW9uKEEpe2Zvcig7Oylzd2l0Y2goQS5wcmV2PUEubmV4dCl7Y2FzZSAwOmlmKHQ9SS5nZXQoZS5Db21wcmVzc2lvbikpe0EubmV4dD0zO2JyZWFrfXRocm93IG5ldyBFcnJvcihcXFwiVW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QgaWRlbnRpZmllcjogXFxcIi5jb25jYXQoZS5Db21wcmVzc2lvbikpO2Nhc2UgMzpyZXR1cm4gQS5uZXh0PTUsdCgpO2Nhc2UgNTpyZXR1cm4gaT1BLnNlbnQsQS5hYnJ1cHQoXFxcInJldHVyblxcXCIsbmV3IGkoZSkpO2Nhc2UgNzpjYXNlXFxcImVuZFxcXCI6cmV0dXJuIEEuc3RvcCgpfX0pLEEpfSkpKSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfWcoW3ZvaWQgMCwxXSwoZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4geX0pKS50aGVuKChmdW5jdGlvbihBKXtyZXR1cm4gQS5kZWZhdWx0fSkpfSkpLGcoNSwoZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gRn0pKS50aGVuKChmdW5jdGlvbihBKXtyZXR1cm4gQS5kZWZhdWx0fSkpfSkpLGcoNiwoZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXFxcIm9sZCBzdHlsZSBKUEVHIGNvbXByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQuXFxcIil9KSksZyg3LChmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKChmdW5jdGlvbigpe3JldHVybiBOfSkpLnRoZW4oKGZ1bmN0aW9uKEEpe3JldHVybiBBLmRlZmF1bHR9KSl9KSksZyhbOCwzMjk0Nl0sKGZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIE9BfSkpLnRoZW4oKGZ1bmN0aW9uKEEpe3JldHVybiBBLmRlZmF1bHR9KSl9KSksZygzMjc3MywoZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gX0F9KSkudGhlbigoZnVuY3Rpb24oQSl7cmV0dXJuIEEuZGVmYXVsdH0pKX0pKSxnKDM0ODg3LChmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKChmdW5jdGlvbigpe3JldHVybiBsZX0pKS50aGVuKGZ1bmN0aW9uKCl7dmFyIEE9ZShyLm1hcmsoKGZ1bmN0aW9uIEEoZSl7cmV0dXJuIHIud3JhcCgoZnVuY3Rpb24oQSl7Zm9yKDs7KXN3aXRjaChBLnByZXY9QS5uZXh0KXtjYXNlIDA6cmV0dXJuIEEubmV4dD0yLGUuenN0ZC5pbml0KCk7Y2FzZSAyOnJldHVybiBBLmFicnVwdChcXFwicmV0dXJuXFxcIixlKTtjYXNlIDM6Y2FzZVxcXCJlbmRcXFwiOnJldHVybiBBLnN0b3AoKX19KSxBKX0pKSk7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBBLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19KCkpLnRoZW4oKGZ1bmN0aW9uKEEpe3JldHVybiBBLmRlZmF1bHR9KSl9KSksZyg1MDAwMSwoZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gZGV9KSkudGhlbigoZnVuY3Rpb24oQSl7cmV0dXJuIEEuZGVmYXVsdH0pKX0pKTt2YXIgbz1nbG9iYWxUaGlzO2Z1bmN0aW9uIEIoQSxlKXtpZighKEEgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKX1mdW5jdGlvbiBDKEEsZSl7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kyspe3ZhciBpPWVbdF07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIGkmJihpLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxpLmtleSxpKX19ZnVuY3Rpb24gUShBLGUsdCl7cmV0dXJuIGUmJkMoQS5wcm90b3R5cGUsZSksdCYmQyhBLHQpLEF9ZnVuY3Rpb24gRShBLGUpe3JldHVybiBFPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24oQSxlKXtyZXR1cm4gQS5fX3Byb3RvX189ZSxBfSxFKEEsZSl9ZnVuY3Rpb24gcyhBLGUpe2lmKFxcXCJmdW5jdGlvblxcXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpO0EucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpBLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiZFKEEsZSl9ZnVuY3Rpb24gZihBLGUpe2lmKGUmJihcXFwib2JqZWN0XFxcIj09PXQoZSl8fFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBlKSlyZXR1cm4gZTtpZih2b2lkIDAhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXFxcIik7cmV0dXJuIGZ1bmN0aW9uKEEpe2lmKHZvaWQgMD09PUEpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTtyZXR1cm4gQX0oQSl9ZnVuY3Rpb24gYyhBKXtyZXR1cm4gYz1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKEEpe3JldHVybiBBLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKEEpfSxjKEEpfWZ1bmN0aW9uIGgoQSxlKXt2YXIgdD1BLmxlbmd0aC1lLGk9MDtkb3tmb3IodmFyIHI9ZTtyPjA7ci0tKUFbaStlXSs9QVtpXSxpKys7dC09ZX13aGlsZSh0PjApfWZ1bmN0aW9uIGwoQSxlLHQpe2Zvcih2YXIgaT0wLHI9QS5sZW5ndGgsST1yL3Q7cj5lOyl7Zm9yKHZhciBnPWU7Zz4wOy0tZylBW2krZV0rPUFbaV0sKytpO3ItPWV9Zm9yKHZhciBuPUEuc2xpY2UoKSxhPTA7YTxJOysrYSlmb3IodmFyIG89MDtvPHQ7KytvKUFbdCphK29dPW5bKHQtby0xKSpJK2FdfWZ1bmN0aW9uIHUoQSxlLHQsaSxyLEkpe2lmKCFlfHwxPT09ZSlyZXR1cm4gQTtmb3IodmFyIGc9MDtnPHIubGVuZ3RoOysrZyl7aWYocltnXSU4IT0wKXRocm93IG5ldyBFcnJvcihcXFwiV2hlbiBkZWNvZGluZyB3aXRoIHByZWRpY3Rvciwgb25seSBtdWx0aXBsZSBvZiA4IGJpdHMgYXJlIHN1cHBvcnRlZC5cXFwiKTtpZihyW2ddIT09clswXSl0aHJvdyBuZXcgRXJyb3IoXFxcIldoZW4gZGVjb2Rpbmcgd2l0aCBwcmVkaWN0b3IsIGFsbCBzYW1wbGVzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaXplLlxcXCIpfWZvcih2YXIgbj1yWzBdLzgsYT0yPT09ST8xOnIubGVuZ3RoLG89MDtvPGkmJiEobyphKnQqbj49QS5ieXRlTGVuZ3RoKTsrK28pe3ZhciBCPXZvaWQgMDtpZigyPT09ZSl7c3dpdGNoKHJbMF0pe2Nhc2UgODpCPW5ldyBVaW50OEFycmF5KEEsbyphKnQqbixhKnQqbik7YnJlYWs7Y2FzZSAxNjpCPW5ldyBVaW50MTZBcnJheShBLG8qYSp0Km4sYSp0Km4vMik7YnJlYWs7Y2FzZSAzMjpCPW5ldyBVaW50MzJBcnJheShBLG8qYSp0Km4sYSp0Km4vNCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXFxcIlByZWRpY3RvciAyIG5vdCBhbGxvd2VkIHdpdGggXFxcIi5jb25jYXQoclswXSxcXFwiIGJpdHMgcGVyIHNhbXBsZS5cXFwiKSl9aChCLGEpfWVsc2UgMz09PWUmJmwoQj1uZXcgVWludDhBcnJheShBLG8qYSp0Km4sYSp0Km4pLGEsbil9cmV0dXJuIEF9by5hZGRFdmVudExpc3RlbmVyKFxcXCJtZXNzYWdlXFxcIixmdW5jdGlvbigpe3ZhciBBPWUoci5tYXJrKChmdW5jdGlvbiBBKGUpe3ZhciB0LGksSSxnLGEsQjtyZXR1cm4gci53cmFwKChmdW5jdGlvbihBKXtmb3IoOzspc3dpdGNoKEEucHJldj1BLm5leHQpe2Nhc2UgMDpyZXR1cm4gdD1lLmRhdGEsaT10LmlkLEk9dC5maWxlRGlyZWN0b3J5LGc9dC5idWZmZXIsQS5uZXh0PTMsbihJKTtjYXNlIDM6cmV0dXJuIGE9QS5zZW50LEEubmV4dD02LGEuZGVjb2RlKEksZyk7Y2FzZSA2OkI9QS5zZW50LG8ucG9zdE1lc3NhZ2Uoe2RlY29kZWQ6QixpZDppfSxbQl0pO2Nhc2UgODpjYXNlXFxcImVuZFxcXCI6cmV0dXJuIEEuc3RvcCgpfX0pLEEpfSkpKTtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIEEuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0oKSk7dmFyIHc9ZnVuY3Rpb24oKXtmdW5jdGlvbiBBKCl7Qih0aGlzLEEpfXZhciB0O3JldHVybiBRKEEsW3trZXk6XFxcImRlY29kZVxcXCIsdmFsdWU6KHQ9ZShyLm1hcmsoKGZ1bmN0aW9uIEEoZSx0KXt2YXIgaSxJLGcsbixhO3JldHVybiByLndyYXAoKGZ1bmN0aW9uKEEpe2Zvcig7Oylzd2l0Y2goQS5wcmV2PUEubmV4dCl7Y2FzZSAwOnJldHVybiBBLm5leHQ9Mix0aGlzLmRlY29kZUJsb2NrKHQpO2Nhc2UgMjppZihpPUEuc2VudCwxPT09KEk9ZS5QcmVkaWN0b3J8fDEpKXtBLm5leHQ9OTticmVha31yZXR1cm4gZz0hZS5TdHJpcE9mZnNldHMsbj1nP2UuVGlsZVdpZHRoOmUuSW1hZ2VXaWR0aCxhPWc/ZS5UaWxlTGVuZ3RoOmUuUm93c1BlclN0cmlwfHxlLkltYWdlTGVuZ3RoLEEuYWJydXB0KFxcXCJyZXR1cm5cXFwiLHUoaSxJLG4sYSxlLkJpdHNQZXJTYW1wbGUsZS5QbGFuYXJDb25maWd1cmF0aW9uKSk7Y2FzZSA5OnJldHVybiBBLmFicnVwdChcXFwicmV0dXJuXFxcIixpKTtjYXNlIDEwOmNhc2VcXFwiZW5kXFxcIjpyZXR1cm4gQS5zdG9wKCl9fSksQSx0aGlzKX0pKSksZnVuY3Rpb24oQSxlKXtyZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX1dKSxBfSgpO2Z1bmN0aW9uIGQoQSl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goQSl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciB0LGk9YyhBKTtpZihlKXt2YXIgcj1jKHRoaXMpLmNvbnN0cnVjdG9yO3Q9UmVmbGVjdC5jb25zdHJ1Y3QoaSxhcmd1bWVudHMscil9ZWxzZSB0PWkuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBmKHRoaXMsdCl9fXZhciBEPWZ1bmN0aW9uKEEpe3ModCx3KTt2YXIgZT1kKHQpO2Z1bmN0aW9uIHQoKXtyZXR1cm4gQih0aGlzLHQpLGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBRKHQsW3trZXk6XFxcImRlY29kZUJsb2NrXFxcIix2YWx1ZTpmdW5jdGlvbihBKXtyZXR1cm4gQX19XSksdH0oKSx5PU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGRlZmF1bHQ6RH0pO2Z1bmN0aW9uIGsoQSl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goQSl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciB0LGk9YyhBKTtpZihlKXt2YXIgcj1jKHRoaXMpLmNvbnN0cnVjdG9yO3Q9UmVmbGVjdC5jb25zdHJ1Y3QoaSxhcmd1bWVudHMscil9ZWxzZSB0PWkuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBmKHRoaXMsdCl9fWZ1bmN0aW9uIHAoQSxlKXtmb3IodmFyIHQ9ZS5sZW5ndGgtMTt0Pj0wO3QtLSlBLnB1c2goZVt0XSk7cmV0dXJuIEF9ZnVuY3Rpb24gbShBKXtmb3IodmFyIGU9bmV3IFVpbnQxNkFycmF5KDQwOTMpLHQ9bmV3IFVpbnQ4QXJyYXkoNDA5MyksaT0wO2k8PTI1NztpKyspZVtpXT00MDk2LHRbaV09aTt2YXIgcj0yNTgsST05LGc9MDtmdW5jdGlvbiBuKCl7cj0yNTgsST05fWZ1bmN0aW9uIGEoQSl7dmFyIGU9ZnVuY3Rpb24oQSxlLHQpe3ZhciBpPWUlOCxyPU1hdGguZmxvb3IoZS84KSxJPTgtaSxnPWUrdC04KihyKzEpLG49OCoocisyKS0oZSt0KSxhPTgqKHIrMiktZTtpZihuPU1hdGgubWF4KDAsbikscj49QS5sZW5ndGgpcmV0dXJuIGNvbnNvbGUud2FybihcXFwicmFuIG9mZiB0aGUgZW5kIG9mIHRoZSBidWZmZXIgYmVmb3JlIGZpbmRpbmcgRU9JX0NPREUgKGVuZCBvbiBpbnB1dCBjb2RlKVxcXCIpLDI1Nzt2YXIgbz1BW3JdJk1hdGgucG93KDIsOC1pKS0xLEI9bzw8PXQtSTtpZihyKzE8QS5sZW5ndGgpe3ZhciBDPUFbcisxXT4+Pm47Qis9Qzw8PU1hdGgubWF4KDAsdC1hKX1pZihnPjgmJnIrMjxBLmxlbmd0aCl7dmFyIFE9OCoociszKS0oZSt0KTtCKz1BW3IrMl0+Pj5RfXJldHVybiBCfShBLGcsSSk7cmV0dXJuIGcrPUksZX1mdW5jdGlvbiBvKEEsaSl7cmV0dXJuIHRbcl09aSxlW3JdPUEsKytyLTF9ZnVuY3Rpb24gQihBKXtmb3IodmFyIGk9W10scj1BOzQwOTYhPT1yO3I9ZVtyXSlpLnB1c2godFtyXSk7cmV0dXJuIGl9dmFyIEM9W107bigpO2Zvcih2YXIgUSxFPW5ldyBVaW50OEFycmF5KEEpLHM9YShFKTsyNTchPT1zOyl7aWYoMjU2PT09cyl7Zm9yKG4oKSxzPWEoRSk7MjU2PT09czspcz1hKEUpO2lmKDI1Nz09PXMpYnJlYWs7aWYocz4yNTYpdGhyb3cgbmV3IEVycm9yKFxcXCJjb3JydXB0ZWQgY29kZSBhdCBzY2FubGluZSBcXFwiLmNvbmNhdChzKSk7cChDLEIocykpLFE9c31lbHNlIGlmKHM8cil7dmFyIGY9QihzKTtwKEMsZiksbyhRLGZbZi5sZW5ndGgtMV0pLFE9c31lbHNle3ZhciBjPUIoUSk7aWYoIWMpdGhyb3cgbmV3IEVycm9yKFxcXCJCb2d1cyBlbnRyeS4gTm90IGluIGRpY3Rpb25hcnksIFxcXCIuY29uY2F0KFEsXFxcIiAvIFxcXCIpLmNvbmNhdChyLFxcXCIsIHBvc2l0aW9uOiBcXFwiKS5jb25jYXQoZykpO3AoQyxjKSxDLnB1c2goY1tjLmxlbmd0aC0xXSksbyhRLGNbYy5sZW5ndGgtMV0pLFE9c31yKzE+PU1hdGgucG93KDIsSSkmJigxMj09PUk/UT12b2lkIDA6SSsrKSxzPWEoRSl9cmV0dXJuIG5ldyBVaW50OEFycmF5KEMpfXZhciBHPWZ1bmN0aW9uKEEpe3ModCx3KTt2YXIgZT1rKHQpO2Z1bmN0aW9uIHQoKXtyZXR1cm4gQih0aGlzLHQpLGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBRKHQsW3trZXk6XFxcImRlY29kZUJsb2NrXFxcIix2YWx1ZTpmdW5jdGlvbihBKXtyZXR1cm4gbShBKS5idWZmZXJ9fV0pLHR9KCksRj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxkZWZhdWx0Okd9KTtmdW5jdGlvbiBTKEEpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3QpcmV0dXJuITE7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZihcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKEEpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdCxpPWMoQSk7aWYoZSl7dmFyIHI9Yyh0aGlzKS5jb25zdHJ1Y3Rvcjt0PVJlZmxlY3QuY29uc3RydWN0KGksYXJndW1lbnRzLHIpfWVsc2UgdD1pLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gZih0aGlzLHQpfX12YXIgdj1uZXcgSW50MzJBcnJheShbMCwxLDgsMTYsOSwyLDMsMTAsMTcsMjQsMzIsMjUsMTgsMTEsNCw1LDEyLDE5LDI2LDMzLDQwLDQ4LDQxLDM0LDI3LDIwLDEzLDYsNywxNCwyMSwyOCwzNSw0Miw0OSw1Niw1Nyw1MCw0MywzNiwyOSwyMiwxNSwyMywzMCwzNyw0NCw1MSw1OCw1OSw1Miw0NSwzOCwzMSwzOSw0Niw1Myw2MCw2MSw1NCw0Nyw1NSw2Miw2M10pO2Z1bmN0aW9uIFIoQSxlKXtmb3IodmFyIHQ9MCxpPVtdLHI9MTY7cj4wJiYhQVtyLTFdOyktLXI7aS5wdXNoKHtjaGlsZHJlbjpbXSxpbmRleDowfSk7Zm9yKHZhciBJLGc9aVswXSxuPTA7bjxyO24rKyl7Zm9yKHZhciBhPTA7YTxBW25dO2ErKyl7Zm9yKChnPWkucG9wKCkpLmNoaWxkcmVuW2cuaW5kZXhdPWVbdF07Zy5pbmRleD4wOylnPWkucG9wKCk7Zm9yKGcuaW5kZXgrKyxpLnB1c2goZyk7aS5sZW5ndGg8PW47KWkucHVzaChJPXtjaGlsZHJlbjpbXSxpbmRleDowfSksZy5jaGlsZHJlbltnLmluZGV4XT1JLmNoaWxkcmVuLGc9STt0Kyt9bisxPHImJihpLnB1c2goST17Y2hpbGRyZW46W10saW5kZXg6MH0pLGcuY2hpbGRyZW5bZy5pbmRleF09SS5jaGlsZHJlbixnPUkpfXJldHVybiBpWzBdLmNoaWxkcmVufWZ1bmN0aW9uIFUoQSxlLGkscixJLGcsbixhLG8pe3ZhciBCPWkubWN1c1BlckxpbmUsQz1pLnByb2dyZXNzaXZlLFE9ZSxFPWUscz0wLGY9MDtmdW5jdGlvbiBjKCl7aWYoZj4wKXJldHVybiBmLS0scz4+ZiYxO2lmKDI1NT09PShzPUFbRSsrXSkpe3ZhciBlPUFbRSsrXTtpZihlKXRocm93IG5ldyBFcnJvcihcXFwidW5leHBlY3RlZCBtYXJrZXI6IFxcXCIuY29uY2F0KChzPDw4fGUpLnRvU3RyaW5nKDE2KSkpfXJldHVybiBmPTcscz4+Pjd9ZnVuY3Rpb24gaChBKXtmb3IodmFyIGUsaT1BO251bGwhPT0oZT1jKCkpOyl7aWYoXFxcIm51bWJlclxcXCI9PXR5cGVvZihpPWlbZV0pKXJldHVybiBpO2lmKFxcXCJvYmplY3RcXFwiIT09dChpKSl0aHJvdyBuZXcgRXJyb3IoXFxcImludmFsaWQgaHVmZm1hbiBzZXF1ZW5jZVxcXCIpfXJldHVybiBudWxsfWZ1bmN0aW9uIGwoQSl7Zm9yKHZhciBlPUEsdD0wO2U+MDspe3ZhciBpPWMoKTtpZihudWxsPT09aSlyZXR1cm47dD10PDwxfGksLS1lfXJldHVybiB0fWZ1bmN0aW9uIHUoQSl7dmFyIGU9bChBKTtyZXR1cm4gZT49MTw8QS0xP2U6ZSsoLTE8PEEpKzF9dmFyIHc9MDt2YXIgZCxEPTA7ZnVuY3Rpb24geShBLGUsdCxpLHIpe3ZhciBJPXQlQixnPSh0L0J8MCkqQS52K2ksbj1JKkEuaCtyO2UoQSxBLmJsb2Nrc1tnXVtuXSl9ZnVuY3Rpb24gayhBLGUsdCl7dmFyIGk9dC9BLmJsb2Nrc1BlckxpbmV8MCxyPXQlQS5ibG9ja3NQZXJMaW5lO2UoQSxBLmJsb2Nrc1tpXVtyXSl9dmFyIHAsbSxHLEYsUyxSLFU9ci5sZW5ndGg7Uj1DPzA9PT1nPzA9PT1hP2Z1bmN0aW9uKEEsZSl7dmFyIHQ9aChBLmh1ZmZtYW5UYWJsZURDKSxpPTA9PT10PzA6dSh0KTw8bztBLnByZWQrPWksZVswXT1BLnByZWR9OmZ1bmN0aW9uKEEsZSl7ZVswXXw9YygpPDxvfTowPT09YT9mdW5jdGlvbihBLGUpe2lmKHc+MCl3LS07ZWxzZSBmb3IodmFyIHQ9ZyxpPW47dDw9aTspe3ZhciByPWgoQS5odWZmbWFuVGFibGVBQyksST0xNSZyLGE9cj4+NDtpZigwPT09SSl7aWYoYTwxNSl7dz1sKGEpKygxPDxhKS0xO2JyZWFrfXQrPTE2fWVsc2UgZVt2W3QrPWFdXT11KEkpKigxPDxvKSx0Kyt9fTpmdW5jdGlvbihBLGUpe2Zvcih2YXIgdD1nLGk9bixyPTA7dDw9aTspe3ZhciBJPXZbdF0sYT1lW0ldPDA/LTE6MTtzd2l0Y2goRCl7Y2FzZSAwOnZhciBCPWgoQS5odWZmbWFuVGFibGVBQyksQz0xNSZCO2lmKHI9Qj4+NCwwPT09QylyPDE1Pyh3PWwocikrKDE8PHIpLEQ9NCk6KHI9MTYsRD0xKTtlbHNle2lmKDEhPT1DKXRocm93IG5ldyBFcnJvcihcXFwiaW52YWxpZCBBQ24gZW5jb2RpbmdcXFwiKTtkPXUoQyksRD1yPzI6M31jb250aW51ZTtjYXNlIDE6Y2FzZSAyOmVbSV0/ZVtJXSs9KGMoKTw8bykqYTowPT0tLXImJihEPTI9PT1EPzM6MCk7YnJlYWs7Y2FzZSAzOmVbSV0/ZVtJXSs9KGMoKTw8bykqYTooZVtJXT1kPDxvLEQ9MCk7YnJlYWs7Y2FzZSA0OmVbSV0mJihlW0ldKz0oYygpPDxvKSphKX10Kyt9ND09PUQmJjA9PS0tdyYmKEQ9MCl9OmZ1bmN0aW9uKEEsZSl7dmFyIHQ9aChBLmh1ZmZtYW5UYWJsZURDKSxpPTA9PT10PzA6dSh0KTtBLnByZWQrPWksZVswXT1BLnByZWQ7Zm9yKHZhciByPTE7cjw2NDspe3ZhciBJPWgoQS5odWZmbWFuVGFibGVBQyksZz0xNSZJLG49ST4+NDtpZigwPT09Zyl7aWYobjwxNSlicmVhaztyKz0xNn1lbHNlIGVbdltyKz1uXV09dShnKSxyKyt9fTt2YXIgTCxiLE09MDtiPTE9PT1VP3JbMF0uYmxvY2tzUGVyTGluZSpyWzBdLmJsb2Nrc1BlckNvbHVtbjpCKmkubWN1c1BlckNvbHVtbjtmb3IodmFyIE49SXx8YjtNPGI7KXtmb3IobT0wO208VTttKyspclttXS5wcmVkPTA7aWYodz0wLDE9PT1VKWZvcihwPXJbMF0sUz0wO1M8TjtTKyspayhwLFIsTSksTSsrO2Vsc2UgZm9yKFM9MDtTPE47UysrKXtmb3IobT0wO208VTttKyspe3ZhciB4PXA9clttXSxKPXguaCxxPXgudjtmb3IoRz0wO0c8cTtHKyspZm9yKEY9MDtGPEo7RisrKXkocCxSLE0sRyxGKX1pZigrK009PT1iKWJyZWFrfWlmKGY9MCwoTD1BW0VdPDw4fEFbRSsxXSk8NjUyODApdGhyb3cgbmV3IEVycm9yKFxcXCJtYXJrZXIgd2FzIG5vdCBmb3VuZFxcXCIpO2lmKCEoTD49NjU0ODgmJkw8PTY1NDk1KSlicmVhaztFKz0yfXJldHVybiBFLVF9ZnVuY3Rpb24gTChBLGUpe3ZhciB0PVtdLGk9ZS5ibG9ja3NQZXJMaW5lLHI9ZS5ibG9ja3NQZXJDb2x1bW4sST1pPDwzLGc9bmV3IEludDMyQXJyYXkoNjQpLG49bmV3IFVpbnQ4QXJyYXkoNjQpO2Z1bmN0aW9uIGEoQSx0LGkpe3ZhciByLEksZyxuLGEsbyxCLEMsUSxFLHM9ZS5xdWFudGl6YXRpb25UYWJsZSxmPWk7Zm9yKEU9MDtFPDY0O0UrKylmW0VdPUFbRV0qc1tFXTtmb3IoRT0wO0U8ODsrK0Upe3ZhciBjPTgqRTswIT09ZlsxK2NdfHwwIT09ZlsyK2NdfHwwIT09ZlszK2NdfHwwIT09Zls0K2NdfHwwIT09Zls1K2NdfHwwIT09Zls2K2NdfHwwIT09Zls3K2NdPyhyPTU3OTMqZlswK2NdKzEyOD4+OCxJPTU3OTMqZls0K2NdKzEyOD4+OCxnPWZbMitjXSxuPWZbNitjXSxhPTI4OTYqKGZbMStjXS1mWzcrY10pKzEyOD4+OCxDPTI4OTYqKGZbMStjXStmWzcrY10pKzEyOD4+OCxvPWZbMytjXTw8NCxRPXItSSsxPj4xLHI9citJKzE+PjEsST1RLFE9Mzc4NCpnKzE1NjcqbisxMjg+PjgsZz0xNTY3KmctMzc4NCpuKzEyOD4+OCxuPVEsUT1hLShCPWZbNStjXTw8NCkrMT4+MSxhPWErQisxPj4xLEI9USxRPUMrbysxPj4xLG89Qy1vKzE+PjEsQz1RLFE9ci1uKzE+PjEscj1yK24rMT4+MSxuPVEsUT1JLWcrMT4+MSxJPUkrZysxPj4xLGc9USxRPTIyNzYqYSszNDA2KkMrMjA0OD4+MTIsYT0zNDA2KmEtMjI3NipDKzIwNDg+PjEyLEM9USxRPTc5OSpvKzQwMTcqQisyMDQ4Pj4xMixvPTQwMTcqby03OTkqQisyMDQ4Pj4xMixCPVEsZlswK2NdPXIrQyxmWzcrY109ci1DLGZbMStjXT1JK0IsZls2K2NdPUktQixmWzIrY109ZytvLGZbNStjXT1nLW8sZlszK2NdPW4rYSxmWzQrY109bi1hKTooUT01NzkzKmZbMCtjXSs1MTI+PjEwLGZbMCtjXT1RLGZbMStjXT1RLGZbMitjXT1RLGZbMytjXT1RLGZbNCtjXT1RLGZbNStjXT1RLGZbNitjXT1RLGZbNytjXT1RKX1mb3IoRT0wO0U8ODsrK0Upe3ZhciBoPUU7MCE9PWZbOCtoXXx8MCE9PWZbMTYraF18fDAhPT1mWzI0K2hdfHwwIT09ZlszMitoXXx8MCE9PWZbNDAraF18fDAhPT1mWzQ4K2hdfHwwIT09Zls1NitoXT8ocj01NzkzKmZbMCtoXSsyMDQ4Pj4xMixJPTU3OTMqZlszMitoXSsyMDQ4Pj4xMixnPWZbMTYraF0sbj1mWzQ4K2hdLGE9Mjg5NiooZls4K2hdLWZbNTYraF0pKzIwNDg+PjEyLEM9Mjg5NiooZls4K2hdK2ZbNTYraF0pKzIwNDg+PjEyLG89ZlsyNCtoXSxRPXItSSsxPj4xLHI9citJKzE+PjEsST1RLFE9Mzc4NCpnKzE1NjcqbisyMDQ4Pj4xMixnPTE1NjcqZy0zNzg0Km4rMjA0OD4+MTIsbj1RLFE9YS0oQj1mWzQwK2hdKSsxPj4xLGE9YStCKzE+PjEsQj1RLFE9QytvKzE+PjEsbz1DLW8rMT4+MSxDPVEsUT1yLW4rMT4+MSxyPXIrbisxPj4xLG49USxRPUktZysxPj4xLEk9SStnKzE+PjEsZz1RLFE9MjI3NiphKzM0MDYqQysyMDQ4Pj4xMixhPTM0MDYqYS0yMjc2KkMrMjA0OD4+MTIsQz1RLFE9Nzk5Km8rNDAxNypCKzIwNDg+PjEyLG89NDAxNypvLTc5OSpCKzIwNDg+PjEyLEI9USxmWzAraF09citDLGZbNTYraF09ci1DLGZbOCtoXT1JK0IsZls0OCtoXT1JLUIsZlsxNitoXT1nK28sZls0MCtoXT1nLW8sZlsyNCtoXT1uK2EsZlszMitoXT1uLWEpOihRPTU3OTMqaVtFKzBdKzgxOTI+PjE0LGZbMCtoXT1RLGZbOCtoXT1RLGZbMTYraF09USxmWzI0K2hdPVEsZlszMitoXT1RLGZbNDAraF09USxmWzQ4K2hdPVEsZls1NitoXT1RKX1mb3IoRT0wO0U8NjQ7KytFKXt2YXIgbD0xMjgrKGZbRV0rOD4+NCk7dFtFXT1sPDA/MDpsPjI1NT8yNTU6bH19Zm9yKHZhciBvPTA7bzxyO28rKyl7Zm9yKHZhciBCPW88PDMsQz0wO0M8ODtDKyspdC5wdXNoKG5ldyBVaW50OEFycmF5KEkpKTtmb3IodmFyIFE9MDtRPGk7USsrKXthKGUuYmxvY2tzW29dW1FdLG4sZyk7Zm9yKHZhciBFPTAscz1RPDwzLGY9MDtmPDg7ZisrKWZvcih2YXIgYz10W0IrZl0saD0wO2g8ODtoKyspY1tzK2hdPW5bRSsrXX19cmV0dXJuIHR9dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBBKCl7Qih0aGlzLEEpLHRoaXMuamZpZj1udWxsLHRoaXMuYWRvYmU9bnVsbCx0aGlzLnF1YW50aXphdGlvblRhYmxlcz1bXSx0aGlzLmh1ZmZtYW5UYWJsZXNBQz1bXSx0aGlzLmh1ZmZtYW5UYWJsZXNEQz1bXSx0aGlzLnJlc2V0RnJhbWVzKCl9cmV0dXJuIFEoQSxbe2tleTpcXFwicmVzZXRGcmFtZXNcXFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5mcmFtZXM9W119fSx7a2V5OlxcXCJwYXJzZVxcXCIsdmFsdWU6ZnVuY3Rpb24oQSl7dmFyIGU9MDtmdW5jdGlvbiB0KCl7dmFyIHQ9QVtlXTw8OHxBW2UrMV07cmV0dXJuIGUrPTIsdH1mdW5jdGlvbiBpKEEpe3ZhciBlLHQsaT0wLHI9MDtmb3IodCBpbiBBLmNvbXBvbmVudHMpQS5jb21wb25lbnRzLmhhc093blByb3BlcnR5KHQpJiYoaTwoZT1BLmNvbXBvbmVudHNbdF0pLmgmJihpPWUuaCkscjxlLnYmJihyPWUudikpO3ZhciBJPU1hdGguY2VpbChBLnNhbXBsZXNQZXJMaW5lLzgvaSksZz1NYXRoLmNlaWwoQS5zY2FuTGluZXMvOC9yKTtmb3IodCBpbiBBLmNvbXBvbmVudHMpaWYoQS5jb21wb25lbnRzLmhhc093blByb3BlcnR5KHQpKXtlPUEuY29tcG9uZW50c1t0XTtmb3IodmFyIG49TWF0aC5jZWlsKE1hdGguY2VpbChBLnNhbXBsZXNQZXJMaW5lLzgpKmUuaC9pKSxhPU1hdGguY2VpbChNYXRoLmNlaWwoQS5zY2FuTGluZXMvOCkqZS52L3IpLG89SSplLmgsQj1nKmUudixDPVtdLFE9MDtRPEI7USsrKXtmb3IodmFyIEU9W10scz0wO3M8bztzKyspRS5wdXNoKG5ldyBJbnQzMkFycmF5KDY0KSk7Qy5wdXNoKEUpfWUuYmxvY2tzUGVyTGluZT1uLGUuYmxvY2tzUGVyQ29sdW1uPWEsZS5ibG9ja3M9Q31BLm1heEg9aSxBLm1heFY9cixBLm1jdXNQZXJMaW5lPUksQS5tY3VzUGVyQ29sdW1uPWd9dmFyIHIsSSxnPXQoKTtpZig2NTQ5NiE9PWcpdGhyb3cgbmV3IEVycm9yKFxcXCJTT0kgbm90IGZvdW5kXFxcIik7Zm9yKGc9dCgpOzY1NDk3IT09Zzspe3N3aXRjaChnKXtjYXNlIDY1MjgwOmJyZWFrO2Nhc2UgNjU1MDQ6Y2FzZSA2NTUwNTpjYXNlIDY1NTA2OmNhc2UgNjU1MDc6Y2FzZSA2NTUwODpjYXNlIDY1NTA5OmNhc2UgNjU1MTA6Y2FzZSA2NTUxMTpjYXNlIDY1NTEyOmNhc2UgNjU1MTM6Y2FzZSA2NTUxNDpjYXNlIDY1NTE1OmNhc2UgNjU1MTY6Y2FzZSA2NTUxNzpjYXNlIDY1NTE4OmNhc2UgNjU1MTk6Y2FzZSA2NTUzNDp2YXIgbj0ocj12b2lkIDAsST12b2lkIDAscj10KCksST1BLnN1YmFycmF5KGUsZStyLTIpLGUrPUkubGVuZ3RoLEkpOzY1NTA0PT09ZyYmNzQ9PT1uWzBdJiY3MD09PW5bMV0mJjczPT09blsyXSYmNzA9PT1uWzNdJiYwPT09bls0XSYmKHRoaXMuamZpZj17dmVyc2lvbjp7bWFqb3I6bls1XSxtaW5vcjpuWzZdfSxkZW5zaXR5VW5pdHM6bls3XSx4RGVuc2l0eTpuWzhdPDw4fG5bOV0seURlbnNpdHk6blsxMF08PDh8blsxMV0sdGh1bWJXaWR0aDpuWzEyXSx0aHVtYkhlaWdodDpuWzEzXSx0aHVtYkRhdGE6bi5zdWJhcnJheSgxNCwxNCszKm5bMTJdKm5bMTNdKX0pLDY1NTE4PT09ZyYmNjU9PT1uWzBdJiYxMDA9PT1uWzFdJiYxMTE9PT1uWzJdJiY5OD09PW5bM10mJjEwMT09PW5bNF0mJjA9PT1uWzVdJiYodGhpcy5hZG9iZT17dmVyc2lvbjpuWzZdLGZsYWdzMDpuWzddPDw4fG5bOF0sZmxhZ3MxOm5bOV08PDh8blsxMF0sdHJhbnNmb3JtQ29kZTpuWzExXX0pO2JyZWFrO2Nhc2UgNjU0OTk6Zm9yKHZhciBhPXQoKStlLTI7ZTxhOyl7dmFyIG89QVtlKytdLEI9bmV3IEludDMyQXJyYXkoNjQpO2lmKG8+PjQ9PTApZm9yKHZhciBDPTA7Qzw2NDtDKyspe0JbdltDXV09QVtlKytdfWVsc2V7aWYobz4+NCE9MSl0aHJvdyBuZXcgRXJyb3IoXFxcIkRRVDogaW52YWxpZCB0YWJsZSBzcGVjXFxcIik7Zm9yKHZhciBRPTA7UTw2NDtRKyspe0JbdltRXV09dCgpfX10aGlzLnF1YW50aXphdGlvblRhYmxlc1sxNSZvXT1CfWJyZWFrO2Nhc2UgNjU0NzI6Y2FzZSA2NTQ3MzpjYXNlIDY1NDc0OnQoKTtmb3IodmFyIEU9e2V4dGVuZGVkOjY1NDczPT09Zyxwcm9ncmVzc2l2ZTo2NTQ3ND09PWcscHJlY2lzaW9uOkFbZSsrXSxzY2FuTGluZXM6dCgpLHNhbXBsZXNQZXJMaW5lOnQoKSxjb21wb25lbnRzOnt9LGNvbXBvbmVudHNPcmRlcjpbXX0scz1BW2UrK10sZj12b2lkIDAsYz0wO2M8cztjKyspe2Y9QVtlXTt2YXIgaD1BW2UrMV0+PjQsbD0xNSZBW2UrMV0sdT1BW2UrMl07RS5jb21wb25lbnRzT3JkZXIucHVzaChmKSxFLmNvbXBvbmVudHNbZl09e2g6aCx2OmwscXVhbnRpemF0aW9uSWR4OnV9LGUrPTN9aShFKSx0aGlzLmZyYW1lcy5wdXNoKEUpO2JyZWFrO2Nhc2UgNjU0NzY6Zm9yKHZhciB3PXQoKSxkPTI7ZDx3Oyl7Zm9yKHZhciBEPUFbZSsrXSx5PW5ldyBVaW50OEFycmF5KDE2KSxrPTAscD0wO3A8MTY7cCsrLGUrKyl5W3BdPUFbZV0says9eVtwXTtmb3IodmFyIG09bmV3IFVpbnQ4QXJyYXkoayksRz0wO0c8aztHKyssZSsrKW1bR109QVtlXTtkKz0xNytrLEQ+PjQ9PTA/dGhpcy5odWZmbWFuVGFibGVzRENbMTUmRF09Uih5LG0pOnRoaXMuaHVmZm1hblRhYmxlc0FDWzE1JkRdPVIoeSxtKX1icmVhaztjYXNlIDY1NTAxOnQoKSx0aGlzLnJlc2V0SW50ZXJ2YWw9dCgpO2JyZWFrO2Nhc2UgNjU0OTg6dCgpO2Zvcih2YXIgRj1BW2UrK10sUz1bXSxMPXRoaXMuZnJhbWVzWzBdLGI9MDtiPEY7YisrKXt2YXIgTT1MLmNvbXBvbmVudHNbQVtlKytdXSxOPUFbZSsrXTtNLmh1ZmZtYW5UYWJsZURDPXRoaXMuaHVmZm1hblRhYmxlc0RDW04+PjRdLE0uaHVmZm1hblRhYmxlQUM9dGhpcy5odWZmbWFuVGFibGVzQUNbMTUmTl0sUy5wdXNoKE0pfXZhciB4PUFbZSsrXSxKPUFbZSsrXSxxPUFbZSsrXSxZPVUoQSxlLEwsUyx0aGlzLnJlc2V0SW50ZXJ2YWwseCxKLHE+PjQsMTUmcSk7ZSs9WTticmVhaztjYXNlIDY1NTM1OjI1NSE9PUFbZV0mJmUtLTticmVhaztkZWZhdWx0OmlmKDI1NT09PUFbZS0zXSYmQVtlLTJdPj0xOTImJkFbZS0yXTw9MjU0KXtlLT0zO2JyZWFrfXRocm93IG5ldyBFcnJvcihcXFwidW5rbm93biBKUEVHIG1hcmtlciBcXFwiLmNvbmNhdChnLnRvU3RyaW5nKDE2KSkpfWc9dCgpfX19LHtrZXk6XFxcImdldFJlc3VsdFxcXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgQT10aGlzLmZyYW1lcztpZigwPT09dGhpcy5mcmFtZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcXFwibm8gZnJhbWVzIHdlcmUgZGVjb2RlZFxcXCIpO3RoaXMuZnJhbWVzLmxlbmd0aD4xJiZjb25zb2xlLndhcm4oXFxcIm1vcmUgdGhhbiBvbmUgZnJhbWUgaXMgbm90IHN1cHBvcnRlZFxcXCIpO2Zvcih2YXIgZT0wO2U8dGhpcy5mcmFtZXMubGVuZ3RoO2UrKylmb3IodmFyIHQ9dGhpcy5mcmFtZXNbZV0uY29tcG9uZW50cyxpPTAscj1PYmplY3Qua2V5cyh0KTtpPHIubGVuZ3RoO2krKyl7dmFyIEk9cltpXTt0W0ldLnF1YW50aXphdGlvblRhYmxlPXRoaXMucXVhbnRpemF0aW9uVGFibGVzW3RbSV0ucXVhbnRpemF0aW9uSWR4XSxkZWxldGUgdFtJXS5xdWFudGl6YXRpb25JZHh9Zm9yKHZhciBnPUFbMF0sbj1nLmNvbXBvbmVudHMsYT1nLmNvbXBvbmVudHNPcmRlcixvPVtdLEI9Zy5zYW1wbGVzUGVyTGluZSxDPWcuc2NhbkxpbmVzLFE9MDtRPGEubGVuZ3RoO1ErKyl7dmFyIEU9blthW1FdXTtvLnB1c2goe2xpbmVzOkwoMCxFKSxzY2FsZVg6RS5oL2cubWF4SCxzY2FsZVk6RS52L2cubWF4Vn0pfWZvcih2YXIgcz1uZXcgVWludDhBcnJheShCKkMqby5sZW5ndGgpLGY9MCxjPTA7YzxDOysrYylmb3IodmFyIGg9MDtoPEI7KytoKWZvcih2YXIgbD0wO2w8by5sZW5ndGg7KytsKXt2YXIgdT1vW2xdO3NbZl09dS5saW5lc1swfGMqdS5zY2FsZVldWzB8aCp1LnNjYWxlWF0sKytmfXJldHVybiBzfX1dKSxBfSgpLE09ZnVuY3Rpb24oQSl7cyh0LHcpO3ZhciBlPVModCk7ZnVuY3Rpb24gdChBKXt2YXIgaTtyZXR1cm4gQih0aGlzLHQpLChpPWUuY2FsbCh0aGlzKSkucmVhZGVyPW5ldyBiLEEuSlBFR1RhYmxlcyYmaS5yZWFkZXIucGFyc2UoQS5KUEVHVGFibGVzKSxpfXJldHVybiBRKHQsW3trZXk6XFxcImRlY29kZUJsb2NrXFxcIix2YWx1ZTpmdW5jdGlvbihBKXtyZXR1cm4gdGhpcy5yZWFkZXIucmVzZXRGcmFtZXMoKSx0aGlzLnJlYWRlci5wYXJzZShuZXcgVWludDhBcnJheShBKSksdGhpcy5yZWFkZXIuZ2V0UmVzdWx0KCkuYnVmZmVyfX1dKSx0fSgpLE49T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsZGVmYXVsdDpNfSk7ZnVuY3Rpb24geChBKXtmb3IodmFyIGU9QS5sZW5ndGg7LS1lPj0wOylBW2VdPTB9eChuZXcgQXJyYXkoNTc2KSkseChuZXcgQXJyYXkoNjApKSx4KG5ldyBBcnJheSg1MTIpKSx4KG5ldyBBcnJheSgyNTYpKSx4KG5ldyBBcnJheSgyOSkpLHgobmV3IEFycmF5KDMwKSk7dmFyIEo9ZnVuY3Rpb24oQSxlLHQsaSl7Zm9yKHZhciByPTY1NTM1JkF8MCxJPUE+Pj4xNiY2NTUzNXwwLGc9MDswIT09dDspe3QtPWc9dD4yZTM/MmUzOnQ7ZG97ST1JKyhyPXIrZVtpKytdfDApfDB9d2hpbGUoLS1nKTtyJT02NTUyMSxJJT02NTUyMX1yZXR1cm4gcnxJPDwxNnwwfSxxPW5ldyBVaW50MzJBcnJheShmdW5jdGlvbigpe2Zvcih2YXIgQSxlPVtdLHQ9MDt0PDI1Njt0Kyspe0E9dDtmb3IodmFyIGk9MDtpPDg7aSsrKUE9MSZBPzM5ODgyOTIzODReQT4+PjE6QT4+PjE7ZVt0XT1BfXJldHVybiBlfSgpKSxZPWZ1bmN0aW9uKEEsZSx0LGkpe3ZhciByPXEsST1pK3Q7QV49LTE7Zm9yKHZhciBnPWk7ZzxJO2crKylBPUE+Pj44XnJbMjU1JihBXmVbZ10pXTtyZXR1cm4tMV5BfSxLPXsyOlxcXCJuZWVkIGRpY3Rpb25hcnlcXFwiLDE6XFxcInN0cmVhbSBlbmRcXFwiLDA6XFxcIlxcXCIsXFxcIi0xXFxcIjpcXFwiZmlsZSBlcnJvclxcXCIsXFxcIi0yXFxcIjpcXFwic3RyZWFtIGVycm9yXFxcIixcXFwiLTNcXFwiOlxcXCJkYXRhIGVycm9yXFxcIixcXFwiLTRcXFwiOlxcXCJpbnN1ZmZpY2llbnQgbWVtb3J5XFxcIixcXFwiLTVcXFwiOlxcXCJidWZmZXIgZXJyb3JcXFwiLFxcXCItNlxcXCI6XFxcImluY29tcGF0aWJsZSB2ZXJzaW9uXFxcIn0sSD17Wl9OT19GTFVTSDowLFpfUEFSVElBTF9GTFVTSDoxLFpfU1lOQ19GTFVTSDoyLFpfRlVMTF9GTFVTSDozLFpfRklOSVNIOjQsWl9CTE9DSzo1LFpfVFJFRVM6NixaX09LOjAsWl9TVFJFQU1fRU5EOjEsWl9ORUVEX0RJQ1Q6MixaX0VSUk5POi0xLFpfU1RSRUFNX0VSUk9SOi0yLFpfREFUQV9FUlJPUjotMyxaX01FTV9FUlJPUjotNCxaX0JVRl9FUlJPUjotNSxaX05PX0NPTVBSRVNTSU9OOjAsWl9CRVNUX1NQRUVEOjEsWl9CRVNUX0NPTVBSRVNTSU9OOjksWl9ERUZBVUxUX0NPTVBSRVNTSU9OOi0xLFpfRklMVEVSRUQ6MSxaX0hVRkZNQU5fT05MWToyLFpfUkxFOjMsWl9GSVhFRDo0LFpfREVGQVVMVF9TVFJBVEVHWTowLFpfQklOQVJZOjAsWl9URVhUOjEsWl9VTktOT1dOOjIsWl9ERUZMQVRFRDo4fSxPPWZ1bmN0aW9uKEEsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChBLGUpfSxQPWZ1bmN0aW9uKEEpe2Zvcih2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7ZS5sZW5ndGg7KXt2YXIgaT1lLnNoaWZ0KCk7aWYoaSl7aWYoXFxcIm9iamVjdFxcXCIhPT10KGkpKXRocm93IG5ldyBUeXBlRXJyb3IoaStcXFwibXVzdCBiZSBub24tb2JqZWN0XFxcIik7Zm9yKHZhciByIGluIGkpTyhpLHIpJiYoQVtyXT1pW3JdKX19cmV0dXJuIEF9LFQ9ZnVuY3Rpb24oQSl7Zm9yKHZhciBlPTAsdD0wLGk9QS5sZW5ndGg7dDxpO3QrKyllKz1BW3RdLmxlbmd0aDtmb3IodmFyIHI9bmV3IFVpbnQ4QXJyYXkoZSksST0wLGc9MCxuPUEubGVuZ3RoO0k8bjtJKyspe3ZhciBhPUFbSV07ci5zZXQoYSxnKSxnKz1hLmxlbmd0aH1yZXR1cm4gcn0sVj0hMDt0cnl7U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLG5ldyBVaW50OEFycmF5KDEpKX1jYXRjaChBKXtWPSExfWZvcih2YXIgXz1uZXcgVWludDhBcnJheSgyNTYpLFg9MDtYPDI1NjtYKyspX1tYXT1YPj0yNTI/NjpYPj0yNDg/NTpYPj0yNDA/NDpYPj0yMjQ/MzpYPj0xOTI/MjoxO19bMjU0XT1fWzI1NF09MTt2YXIgWj1mdW5jdGlvbihBKXtpZihcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgVGV4dEVuY29kZXImJlRleHRFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUpcmV0dXJuKG5ldyBUZXh0RW5jb2RlcikuZW5jb2RlKEEpO3ZhciBlLHQsaSxyLEksZz1BLmxlbmd0aCxuPTA7Zm9yKHI9MDtyPGc7cisrKTU1Mjk2PT0oNjQ1MTImKHQ9QS5jaGFyQ29kZUF0KHIpKSkmJnIrMTxnJiY1NjMyMD09KDY0NTEyJihpPUEuY2hhckNvZGVBdChyKzEpKSkmJih0PTY1NTM2Kyh0LTU1Mjk2PDwxMCkrKGktNTYzMjApLHIrKyksbis9dDwxMjg/MTp0PDIwNDg/Mjp0PDY1NTM2PzM6NDtmb3IoZT1uZXcgVWludDhBcnJheShuKSxJPTAscj0wO0k8bjtyKyspNTUyOTY9PSg2NDUxMiYodD1BLmNoYXJDb2RlQXQocikpKSYmcisxPGcmJjU2MzIwPT0oNjQ1MTImKGk9QS5jaGFyQ29kZUF0KHIrMSkpKSYmKHQ9NjU1MzYrKHQtNTUyOTY8PDEwKSsoaS01NjMyMCkscisrKSx0PDEyOD9lW0krK109dDp0PDIwNDg/KGVbSSsrXT0xOTJ8dD4+PjYsZVtJKytdPTEyOHw2MyZ0KTp0PDY1NTM2PyhlW0krK109MjI0fHQ+Pj4xMixlW0krK109MTI4fHQ+Pj42JjYzLGVbSSsrXT0xMjh8NjMmdCk6KGVbSSsrXT0yNDB8dD4+PjE4LGVbSSsrXT0xMjh8dD4+PjEyJjYzLGVbSSsrXT0xMjh8dD4+PjYmNjMsZVtJKytdPTEyOHw2MyZ0KTtyZXR1cm4gZX0saj1mdW5jdGlvbihBLGUpe3ZhciB0LGkscj1lfHxBLmxlbmd0aDtpZihcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgVGV4dERlY29kZXImJlRleHREZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUpcmV0dXJuKG5ldyBUZXh0RGVjb2RlcikuZGVjb2RlKEEuc3ViYXJyYXkoMCxlKSk7dmFyIEk9bmV3IEFycmF5KDIqcik7Zm9yKGk9MCx0PTA7dDxyOyl7dmFyIGc9QVt0KytdO2lmKGc8MTI4KUlbaSsrXT1nO2Vsc2V7dmFyIG49X1tnXTtpZihuPjQpSVtpKytdPTY1NTMzLHQrPW4tMTtlbHNle2ZvcihnJj0yPT09bj8zMTozPT09bj8xNTo3O24+MSYmdDxyOylnPWc8PDZ8NjMmQVt0KytdLG4tLTtuPjE/SVtpKytdPTY1NTMzOmc8NjU1MzY/SVtpKytdPWc6KGctPTY1NTM2LElbaSsrXT01NTI5NnxnPj4xMCYxMDIzLElbaSsrXT01NjMyMHwxMDIzJmcpfX19cmV0dXJuIGZ1bmN0aW9uKEEsZSl7aWYoZTw2NTUzNCYmQS5zdWJhcnJheSYmVilyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLEEubGVuZ3RoPT09ZT9BOkEuc3ViYXJyYXkoMCxlKSk7Zm9yKHZhciB0PVxcXCJcXFwiLGk9MDtpPGU7aSsrKXQrPVN0cmluZy5mcm9tQ2hhckNvZGUoQVtpXSk7cmV0dXJuIHR9KEksaSl9LFc9ZnVuY3Rpb24oQSxlKXsoZT1lfHxBLmxlbmd0aCk+QS5sZW5ndGgmJihlPUEubGVuZ3RoKTtmb3IodmFyIHQ9ZS0xO3Q+PTAmJjEyOD09KDE5MiZBW3RdKTspdC0tO3JldHVybiB0PDB8fDA9PT10P2U6dCtfW0FbdF1dPmU/dDplfTt2YXIgej1mdW5jdGlvbigpe3RoaXMuaW5wdXQ9bnVsbCx0aGlzLm5leHRfaW49MCx0aGlzLmF2YWlsX2luPTAsdGhpcy50b3RhbF9pbj0wLHRoaXMub3V0cHV0PW51bGwsdGhpcy5uZXh0X291dD0wLHRoaXMuYXZhaWxfb3V0PTAsdGhpcy50b3RhbF9vdXQ9MCx0aGlzLm1zZz1cXFwiXFxcIix0aGlzLnN0YXRlPW51bGwsdGhpcy5kYXRhX3R5cGU9Mix0aGlzLmFkbGVyPTB9LCQ9ZnVuY3Rpb24oQSxlKXt2YXIgdCxpLHIsSSxnLG4sYSxvLEIsQyxRLEUscyxmLGMsaCxsLHUsdyxkLEQseSxrLHAsbT1BLnN0YXRlO3Q9QS5uZXh0X2luLGs9QS5pbnB1dCxpPXQrKEEuYXZhaWxfaW4tNSkscj1BLm5leHRfb3V0LHA9QS5vdXRwdXQsST1yLShlLUEuYXZhaWxfb3V0KSxnPXIrKEEuYXZhaWxfb3V0LTI1Nyksbj1tLmRtYXgsYT1tLndzaXplLG89bS53aGF2ZSxCPW0ud25leHQsQz1tLndpbmRvdyxRPW0uaG9sZCxFPW0uYml0cyxzPW0ubGVuY29kZSxmPW0uZGlzdGNvZGUsYz0oMTw8bS5sZW5iaXRzKS0xLGg9KDE8PG0uZGlzdGJpdHMpLTE7QTpkb3tFPDE1JiYoUSs9a1t0KytdPDxFLEUrPTgsUSs9a1t0KytdPDxFLEUrPTgpLGw9c1tRJmNdO2U6Zm9yKDs7KXtpZihRPj4+PXU9bD4+PjI0LEUtPXUsMD09PSh1PWw+Pj4xNiYyNTUpKXBbcisrXT02NTUzNSZsO2Vsc2V7aWYoISgxNiZ1KSl7aWYoMD09KDY0JnUpKXtsPXNbKDY1NTM1JmwpKyhRJigxPDx1KS0xKV07Y29udGludWUgZX1pZigzMiZ1KXttLm1vZGU9MTI7YnJlYWsgQX1BLm1zZz1cXFwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXFxcIixtLm1vZGU9MzA7YnJlYWsgQX13PTY1NTM1JmwsKHUmPTE1KSYmKEU8dSYmKFErPWtbdCsrXTw8RSxFKz04KSx3Kz1RJigxPDx1KS0xLFE+Pj49dSxFLT11KSxFPDE1JiYoUSs9a1t0KytdPDxFLEUrPTgsUSs9a1t0KytdPDxFLEUrPTgpLGw9ZltRJmhdO3Q6Zm9yKDs7KXtpZihRPj4+PXU9bD4+PjI0LEUtPXUsISgxNiYodT1sPj4+MTYmMjU1KSkpe2lmKDA9PSg2NCZ1KSl7bD1mWyg2NTUzNSZsKSsoUSYoMTw8dSktMSldO2NvbnRpbnVlIHR9QS5tc2c9XFxcImludmFsaWQgZGlzdGFuY2UgY29kZVxcXCIsbS5tb2RlPTMwO2JyZWFrIEF9aWYoZD02NTUzNSZsLEU8KHUmPTE1KSYmKFErPWtbdCsrXTw8RSwoRSs9OCk8dSYmKFErPWtbdCsrXTw8RSxFKz04KSksKGQrPVEmKDE8PHUpLTEpPm4pe0EubXNnPVxcXCJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFja1xcXCIsbS5tb2RlPTMwO2JyZWFrIEF9aWYoUT4+Pj11LEUtPXUsZD4odT1yLUkpKXtpZigodT1kLXUpPm8mJm0uc2FuZSl7QS5tc2c9XFxcImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrXFxcIixtLm1vZGU9MzA7YnJlYWsgQX1pZihEPTAseT1DLDA9PT1CKXtpZihEKz1hLXUsdTx3KXt3LT11O2Rve3BbcisrXT1DW0QrK119d2hpbGUoLS11KTtEPXItZCx5PXB9fWVsc2UgaWYoQjx1KXtpZihEKz1hK0ItdSwodS09Qik8dyl7dy09dTtkb3twW3IrK109Q1tEKytdfXdoaWxlKC0tdSk7aWYoRD0wLEI8dyl7dy09dT1CO2Rve3BbcisrXT1DW0QrK119d2hpbGUoLS11KTtEPXItZCx5PXB9fX1lbHNlIGlmKEQrPUItdSx1PHcpe3ctPXU7ZG97cFtyKytdPUNbRCsrXX13aGlsZSgtLXUpO0Q9ci1kLHk9cH1mb3IoO3c+MjspcFtyKytdPXlbRCsrXSxwW3IrK109eVtEKytdLHBbcisrXT15W0QrK10sdy09Mzt3JiYocFtyKytdPXlbRCsrXSx3PjEmJihwW3IrK109eVtEKytdKSl9ZWxzZXtEPXItZDtkb3twW3IrK109cFtEKytdLHBbcisrXT1wW0QrK10scFtyKytdPXBbRCsrXSx3LT0zfXdoaWxlKHc+Mik7dyYmKHBbcisrXT1wW0QrK10sdz4xJiYocFtyKytdPXBbRCsrXSkpfWJyZWFrfX1icmVha319d2hpbGUodDxpJiZyPGcpO3QtPXc9RT4+MyxRJj0oMTw8KEUtPXc8PDMpKS0xLEEubmV4dF9pbj10LEEubmV4dF9vdXQ9cixBLmF2YWlsX2luPXQ8aT9pLXQrNTo1LSh0LWkpLEEuYXZhaWxfb3V0PXI8Zz9nLXIrMjU3OjI1Ny0oci1nKSxtLmhvbGQ9USxtLmJpdHM9RX0sQUE9bmV3IFVpbnQxNkFycmF5KFszLDQsNSw2LDcsOCw5LDEwLDExLDEzLDE1LDE3LDE5LDIzLDI3LDMxLDM1LDQzLDUxLDU5LDY3LDgzLDk5LDExNSwxMzEsMTYzLDE5NSwyMjcsMjU4LDAsMF0pLGVBPW5ldyBVaW50OEFycmF5KFsxNiwxNiwxNiwxNiwxNiwxNiwxNiwxNiwxNywxNywxNywxNywxOCwxOCwxOCwxOCwxOSwxOSwxOSwxOSwyMCwyMCwyMCwyMCwyMSwyMSwyMSwyMSwxNiw3Miw3OF0pLHRBPW5ldyBVaW50MTZBcnJheShbMSwyLDMsNCw1LDcsOSwxMywxNywyNSwzMyw0OSw2NSw5NywxMjksMTkzLDI1NywzODUsNTEzLDc2OSwxMDI1LDE1MzcsMjA0OSwzMDczLDQwOTcsNjE0NSw4MTkzLDEyMjg5LDE2Mzg1LDI0NTc3LDAsMF0pLGlBPW5ldyBVaW50OEFycmF5KFsxNiwxNiwxNiwxNiwxNywxNywxOCwxOCwxOSwxOSwyMCwyMCwyMSwyMSwyMiwyMiwyMywyMywyNCwyNCwyNSwyNSwyNiwyNiwyNywyNywyOCwyOCwyOSwyOSw2NCw2NF0pLHJBPWZ1bmN0aW9uKEEsZSx0LGkscixJLGcsbil7dmFyIGEsbyxCLEMsUSxFLHMsZixjLGg9bi5iaXRzLGw9MCx1PTAsdz0wLGQ9MCxEPTAseT0wLGs9MCxwPTAsbT0wLEc9MCxGPW51bGwsUz0wLHY9bmV3IFVpbnQxNkFycmF5KDE2KSxSPW5ldyBVaW50MTZBcnJheSgxNiksVT1udWxsLEw9MDtmb3IobD0wO2w8PTE1O2wrKyl2W2xdPTA7Zm9yKHU9MDt1PGk7dSsrKXZbZVt0K3VdXSsrO2ZvcihEPWgsZD0xNTtkPj0xJiYwPT09dltkXTtkLS0pO2lmKEQ+ZCYmKEQ9ZCksMD09PWQpcmV0dXJuIHJbSSsrXT0yMDk3MTUyMCxyW0krK109MjA5NzE1MjAsbi5iaXRzPTEsMDtmb3Iodz0xO3c8ZCYmMD09PXZbd107dysrKTtmb3IoRDx3JiYoRD13KSxwPTEsbD0xO2w8PTE1O2wrKylpZihwPDw9MSwocC09dltsXSk8MClyZXR1cm4tMTtpZihwPjAmJigwPT09QXx8MSE9PWQpKXJldHVybi0xO2ZvcihSWzFdPTAsbD0xO2w8MTU7bCsrKVJbbCsxXT1SW2xdK3ZbbF07Zm9yKHU9MDt1PGk7dSsrKTAhPT1lW3QrdV0mJihnW1JbZVt0K3VdXSsrXT11KTtpZigwPT09QT8oRj1VPWcsRT0xOSk6MT09PUE/KEY9QUEsUy09MjU3LFU9ZUEsTC09MjU3LEU9MjU2KTooRj10QSxVPWlBLEU9LTEpLEc9MCx1PTAsbD13LFE9SSx5PUQsaz0wLEI9LTEsQz0obT0xPDxEKS0xLDE9PT1BJiZtPjg1Mnx8Mj09PUEmJm0+NTkyKXJldHVybiAxO2Zvcig7Oyl7cz1sLWssZ1t1XTxFPyhmPTAsYz1nW3VdKTpnW3VdPkU/KGY9VVtMK2dbdV1dLGM9RltTK2dbdV1dKTooZj05NixjPTApLGE9MTw8bC1rLHc9bz0xPDx5O2Rve3JbUSsoRz4+aykrKG8tPWEpXT1zPDwyNHxmPDwxNnxjfDB9d2hpbGUoMCE9PW8pO2ZvcihhPTE8PGwtMTtHJmE7KWE+Pj0xO2lmKDAhPT1hPyhHJj1hLTEsRys9YSk6Rz0wLHUrKywwPT0tLXZbbF0pe2lmKGw9PT1kKWJyZWFrO2w9ZVt0K2dbdV1dfWlmKGw+RCYmKEcmQykhPT1CKXtmb3IoMD09PWsmJihrPUQpLFErPXcscD0xPDwoeT1sLWspO3krazxkJiYhKChwLT12W3kra10pPD0wKTspeSsrLHA8PD0xO2lmKG0rPTE8PHksMT09PUEmJm0+ODUyfHwyPT09QSYmbT41OTIpcmV0dXJuIDE7cltCPUcmQ109RDw8MjR8eTw8MTZ8US1JfDB9fXJldHVybiAwIT09RyYmKHJbUStHXT1sLWs8PDI0fDY0PDwxNnwwKSxuLmJpdHM9RCwwfSxJQT1ILlpfRklOSVNILGdBPUguWl9CTE9DSyxuQT1ILlpfVFJFRVMsYUE9SC5aX09LLG9BPUguWl9TVFJFQU1fRU5ELEJBPUguWl9ORUVEX0RJQ1QsQ0E9SC5aX1NUUkVBTV9FUlJPUixRQT1ILlpfREFUQV9FUlJPUixFQT1ILlpfTUVNX0VSUk9SLHNBPUguWl9CVUZfRVJST1IsZkE9SC5aX0RFRkxBVEVELGNBPWZ1bmN0aW9uKEEpe3JldHVybihBPj4+MjQmMjU1KSsoQT4+PjgmNjUyODApKygoNjUyODAmQSk8PDgpKygoMjU1JkEpPDwyNCl9O2Z1bmN0aW9uIGhBKCl7dGhpcy5tb2RlPTAsdGhpcy5sYXN0PSExLHRoaXMud3JhcD0wLHRoaXMuaGF2ZWRpY3Q9ITEsdGhpcy5mbGFncz0wLHRoaXMuZG1heD0wLHRoaXMuY2hlY2s9MCx0aGlzLnRvdGFsPTAsdGhpcy5oZWFkPW51bGwsdGhpcy53Yml0cz0wLHRoaXMud3NpemU9MCx0aGlzLndoYXZlPTAsdGhpcy53bmV4dD0wLHRoaXMud2luZG93PW51bGwsdGhpcy5ob2xkPTAsdGhpcy5iaXRzPTAsdGhpcy5sZW5ndGg9MCx0aGlzLm9mZnNldD0wLHRoaXMuZXh0cmE9MCx0aGlzLmxlbmNvZGU9bnVsbCx0aGlzLmRpc3Rjb2RlPW51bGwsdGhpcy5sZW5iaXRzPTAsdGhpcy5kaXN0Yml0cz0wLHRoaXMubmNvZGU9MCx0aGlzLm5sZW49MCx0aGlzLm5kaXN0PTAsdGhpcy5oYXZlPTAsdGhpcy5uZXh0PW51bGwsdGhpcy5sZW5zPW5ldyBVaW50MTZBcnJheSgzMjApLHRoaXMud29yaz1uZXcgVWludDE2QXJyYXkoMjg4KSx0aGlzLmxlbmR5bj1udWxsLHRoaXMuZGlzdGR5bj1udWxsLHRoaXMuc2FuZT0wLHRoaXMuYmFjaz0wLHRoaXMud2FzPTB9dmFyIGxBLHVBLHdBPWZ1bmN0aW9uKEEpe2lmKCFBfHwhQS5zdGF0ZSlyZXR1cm4gQ0E7dmFyIGU9QS5zdGF0ZTtyZXR1cm4gQS50b3RhbF9pbj1BLnRvdGFsX291dD1lLnRvdGFsPTAsQS5tc2c9XFxcIlxcXCIsZS53cmFwJiYoQS5hZGxlcj0xJmUud3JhcCksZS5tb2RlPTEsZS5sYXN0PTAsZS5oYXZlZGljdD0wLGUuZG1heD0zMjc2OCxlLmhlYWQ9bnVsbCxlLmhvbGQ9MCxlLmJpdHM9MCxlLmxlbmNvZGU9ZS5sZW5keW49bmV3IEludDMyQXJyYXkoODUyKSxlLmRpc3Rjb2RlPWUuZGlzdGR5bj1uZXcgSW50MzJBcnJheSg1OTIpLGUuc2FuZT0xLGUuYmFjaz0tMSxhQX0sZEE9ZnVuY3Rpb24oQSl7aWYoIUF8fCFBLnN0YXRlKXJldHVybiBDQTt2YXIgZT1BLnN0YXRlO3JldHVybiBlLndzaXplPTAsZS53aGF2ZT0wLGUud25leHQ9MCx3QShBKX0sREE9ZnVuY3Rpb24oQSxlKXt2YXIgdDtpZighQXx8IUEuc3RhdGUpcmV0dXJuIENBO3ZhciBpPUEuc3RhdGU7cmV0dXJuIGU8MD8odD0wLGU9LWUpOih0PTErKGU+PjQpLGU8NDgmJihlJj0xNSkpLGUmJihlPDh8fGU+MTUpP0NBOihudWxsIT09aS53aW5kb3cmJmkud2JpdHMhPT1lJiYoaS53aW5kb3c9bnVsbCksaS53cmFwPXQsaS53Yml0cz1lLGRBKEEpKX0seUE9ZnVuY3Rpb24oQSxlKXtpZighQSlyZXR1cm4gQ0E7dmFyIHQ9bmV3IGhBO0Euc3RhdGU9dCx0LndpbmRvdz1udWxsO3ZhciBpPURBKEEsZSk7cmV0dXJuIGkhPT1hQSYmKEEuc3RhdGU9bnVsbCksaX0sa0E9ITAscEE9ZnVuY3Rpb24oQSl7aWYoa0Epe2xBPW5ldyBJbnQzMkFycmF5KDUxMiksdUE9bmV3IEludDMyQXJyYXkoMzIpO2Zvcih2YXIgZT0wO2U8MTQ0OylBLmxlbnNbZSsrXT04O2Zvcig7ZTwyNTY7KUEubGVuc1tlKytdPTk7Zm9yKDtlPDI4MDspQS5sZW5zW2UrK109Nztmb3IoO2U8Mjg4OylBLmxlbnNbZSsrXT04O2ZvcihyQSgxLEEubGVucywwLDI4OCxsQSwwLEEud29yayx7Yml0czo5fSksZT0wO2U8MzI7KUEubGVuc1tlKytdPTU7ckEoMixBLmxlbnMsMCwzMix1QSwwLEEud29yayx7Yml0czo1fSksa0E9ITF9QS5sZW5jb2RlPWxBLEEubGVuYml0cz05LEEuZGlzdGNvZGU9dUEsQS5kaXN0Yml0cz01fSxtQT1mdW5jdGlvbihBLGUsdCxpKXt2YXIgcixJPUEuc3RhdGU7cmV0dXJuIG51bGw9PT1JLndpbmRvdyYmKEkud3NpemU9MTw8SS53Yml0cyxJLnduZXh0PTAsSS53aGF2ZT0wLEkud2luZG93PW5ldyBVaW50OEFycmF5KEkud3NpemUpKSxpPj1JLndzaXplPyhJLndpbmRvdy5zZXQoZS5zdWJhcnJheSh0LUkud3NpemUsdCksMCksSS53bmV4dD0wLEkud2hhdmU9SS53c2l6ZSk6KChyPUkud3NpemUtSS53bmV4dCk+aSYmKHI9aSksSS53aW5kb3cuc2V0KGUuc3ViYXJyYXkodC1pLHQtaStyKSxJLnduZXh0KSwoaS09cik/KEkud2luZG93LnNldChlLnN1YmFycmF5KHQtaSx0KSwwKSxJLnduZXh0PWksSS53aGF2ZT1JLndzaXplKTooSS53bmV4dCs9cixJLnduZXh0PT09SS53c2l6ZSYmKEkud25leHQ9MCksSS53aGF2ZTxJLndzaXplJiYoSS53aGF2ZSs9cikpKSwwfSxHQT17aW5mbGF0ZVJlc2V0OmRBLGluZmxhdGVSZXNldDI6REEsaW5mbGF0ZVJlc2V0S2VlcDp3QSxpbmZsYXRlSW5pdDpmdW5jdGlvbihBKXtyZXR1cm4geUEoQSwxNSl9LGluZmxhdGVJbml0Mjp5QSxpbmZsYXRlOmZ1bmN0aW9uKEEsZSl7dmFyIHQsaSxyLEksZyxuLGEsbyxCLEMsUSxFLHMsZixjLGgsbCx1LHcsZCxELHksayxwLG09MCxHPW5ldyBVaW50OEFycmF5KDQpLEY9bmV3IFVpbnQ4QXJyYXkoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKTtpZighQXx8IUEuc3RhdGV8fCFBLm91dHB1dHx8IUEuaW5wdXQmJjAhPT1BLmF2YWlsX2luKXJldHVybiBDQTsxMj09PSh0PUEuc3RhdGUpLm1vZGUmJih0Lm1vZGU9MTMpLGc9QS5uZXh0X291dCxyPUEub3V0cHV0LGE9QS5hdmFpbF9vdXQsST1BLm5leHRfaW4saT1BLmlucHV0LG49QS5hdmFpbF9pbixvPXQuaG9sZCxCPXQuYml0cyxDPW4sUT1hLHk9YUE7QTpmb3IoOzspc3dpdGNoKHQubW9kZSl7Y2FzZSAxOmlmKDA9PT10LndyYXApe3QubW9kZT0xMzticmVha31mb3IoO0I8MTY7KXtpZigwPT09bilicmVhayBBO24tLSxvKz1pW0krK108PEIsQis9OH1pZigyJnQud3JhcCYmMzU2MTU9PT1vKXt0LmNoZWNrPTAsR1swXT0yNTUmbyxHWzFdPW8+Pj44JjI1NSx0LmNoZWNrPVkodC5jaGVjayxHLDIsMCksbz0wLEI9MCx0Lm1vZGU9MjticmVha31pZih0LmZsYWdzPTAsdC5oZWFkJiYodC5oZWFkLmRvbmU9ITEpLCEoMSZ0LndyYXApfHwoKCgyNTUmbyk8PDgpKyhvPj44KSklMzEpe0EubXNnPVxcXCJpbmNvcnJlY3QgaGVhZGVyIGNoZWNrXFxcIix0Lm1vZGU9MzA7YnJlYWt9aWYoKDE1Jm8pIT09ZkEpe0EubXNnPVxcXCJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZFxcXCIsdC5tb2RlPTMwO2JyZWFrfWlmKEItPTQsRD04KygxNSYobz4+Pj00KSksMD09PXQud2JpdHMpdC53Yml0cz1EO2Vsc2UgaWYoRD50LndiaXRzKXtBLm1zZz1cXFwiaW52YWxpZCB3aW5kb3cgc2l6ZVxcXCIsdC5tb2RlPTMwO2JyZWFrfXQuZG1heD0xPDx0LndiaXRzLEEuYWRsZXI9dC5jaGVjaz0xLHQubW9kZT01MTImbz8xMDoxMixvPTAsQj0wO2JyZWFrO2Nhc2UgMjpmb3IoO0I8MTY7KXtpZigwPT09bilicmVhayBBO24tLSxvKz1pW0krK108PEIsQis9OH1pZih0LmZsYWdzPW8sKDI1NSZ0LmZsYWdzKSE9PWZBKXtBLm1zZz1cXFwidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2RcXFwiLHQubW9kZT0zMDticmVha31pZig1NzM0NCZ0LmZsYWdzKXtBLm1zZz1cXFwidW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0XFxcIix0Lm1vZGU9MzA7YnJlYWt9dC5oZWFkJiYodC5oZWFkLnRleHQ9bz4+OCYxKSw1MTImdC5mbGFncyYmKEdbMF09MjU1Jm8sR1sxXT1vPj4+OCYyNTUsdC5jaGVjaz1ZKHQuY2hlY2ssRywyLDApKSxvPTAsQj0wLHQubW9kZT0zO2Nhc2UgMzpmb3IoO0I8MzI7KXtpZigwPT09bilicmVhayBBO24tLSxvKz1pW0krK108PEIsQis9OH10LmhlYWQmJih0LmhlYWQudGltZT1vKSw1MTImdC5mbGFncyYmKEdbMF09MjU1Jm8sR1sxXT1vPj4+OCYyNTUsR1syXT1vPj4+MTYmMjU1LEdbM109bz4+PjI0JjI1NSx0LmNoZWNrPVkodC5jaGVjayxHLDQsMCkpLG89MCxCPTAsdC5tb2RlPTQ7Y2FzZSA0OmZvcig7QjwxNjspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fXQuaGVhZCYmKHQuaGVhZC54ZmxhZ3M9MjU1Jm8sdC5oZWFkLm9zPW8+PjgpLDUxMiZ0LmZsYWdzJiYoR1swXT0yNTUmbyxHWzFdPW8+Pj44JjI1NSx0LmNoZWNrPVkodC5jaGVjayxHLDIsMCkpLG89MCxCPTAsdC5tb2RlPTU7Y2FzZSA1OmlmKDEwMjQmdC5mbGFncyl7Zm9yKDtCPDE2Oyl7aWYoMD09PW4pYnJlYWsgQTtuLS0sbys9aVtJKytdPDxCLEIrPTh9dC5sZW5ndGg9byx0LmhlYWQmJih0LmhlYWQuZXh0cmFfbGVuPW8pLDUxMiZ0LmZsYWdzJiYoR1swXT0yNTUmbyxHWzFdPW8+Pj44JjI1NSx0LmNoZWNrPVkodC5jaGVjayxHLDIsMCkpLG89MCxCPTB9ZWxzZSB0LmhlYWQmJih0LmhlYWQuZXh0cmE9bnVsbCk7dC5tb2RlPTY7Y2FzZSA2OmlmKDEwMjQmdC5mbGFncyYmKChFPXQubGVuZ3RoKT5uJiYoRT1uKSxFJiYodC5oZWFkJiYoRD10LmhlYWQuZXh0cmFfbGVuLXQubGVuZ3RoLHQuaGVhZC5leHRyYXx8KHQuaGVhZC5leHRyYT1uZXcgVWludDhBcnJheSh0LmhlYWQuZXh0cmFfbGVuKSksdC5oZWFkLmV4dHJhLnNldChpLnN1YmFycmF5KEksSStFKSxEKSksNTEyJnQuZmxhZ3MmJih0LmNoZWNrPVkodC5jaGVjayxpLEUsSSkpLG4tPUUsSSs9RSx0Lmxlbmd0aC09RSksdC5sZW5ndGgpKWJyZWFrIEE7dC5sZW5ndGg9MCx0Lm1vZGU9NztjYXNlIDc6aWYoMjA0OCZ0LmZsYWdzKXtpZigwPT09bilicmVhayBBO0U9MDtkb3tEPWlbSStFKytdLHQuaGVhZCYmRCYmdC5sZW5ndGg8NjU1MzYmJih0LmhlYWQubmFtZSs9U3RyaW5nLmZyb21DaGFyQ29kZShEKSl9d2hpbGUoRCYmRTxuKTtpZig1MTImdC5mbGFncyYmKHQuY2hlY2s9WSh0LmNoZWNrLGksRSxJKSksbi09RSxJKz1FLEQpYnJlYWsgQX1lbHNlIHQuaGVhZCYmKHQuaGVhZC5uYW1lPW51bGwpO3QubGVuZ3RoPTAsdC5tb2RlPTg7Y2FzZSA4OmlmKDQwOTYmdC5mbGFncyl7aWYoMD09PW4pYnJlYWsgQTtFPTA7ZG97RD1pW0krRSsrXSx0LmhlYWQmJkQmJnQubGVuZ3RoPDY1NTM2JiYodC5oZWFkLmNvbW1lbnQrPVN0cmluZy5mcm9tQ2hhckNvZGUoRCkpfXdoaWxlKEQmJkU8bik7aWYoNTEyJnQuZmxhZ3MmJih0LmNoZWNrPVkodC5jaGVjayxpLEUsSSkpLG4tPUUsSSs9RSxEKWJyZWFrIEF9ZWxzZSB0LmhlYWQmJih0LmhlYWQuY29tbWVudD1udWxsKTt0Lm1vZGU9OTtjYXNlIDk6aWYoNTEyJnQuZmxhZ3Mpe2Zvcig7QjwxNjspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fWlmKG8hPT0oNjU1MzUmdC5jaGVjaykpe0EubXNnPVxcXCJoZWFkZXIgY3JjIG1pc21hdGNoXFxcIix0Lm1vZGU9MzA7YnJlYWt9bz0wLEI9MH10LmhlYWQmJih0LmhlYWQuaGNyYz10LmZsYWdzPj45JjEsdC5oZWFkLmRvbmU9ITApLEEuYWRsZXI9dC5jaGVjaz0wLHQubW9kZT0xMjticmVhaztjYXNlIDEwOmZvcig7QjwzMjspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fUEuYWRsZXI9dC5jaGVjaz1jQShvKSxvPTAsQj0wLHQubW9kZT0xMTtjYXNlIDExOmlmKDA9PT10LmhhdmVkaWN0KXJldHVybiBBLm5leHRfb3V0PWcsQS5hdmFpbF9vdXQ9YSxBLm5leHRfaW49SSxBLmF2YWlsX2luPW4sdC5ob2xkPW8sdC5iaXRzPUIsQkE7QS5hZGxlcj10LmNoZWNrPTEsdC5tb2RlPTEyO2Nhc2UgMTI6aWYoZT09PWdBfHxlPT09bkEpYnJlYWsgQTtjYXNlIDEzOmlmKHQubGFzdCl7bz4+Pj03JkIsQi09NyZCLHQubW9kZT0yNzticmVha31mb3IoO0I8Mzspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fXN3aXRjaCh0Lmxhc3Q9MSZvLEItPTEsMyYobz4+Pj0xKSl7Y2FzZSAwOnQubW9kZT0xNDticmVhaztjYXNlIDE6aWYocEEodCksdC5tb2RlPTIwLGU9PT1uQSl7bz4+Pj0yLEItPTI7YnJlYWsgQX1icmVhaztjYXNlIDI6dC5tb2RlPTE3O2JyZWFrO2Nhc2UgMzpBLm1zZz1cXFwiaW52YWxpZCBibG9jayB0eXBlXFxcIix0Lm1vZGU9MzB9bz4+Pj0yLEItPTI7YnJlYWs7Y2FzZSAxNDpmb3Iobz4+Pj03JkIsQi09NyZCO0I8MzI7KXtpZigwPT09bilicmVhayBBO24tLSxvKz1pW0krK108PEIsQis9OH1pZigoNjU1MzUmbykhPShvPj4+MTZeNjU1MzUpKXtBLm1zZz1cXFwiaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Roc1xcXCIsdC5tb2RlPTMwO2JyZWFrfWlmKHQubGVuZ3RoPTY1NTM1Jm8sbz0wLEI9MCx0Lm1vZGU9MTUsZT09PW5BKWJyZWFrIEE7Y2FzZSAxNTp0Lm1vZGU9MTY7Y2FzZSAxNjppZihFPXQubGVuZ3RoKXtpZihFPm4mJihFPW4pLEU+YSYmKEU9YSksMD09PUUpYnJlYWsgQTtyLnNldChpLnN1YmFycmF5KEksSStFKSxnKSxuLT1FLEkrPUUsYS09RSxnKz1FLHQubGVuZ3RoLT1FO2JyZWFrfXQubW9kZT0xMjticmVhaztjYXNlIDE3OmZvcig7QjwxNDspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fWlmKHQubmxlbj0yNTcrKDMxJm8pLG8+Pj49NSxCLT01LHQubmRpc3Q9MSsoMzEmbyksbz4+Pj01LEItPTUsdC5uY29kZT00KygxNSZvKSxvPj4+PTQsQi09NCx0Lm5sZW4+Mjg2fHx0Lm5kaXN0PjMwKXtBLm1zZz1cXFwidG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHNcXFwiLHQubW9kZT0zMDticmVha310LmhhdmU9MCx0Lm1vZGU9MTg7Y2FzZSAxODpmb3IoO3QuaGF2ZTx0Lm5jb2RlOyl7Zm9yKDtCPDM7KXtpZigwPT09bilicmVhayBBO24tLSxvKz1pW0krK108PEIsQis9OH10LmxlbnNbRlt0LmhhdmUrK11dPTcmbyxvPj4+PTMsQi09M31mb3IoO3QuaGF2ZTwxOTspdC5sZW5zW0ZbdC5oYXZlKytdXT0wO2lmKHQubGVuY29kZT10LmxlbmR5bix0LmxlbmJpdHM9NyxrPXtiaXRzOnQubGVuYml0c30seT1yQSgwLHQubGVucywwLDE5LHQubGVuY29kZSwwLHQud29yayxrKSx0LmxlbmJpdHM9ay5iaXRzLHkpe0EubXNnPVxcXCJpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXRcXFwiLHQubW9kZT0zMDticmVha310LmhhdmU9MCx0Lm1vZGU9MTk7Y2FzZSAxOTpmb3IoO3QuaGF2ZTx0Lm5sZW4rdC5uZGlzdDspe2Zvcig7aD0obT10LmxlbmNvZGVbbyYoMTw8dC5sZW5iaXRzKS0xXSk+Pj4xNiYyNTUsbD02NTUzNSZtLCEoKGM9bT4+PjI0KTw9Qik7KXtpZigwPT09bilicmVhayBBO24tLSxvKz1pW0krK108PEIsQis9OH1pZihsPDE2KW8+Pj49YyxCLT1jLHQubGVuc1t0LmhhdmUrK109bDtlbHNle2lmKDE2PT09bCl7Zm9yKHA9YysyO0I8cDspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fWlmKG8+Pj49YyxCLT1jLDA9PT10LmhhdmUpe0EubXNnPVxcXCJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0XFxcIix0Lm1vZGU9MzA7YnJlYWt9RD10LmxlbnNbdC5oYXZlLTFdLEU9MysoMyZvKSxvPj4+PTIsQi09Mn1lbHNlIGlmKDE3PT09bCl7Zm9yKHA9YyszO0I8cDspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fUItPWMsRD0wLEU9MysoNyYobz4+Pj1jKSksbz4+Pj0zLEItPTN9ZWxzZXtmb3IocD1jKzc7QjxwOyl7aWYoMD09PW4pYnJlYWsgQTtuLS0sbys9aVtJKytdPDxCLEIrPTh9Qi09YyxEPTAsRT0xMSsoMTI3JihvPj4+PWMpKSxvPj4+PTcsQi09N31pZih0LmhhdmUrRT50Lm5sZW4rdC5uZGlzdCl7QS5tc2c9XFxcImludmFsaWQgYml0IGxlbmd0aCByZXBlYXRcXFwiLHQubW9kZT0zMDticmVha31mb3IoO0UtLTspdC5sZW5zW3QuaGF2ZSsrXT1EfX1pZigzMD09PXQubW9kZSlicmVhaztpZigwPT09dC5sZW5zWzI1Nl0pe0EubXNnPVxcXCJpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2tcXFwiLHQubW9kZT0zMDticmVha31pZih0LmxlbmJpdHM9OSxrPXtiaXRzOnQubGVuYml0c30seT1yQSgxLHQubGVucywwLHQubmxlbix0LmxlbmNvZGUsMCx0LndvcmssayksdC5sZW5iaXRzPWsuYml0cyx5KXtBLm1zZz1cXFwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0XFxcIix0Lm1vZGU9MzA7YnJlYWt9aWYodC5kaXN0Yml0cz02LHQuZGlzdGNvZGU9dC5kaXN0ZHluLGs9e2JpdHM6dC5kaXN0Yml0c30seT1yQSgyLHQubGVucyx0Lm5sZW4sdC5uZGlzdCx0LmRpc3Rjb2RlLDAsdC53b3JrLGspLHQuZGlzdGJpdHM9ay5iaXRzLHkpe0EubXNnPVxcXCJpbnZhbGlkIGRpc3RhbmNlcyBzZXRcXFwiLHQubW9kZT0zMDticmVha31pZih0Lm1vZGU9MjAsZT09PW5BKWJyZWFrIEE7Y2FzZSAyMDp0Lm1vZGU9MjE7Y2FzZSAyMTppZihuPj02JiZhPj0yNTgpe0EubmV4dF9vdXQ9ZyxBLmF2YWlsX291dD1hLEEubmV4dF9pbj1JLEEuYXZhaWxfaW49bix0LmhvbGQ9byx0LmJpdHM9QiwkKEEsUSksZz1BLm5leHRfb3V0LHI9QS5vdXRwdXQsYT1BLmF2YWlsX291dCxJPUEubmV4dF9pbixpPUEuaW5wdXQsbj1BLmF2YWlsX2luLG89dC5ob2xkLEI9dC5iaXRzLDEyPT09dC5tb2RlJiYodC5iYWNrPS0xKTticmVha31mb3IodC5iYWNrPTA7aD0obT10LmxlbmNvZGVbbyYoMTw8dC5sZW5iaXRzKS0xXSk+Pj4xNiYyNTUsbD02NTUzNSZtLCEoKGM9bT4+PjI0KTw9Qik7KXtpZigwPT09bilicmVhayBBO24tLSxvKz1pW0krK108PEIsQis9OH1pZihoJiYwPT0oMjQwJmgpKXtmb3IodT1jLHc9aCxkPWw7aD0obT10LmxlbmNvZGVbZCsoKG8mKDE8PHUrdyktMSk+PnUpXSk+Pj4xNiYyNTUsbD02NTUzNSZtLCEodSsoYz1tPj4+MjQpPD1CKTspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fW8+Pj49dSxCLT11LHQuYmFjays9dX1pZihvPj4+PWMsQi09Yyx0LmJhY2srPWMsdC5sZW5ndGg9bCwwPT09aCl7dC5tb2RlPTI2O2JyZWFrfWlmKDMyJmgpe3QuYmFjaz0tMSx0Lm1vZGU9MTI7YnJlYWt9aWYoNjQmaCl7QS5tc2c9XFxcImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZVxcXCIsdC5tb2RlPTMwO2JyZWFrfXQuZXh0cmE9MTUmaCx0Lm1vZGU9MjI7Y2FzZSAyMjppZih0LmV4dHJhKXtmb3IocD10LmV4dHJhO0I8cDspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fXQubGVuZ3RoKz1vJigxPDx0LmV4dHJhKS0xLG8+Pj49dC5leHRyYSxCLT10LmV4dHJhLHQuYmFjays9dC5leHRyYX10Lndhcz10Lmxlbmd0aCx0Lm1vZGU9MjM7Y2FzZSAyMzpmb3IoO2g9KG09dC5kaXN0Y29kZVtvJigxPDx0LmRpc3RiaXRzKS0xXSk+Pj4xNiYyNTUsbD02NTUzNSZtLCEoKGM9bT4+PjI0KTw9Qik7KXtpZigwPT09bilicmVhayBBO24tLSxvKz1pW0krK108PEIsQis9OH1pZigwPT0oMjQwJmgpKXtmb3IodT1jLHc9aCxkPWw7aD0obT10LmRpc3Rjb2RlW2QrKChvJigxPDx1K3cpLTEpPj51KV0pPj4+MTYmMjU1LGw9NjU1MzUmbSwhKHUrKGM9bT4+PjI0KTw9Qik7KXtpZigwPT09bilicmVhayBBO24tLSxvKz1pW0krK108PEIsQis9OH1vPj4+PXUsQi09dSx0LmJhY2srPXV9aWYobz4+Pj1jLEItPWMsdC5iYWNrKz1jLDY0Jmgpe0EubXNnPVxcXCJpbnZhbGlkIGRpc3RhbmNlIGNvZGVcXFwiLHQubW9kZT0zMDticmVha310Lm9mZnNldD1sLHQuZXh0cmE9MTUmaCx0Lm1vZGU9MjQ7Y2FzZSAyNDppZih0LmV4dHJhKXtmb3IocD10LmV4dHJhO0I8cDspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fXQub2Zmc2V0Kz1vJigxPDx0LmV4dHJhKS0xLG8+Pj49dC5leHRyYSxCLT10LmV4dHJhLHQuYmFjays9dC5leHRyYX1pZih0Lm9mZnNldD50LmRtYXgpe0EubXNnPVxcXCJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFja1xcXCIsdC5tb2RlPTMwO2JyZWFrfXQubW9kZT0yNTtjYXNlIDI1OmlmKDA9PT1hKWJyZWFrIEE7aWYoRT1RLWEsdC5vZmZzZXQ+RSl7aWYoKEU9dC5vZmZzZXQtRSk+dC53aGF2ZSYmdC5zYW5lKXtBLm1zZz1cXFwiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2tcXFwiLHQubW9kZT0zMDticmVha31FPnQud25leHQ/KEUtPXQud25leHQscz10LndzaXplLUUpOnM9dC53bmV4dC1FLEU+dC5sZW5ndGgmJihFPXQubGVuZ3RoKSxmPXQud2luZG93fWVsc2UgZj1yLHM9Zy10Lm9mZnNldCxFPXQubGVuZ3RoO0U+YSYmKEU9YSksYS09RSx0Lmxlbmd0aC09RTtkb3tyW2crK109ZltzKytdfXdoaWxlKC0tRSk7MD09PXQubGVuZ3RoJiYodC5tb2RlPTIxKTticmVhaztjYXNlIDI2OmlmKDA9PT1hKWJyZWFrIEE7cltnKytdPXQubGVuZ3RoLGEtLSx0Lm1vZGU9MjE7YnJlYWs7Y2FzZSAyNzppZih0LndyYXApe2Zvcig7QjwzMjspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG98PWlbSSsrXTw8QixCKz04fWlmKFEtPWEsQS50b3RhbF9vdXQrPVEsdC50b3RhbCs9USxRJiYoQS5hZGxlcj10LmNoZWNrPXQuZmxhZ3M/WSh0LmNoZWNrLHIsUSxnLVEpOkoodC5jaGVjayxyLFEsZy1RKSksUT1hLCh0LmZsYWdzP286Y0EobykpIT09dC5jaGVjayl7QS5tc2c9XFxcImluY29ycmVjdCBkYXRhIGNoZWNrXFxcIix0Lm1vZGU9MzA7YnJlYWt9bz0wLEI9MH10Lm1vZGU9Mjg7Y2FzZSAyODppZih0LndyYXAmJnQuZmxhZ3Mpe2Zvcig7QjwzMjspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fWlmKG8hPT0oNDI5NDk2NzI5NSZ0LnRvdGFsKSl7QS5tc2c9XFxcImluY29ycmVjdCBsZW5ndGggY2hlY2tcXFwiLHQubW9kZT0zMDticmVha31vPTAsQj0wfXQubW9kZT0yOTtjYXNlIDI5Onk9b0E7YnJlYWsgQTtjYXNlIDMwOnk9UUE7YnJlYWsgQTtjYXNlIDMxOnJldHVybiBFQTtkZWZhdWx0OnJldHVybiBDQX1yZXR1cm4gQS5uZXh0X291dD1nLEEuYXZhaWxfb3V0PWEsQS5uZXh0X2luPUksQS5hdmFpbF9pbj1uLHQuaG9sZD1vLHQuYml0cz1CLCh0LndzaXplfHxRIT09QS5hdmFpbF9vdXQmJnQubW9kZTwzMCYmKHQubW9kZTwyN3x8ZSE9PUlBKSkmJm1BKEEsQS5vdXRwdXQsQS5uZXh0X291dCxRLUEuYXZhaWxfb3V0KSxDLT1BLmF2YWlsX2luLFEtPUEuYXZhaWxfb3V0LEEudG90YWxfaW4rPUMsQS50b3RhbF9vdXQrPVEsdC50b3RhbCs9USx0LndyYXAmJlEmJihBLmFkbGVyPXQuY2hlY2s9dC5mbGFncz9ZKHQuY2hlY2sscixRLEEubmV4dF9vdXQtUSk6Sih0LmNoZWNrLHIsUSxBLm5leHRfb3V0LVEpKSxBLmRhdGFfdHlwZT10LmJpdHMrKHQubGFzdD82NDowKSsoMTI9PT10Lm1vZGU/MTI4OjApKygyMD09PXQubW9kZXx8MTU9PT10Lm1vZGU/MjU2OjApLCgwPT09QyYmMD09PVF8fGU9PT1JQSkmJnk9PT1hQSYmKHk9c0EpLHl9LGluZmxhdGVFbmQ6ZnVuY3Rpb24oQSl7aWYoIUF8fCFBLnN0YXRlKXJldHVybiBDQTt2YXIgZT1BLnN0YXRlO3JldHVybiBlLndpbmRvdyYmKGUud2luZG93PW51bGwpLEEuc3RhdGU9bnVsbCxhQX0saW5mbGF0ZUdldEhlYWRlcjpmdW5jdGlvbihBLGUpe2lmKCFBfHwhQS5zdGF0ZSlyZXR1cm4gQ0E7dmFyIHQ9QS5zdGF0ZTtyZXR1cm4gMD09KDImdC53cmFwKT9DQToodC5oZWFkPWUsZS5kb25lPSExLGFBKX0saW5mbGF0ZVNldERpY3Rpb25hcnk6ZnVuY3Rpb24oQSxlKXt2YXIgdCxpPWUubGVuZ3RoO3JldHVybiBBJiZBLnN0YXRlPzAhPT0odD1BLnN0YXRlKS53cmFwJiYxMSE9PXQubW9kZT9DQToxMT09PXQubW9kZSYmSigxLGUsaSwwKSE9PXQuY2hlY2s/UUE6bUEoQSxlLGksaSk/KHQubW9kZT0zMSxFQSk6KHQuaGF2ZWRpY3Q9MSxhQSk6Q0F9LGluZmxhdGVJbmZvOlxcXCJwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpXFxcIn07dmFyIEZBPWZ1bmN0aW9uKCl7dGhpcy50ZXh0PTAsdGhpcy50aW1lPTAsdGhpcy54ZmxhZ3M9MCx0aGlzLm9zPTAsdGhpcy5leHRyYT1udWxsLHRoaXMuZXh0cmFfbGVuPTAsdGhpcy5uYW1lPVxcXCJcXFwiLHRoaXMuY29tbWVudD1cXFwiXFxcIix0aGlzLmhjcmM9MCx0aGlzLmRvbmU9ITF9LFNBPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsdkE9SC5aX05PX0ZMVVNILFJBPUguWl9GSU5JU0gsVUE9SC5aX09LLExBPUguWl9TVFJFQU1fRU5ELGJBPUguWl9ORUVEX0RJQ1QsTUE9SC5aX1NUUkVBTV9FUlJPUixOQT1ILlpfREFUQV9FUlJPUix4QT1ILlpfTUVNX0VSUk9SO2Z1bmN0aW9uIEpBKEEpe3RoaXMub3B0aW9ucz1QKHtjaHVua1NpemU6NjU1MzYsd2luZG93Qml0czoxNSx0bzpcXFwiXFxcIn0sQXx8e30pO3ZhciBlPXRoaXMub3B0aW9ucztlLnJhdyYmZS53aW5kb3dCaXRzPj0wJiZlLndpbmRvd0JpdHM8MTYmJihlLndpbmRvd0JpdHM9LWUud2luZG93Qml0cywwPT09ZS53aW5kb3dCaXRzJiYoZS53aW5kb3dCaXRzPS0xNSkpLCEoZS53aW5kb3dCaXRzPj0wJiZlLndpbmRvd0JpdHM8MTYpfHxBJiZBLndpbmRvd0JpdHN8fChlLndpbmRvd0JpdHMrPTMyKSxlLndpbmRvd0JpdHM+MTUmJmUud2luZG93Qml0czw0OCYmMD09KDE1JmUud2luZG93Qml0cykmJihlLndpbmRvd0JpdHN8PTE1KSx0aGlzLmVycj0wLHRoaXMubXNnPVxcXCJcXFwiLHRoaXMuZW5kZWQ9ITEsdGhpcy5jaHVua3M9W10sdGhpcy5zdHJtPW5ldyB6LHRoaXMuc3RybS5hdmFpbF9vdXQ9MDt2YXIgdD1HQS5pbmZsYXRlSW5pdDIodGhpcy5zdHJtLGUud2luZG93Qml0cyk7aWYodCE9PVVBKXRocm93IG5ldyBFcnJvcihLW3RdKTtpZih0aGlzLmhlYWRlcj1uZXcgRkEsR0EuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sdGhpcy5oZWFkZXIpLGUuZGljdGlvbmFyeSYmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgZS5kaWN0aW9uYXJ5P2UuZGljdGlvbmFyeT1aKGUuZGljdGlvbmFyeSk6XFxcIltvYmplY3QgQXJyYXlCdWZmZXJdXFxcIj09PVNBLmNhbGwoZS5kaWN0aW9uYXJ5KSYmKGUuZGljdGlvbmFyeT1uZXcgVWludDhBcnJheShlLmRpY3Rpb25hcnkpKSxlLnJhdyYmKHQ9R0EuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLGUuZGljdGlvbmFyeSkpIT09VUEpKXRocm93IG5ldyBFcnJvcihLW3RdKX1mdW5jdGlvbiBxQShBLGUpe3ZhciB0PW5ldyBKQShlKTtpZih0LnB1c2goQSksdC5lcnIpdGhyb3cgdC5tc2d8fEtbdC5lcnJdO3JldHVybiB0LnJlc3VsdH1KQS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihBLGUpe3ZhciB0LGkscixJPXRoaXMuc3RybSxnPXRoaXMub3B0aW9ucy5jaHVua1NpemUsbj10aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtpZih0aGlzLmVuZGVkKXJldHVybiExO2ZvcihpPWU9PT1+fmU/ZTohMD09PWU/UkE6dkEsXFxcIltvYmplY3QgQXJyYXlCdWZmZXJdXFxcIj09PVNBLmNhbGwoQSk/SS5pbnB1dD1uZXcgVWludDhBcnJheShBKTpJLmlucHV0PUEsSS5uZXh0X2luPTAsSS5hdmFpbF9pbj1JLmlucHV0Lmxlbmd0aDs7KXtmb3IoMD09PUkuYXZhaWxfb3V0JiYoSS5vdXRwdXQ9bmV3IFVpbnQ4QXJyYXkoZyksSS5uZXh0X291dD0wLEkuYXZhaWxfb3V0PWcpLCh0PUdBLmluZmxhdGUoSSxpKSk9PT1iQSYmbiYmKCh0PUdBLmluZmxhdGVTZXREaWN0aW9uYXJ5KEksbikpPT09VUE/dD1HQS5pbmZsYXRlKEksaSk6dD09PU5BJiYodD1iQSkpO0kuYXZhaWxfaW4+MCYmdD09PUxBJiZJLnN0YXRlLndyYXA+MCYmMCE9PUFbSS5uZXh0X2luXTspR0EuaW5mbGF0ZVJlc2V0KEkpLHQ9R0EuaW5mbGF0ZShJLGkpO3N3aXRjaCh0KXtjYXNlIE1BOmNhc2UgTkE6Y2FzZSBiQTpjYXNlIHhBOnJldHVybiB0aGlzLm9uRW5kKHQpLHRoaXMuZW5kZWQ9ITAsITF9aWYocj1JLmF2YWlsX291dCxJLm5leHRfb3V0JiYoMD09PUkuYXZhaWxfb3V0fHx0PT09TEEpKWlmKFxcXCJzdHJpbmdcXFwiPT09dGhpcy5vcHRpb25zLnRvKXt2YXIgYT1XKEkub3V0cHV0LEkubmV4dF9vdXQpLG89SS5uZXh0X291dC1hLEI9aihJLm91dHB1dCxhKTtJLm5leHRfb3V0PW8sSS5hdmFpbF9vdXQ9Zy1vLG8mJkkub3V0cHV0LnNldChJLm91dHB1dC5zdWJhcnJheShhLGErbyksMCksdGhpcy5vbkRhdGEoQil9ZWxzZSB0aGlzLm9uRGF0YShJLm91dHB1dC5sZW5ndGg9PT1JLm5leHRfb3V0P0kub3V0cHV0Okkub3V0cHV0LnN1YmFycmF5KDAsSS5uZXh0X291dCkpO2lmKHQhPT1VQXx8MCE9PXIpe2lmKHQ9PT1MQSlyZXR1cm4gdD1HQS5pbmZsYXRlRW5kKHRoaXMuc3RybSksdGhpcy5vbkVuZCh0KSx0aGlzLmVuZGVkPSEwLCEwO2lmKDA9PT1JLmF2YWlsX2luKWJyZWFrfX1yZXR1cm4hMH0sSkEucHJvdG90eXBlLm9uRGF0YT1mdW5jdGlvbihBKXt0aGlzLmNodW5rcy5wdXNoKEEpfSxKQS5wcm90b3R5cGUub25FbmQ9ZnVuY3Rpb24oQSl7QT09PVVBJiYoXFxcInN0cmluZ1xcXCI9PT10aGlzLm9wdGlvbnMudG8/dGhpcy5yZXN1bHQ9dGhpcy5jaHVua3Muam9pbihcXFwiXFxcIik6dGhpcy5yZXN1bHQ9VCh0aGlzLmNodW5rcykpLHRoaXMuY2h1bmtzPVtdLHRoaXMuZXJyPUEsdGhpcy5tc2c9dGhpcy5zdHJtLm1zZ307dmFyIFlBPXtJbmZsYXRlOkpBLGluZmxhdGU6cUEsaW5mbGF0ZVJhdzpmdW5jdGlvbihBLGUpe3JldHVybihlPWV8fHt9KS5yYXc9ITAscUEoQSxlKX0sdW5nemlwOnFBLGNvbnN0YW50czpIfS5pbmZsYXRlO2Z1bmN0aW9uIEtBKEEpe3ZhciBlPWZ1bmN0aW9uKCl7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3QpcmV0dXJuITE7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZihcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKEEpe3JldHVybiExfX0oKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdCxpPWMoQSk7aWYoZSl7dmFyIHI9Yyh0aGlzKS5jb25zdHJ1Y3Rvcjt0PVJlZmxlY3QuY29uc3RydWN0KGksYXJndW1lbnRzLHIpfWVsc2UgdD1pLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gZih0aGlzLHQpfX12YXIgSEE9ZnVuY3Rpb24oQSl7cyh0LHcpO3ZhciBlPUtBKHQpO2Z1bmN0aW9uIHQoKXtyZXR1cm4gQih0aGlzLHQpLGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBRKHQsW3trZXk6XFxcImRlY29kZUJsb2NrXFxcIix2YWx1ZTpmdW5jdGlvbihBKXtyZXR1cm4gWUEobmV3IFVpbnQ4QXJyYXkoQSkpLmJ1ZmZlcn19XSksdH0oKSxPQT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxkZWZhdWx0OkhBfSk7ZnVuY3Rpb24gUEEoQSl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goQSl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciB0LGk9YyhBKTtpZihlKXt2YXIgcj1jKHRoaXMpLmNvbnN0cnVjdG9yO3Q9UmVmbGVjdC5jb25zdHJ1Y3QoaSxhcmd1bWVudHMscil9ZWxzZSB0PWkuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBmKHRoaXMsdCl9fXZhciBUQSxWQT1mdW5jdGlvbihBKXtzKHQsdyk7dmFyIGU9UEEodCk7ZnVuY3Rpb24gdCgpe3JldHVybiBCKHRoaXMsdCksZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIFEodCxbe2tleTpcXFwiZGVjb2RlQmxvY2tcXFwiLHZhbHVlOmZ1bmN0aW9uKEEpe2Zvcih2YXIgZT1uZXcgRGF0YVZpZXcoQSksdD1bXSxpPTA7aTxBLmJ5dGVMZW5ndGg7KytpKXt2YXIgcj1lLmdldEludDgoaSk7aWYocjwwKXt2YXIgST1lLmdldFVpbnQ4KGkrMSk7cj0tcjtmb3IodmFyIGc9MDtnPD1yOysrZyl0LnB1c2goSSk7aSs9MX1lbHNle2Zvcih2YXIgbj0wO248PXI7KytuKXQucHVzaChlLmdldFVpbnQ4KGkrbisxKSk7aSs9cisxfX1yZXR1cm4gbmV3IFVpbnQ4QXJyYXkodCkuYnVmZmVyfX1dKSx0fSgpLF9BPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGRlZmF1bHQ6VkF9KSxYQT17ZXhwb3J0czp7fX07VEE9WEEsXFxuLyogQ29weXJpZ2h0IDIwMTUtMjAyMSBFc3JpLiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXFxcIkxpY2Vuc2VcXFwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wIEBwcmVzZXJ2ZSAqL1xcbmZ1bmN0aW9uKCl7dmFyIEEsZSx0LGkscixJLGcsbixhLG8sQixDLFEsRSxzLGYsYz0oQT17ZGVmYXVsdE5vRGF0YVZhbHVlOi0zNDAyNzk5OTM4NzkwMTQ4NGUyMixkZWNvZGU6ZnVuY3Rpb24oSSxnKXt2YXIgbj0oZz1nfHx7fSkuZW5jb2RlZE1hc2tEYXRhfHxudWxsPT09Zy5lbmNvZGVkTWFza0RhdGEsYT1yKEksZy5pbnB1dE9mZnNldHx8MCxuKSxvPW51bGwhPT1nLm5vRGF0YVZhbHVlP2cubm9EYXRhVmFsdWU6QS5kZWZhdWx0Tm9EYXRhVmFsdWUsQj1lKGEsZy5waXhlbFR5cGV8fEZsb2F0MzJBcnJheSxnLmVuY29kZWRNYXNrRGF0YSxvLGcucmV0dXJuTWFzayksQz17d2lkdGg6YS53aWR0aCxoZWlnaHQ6YS5oZWlnaHQscGl4ZWxEYXRhOkIucmVzdWx0UGl4ZWxzLG1pblZhbHVlOkIubWluVmFsdWUsbWF4VmFsdWU6YS5waXhlbHMubWF4VmFsdWUsbm9EYXRhVmFsdWU6b307cmV0dXJuIEIucmVzdWx0TWFzayYmKEMubWFza0RhdGE9Qi5yZXN1bHRNYXNrKSxnLnJldHVybkVuY29kZWRNYXNrJiZhLm1hc2smJihDLmVuY29kZWRNYXNrRGF0YT1hLm1hc2suYml0c2V0P2EubWFzay5iaXRzZXQ6bnVsbCksZy5yZXR1cm5GaWxlSW5mbyYmKEMuZmlsZUluZm89dChhKSxnLmNvbXB1dGVVc2VkQml0RGVwdGhzJiYoQy5maWxlSW5mby5iaXREZXB0aHM9aShhKSkpLEN9fSxlPWZ1bmN0aW9uKEEsZSx0LGkscil7dmFyIGcsbixhLG89MCxCPUEucGl4ZWxzLm51bUJsb2Nrc1gsQz1BLnBpeGVscy5udW1CbG9ja3NZLFE9TWF0aC5mbG9vcihBLndpZHRoL0IpLEU9TWF0aC5mbG9vcihBLmhlaWdodC9DKSxzPTIqQS5tYXhaRXJyb3IsZj1OdW1iZXIuTUFYX1ZBTFVFO3Q9dHx8KEEubWFzaz9BLm1hc2suYml0c2V0Om51bGwpLG49bmV3IGUoQS53aWR0aCpBLmhlaWdodCksciYmdCYmKGE9bmV3IFVpbnQ4QXJyYXkoQS53aWR0aCpBLmhlaWdodCkpO2Zvcih2YXIgYyxoLGw9bmV3IEZsb2F0MzJBcnJheShRKkUpLHU9MDt1PD1DO3UrKyl7dmFyIHc9dSE9PUM/RTpBLmhlaWdodCVDO2lmKDAhPT13KWZvcih2YXIgZD0wO2Q8PUI7ZCsrKXt2YXIgRD1kIT09Qj9ROkEud2lkdGglQjtpZigwIT09RCl7dmFyIHksayxwLG0sRz11KkEud2lkdGgqRStkKlEsRj1BLndpZHRoLUQsUz1BLnBpeGVscy5ibG9ja3Nbb107aWYoUy5lbmNvZGluZzwyPygwPT09Uy5lbmNvZGluZz95PVMucmF3RGF0YTooSShTLnN0dWZmZWREYXRhLFMuYml0c1BlclBpeGVsLFMubnVtVmFsaWRQaXhlbHMsUy5vZmZzZXQscyxsLEEucGl4ZWxzLm1heFZhbHVlKSx5PWwpLGs9MCk6cD0yPT09Uy5lbmNvZGluZz8wOlMub2Zmc2V0LHQpZm9yKGg9MDtoPHc7aCsrKXtmb3IoNyZHJiYobT10W0c+PjNdLG08PD03JkcpLGM9MDtjPEQ7YysrKTcmR3x8KG09dFtHPj4zXSksMTI4Jm0/KGEmJihhW0ddPTEpLGY9Zj4oZz1TLmVuY29kaW5nPDI/eVtrKytdOnApP2c6ZixuW0crK109Zyk6KGEmJihhW0ddPTApLG5bRysrXT1pKSxtPDw9MTtHKz1GfWVsc2UgaWYoUy5lbmNvZGluZzwyKWZvcihoPTA7aDx3O2grKyl7Zm9yKGM9MDtjPEQ7YysrKWY9Zj4oZz15W2srK10pP2c6ZixuW0crK109ZztHKz1GfWVsc2UgZm9yKGY9Zj5wP3A6ZixoPTA7aDx3O2grKyl7Zm9yKGM9MDtjPEQ7YysrKW5bRysrXT1wO0crPUZ9aWYoMT09PVMuZW5jb2RpbmcmJmshPT1TLm51bVZhbGlkUGl4ZWxzKXRocm93XFxcIkJsb2NrIGFuZCBNYXNrIGRvIG5vdCBtYXRjaFxcXCI7bysrfX19cmV0dXJue3Jlc3VsdFBpeGVsczpuLHJlc3VsdE1hc2s6YSxtaW5WYWx1ZTpmfX0sdD1mdW5jdGlvbihBKXtyZXR1cm57ZmlsZUlkZW50aWZpZXJTdHJpbmc6QS5maWxlSWRlbnRpZmllclN0cmluZyxmaWxlVmVyc2lvbjpBLmZpbGVWZXJzaW9uLGltYWdlVHlwZTpBLmltYWdlVHlwZSxoZWlnaHQ6QS5oZWlnaHQsd2lkdGg6QS53aWR0aCxtYXhaRXJyb3I6QS5tYXhaRXJyb3IsZW9mT2Zmc2V0OkEuZW9mT2Zmc2V0LG1hc2s6QS5tYXNrP3tudW1CbG9ja3NYOkEubWFzay5udW1CbG9ja3NYLG51bUJsb2Nrc1k6QS5tYXNrLm51bUJsb2Nrc1ksbnVtQnl0ZXM6QS5tYXNrLm51bUJ5dGVzLG1heFZhbHVlOkEubWFzay5tYXhWYWx1ZX06bnVsbCxwaXhlbHM6e251bUJsb2Nrc1g6QS5waXhlbHMubnVtQmxvY2tzWCxudW1CbG9ja3NZOkEucGl4ZWxzLm51bUJsb2Nrc1ksbnVtQnl0ZXM6QS5waXhlbHMubnVtQnl0ZXMsbWF4VmFsdWU6QS5waXhlbHMubWF4VmFsdWUsbm9EYXRhVmFsdWU6QS5ub0RhdGFWYWx1ZX19fSxpPWZ1bmN0aW9uKEEpe2Zvcih2YXIgZT1BLnBpeGVscy5udW1CbG9ja3NYKkEucGl4ZWxzLm51bUJsb2Nrc1ksdD17fSxpPTA7aTxlO2krKyl7dmFyIHI9QS5waXhlbHMuYmxvY2tzW2ldOzA9PT1yLmVuY29kaW5nP3QuZmxvYXQzMj0hMDoxPT09ci5lbmNvZGluZz90W3IuYml0c1BlclBpeGVsXT0hMDp0WzBdPSEwfXJldHVybiBPYmplY3Qua2V5cyh0KX0scj1mdW5jdGlvbihBLGUsdCl7dmFyIGk9e30scj1uZXcgVWludDhBcnJheShBLGUsMTApO2lmKGkuZmlsZUlkZW50aWZpZXJTdHJpbmc9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLHIpLFxcXCJDbnRaSW1hZ2VcXFwiIT09aS5maWxlSWRlbnRpZmllclN0cmluZy50cmltKCkpdGhyb3dcXFwiVW5leHBlY3RlZCBmaWxlIGlkZW50aWZpZXIgc3RyaW5nOiBcXFwiK2kuZmlsZUlkZW50aWZpZXJTdHJpbmc7ZSs9MTA7dmFyIEk9bmV3IERhdGFWaWV3KEEsZSwyNCk7aWYoaS5maWxlVmVyc2lvbj1JLmdldEludDMyKDAsITApLGkuaW1hZ2VUeXBlPUkuZ2V0SW50MzIoNCwhMCksaS5oZWlnaHQ9SS5nZXRVaW50MzIoOCwhMCksaS53aWR0aD1JLmdldFVpbnQzMigxMiwhMCksaS5tYXhaRXJyb3I9SS5nZXRGbG9hdDY0KDE2LCEwKSxlKz0yNCwhdClpZihJPW5ldyBEYXRhVmlldyhBLGUsMTYpLGkubWFzaz17fSxpLm1hc2subnVtQmxvY2tzWT1JLmdldFVpbnQzMigwLCEwKSxpLm1hc2subnVtQmxvY2tzWD1JLmdldFVpbnQzMig0LCEwKSxpLm1hc2subnVtQnl0ZXM9SS5nZXRVaW50MzIoOCwhMCksaS5tYXNrLm1heFZhbHVlPUkuZ2V0RmxvYXQzMigxMiwhMCksZSs9MTYsaS5tYXNrLm51bUJ5dGVzPjApe3ZhciBnPW5ldyBVaW50OEFycmF5KE1hdGguY2VpbChpLndpZHRoKmkuaGVpZ2h0LzgpKSxuPShJPW5ldyBEYXRhVmlldyhBLGUsaS5tYXNrLm51bUJ5dGVzKSkuZ2V0SW50MTYoMCwhMCksYT0yLG89MDtkb3tpZihuPjApZm9yKDtuLS07KWdbbysrXT1JLmdldFVpbnQ4KGErKyk7ZWxzZXt2YXIgQj1JLmdldFVpbnQ4KGErKyk7Zm9yKG49LW47bi0tOylnW28rK109Qn1uPUkuZ2V0SW50MTYoYSwhMCksYSs9Mn13aGlsZShhPGkubWFzay5udW1CeXRlcyk7aWYoLTMyNzY4IT09bnx8bzxnLmxlbmd0aCl0aHJvd1xcXCJVbmV4cGVjdGVkIGVuZCBvZiBtYXNrIFJMRSBlbmNvZGluZ1xcXCI7aS5tYXNrLmJpdHNldD1nLGUrPWkubWFzay5udW1CeXRlc31lbHNlIDA9PShpLm1hc2subnVtQnl0ZXN8aS5tYXNrLm51bUJsb2Nrc1l8aS5tYXNrLm1heFZhbHVlKSYmKGkubWFzay5iaXRzZXQ9bmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGkud2lkdGgqaS5oZWlnaHQvOCkpKTtJPW5ldyBEYXRhVmlldyhBLGUsMTYpLGkucGl4ZWxzPXt9LGkucGl4ZWxzLm51bUJsb2Nrc1k9SS5nZXRVaW50MzIoMCwhMCksaS5waXhlbHMubnVtQmxvY2tzWD1JLmdldFVpbnQzMig0LCEwKSxpLnBpeGVscy5udW1CeXRlcz1JLmdldFVpbnQzMig4LCEwKSxpLnBpeGVscy5tYXhWYWx1ZT1JLmdldEZsb2F0MzIoMTIsITApLGUrPTE2O3ZhciBDPWkucGl4ZWxzLm51bUJsb2Nrc1gsUT1pLnBpeGVscy5udW1CbG9ja3NZLEU9QysoaS53aWR0aCVDPjA/MTowKSxzPVErKGkuaGVpZ2h0JVE+MD8xOjApO2kucGl4ZWxzLmJsb2Nrcz1uZXcgQXJyYXkoRSpzKTtmb3IodmFyIGY9MCxjPTA7YzxzO2MrKylmb3IodmFyIGg9MDtoPEU7aCsrKXt2YXIgbD0wLHU9QS5ieXRlTGVuZ3RoLWU7ST1uZXcgRGF0YVZpZXcoQSxlLE1hdGgubWluKDEwLHUpKTt2YXIgdz17fTtpLnBpeGVscy5ibG9ja3NbZisrXT13O3ZhciBkPUkuZ2V0VWludDgoMCk7aWYobCsrLHcuZW5jb2Rpbmc9NjMmZCx3LmVuY29kaW5nPjMpdGhyb3dcXFwiSW52YWxpZCBibG9jayBlbmNvZGluZyAoXFxcIit3LmVuY29kaW5nK1xcXCIpXFxcIjtpZigyIT09dy5lbmNvZGluZyl7aWYoMCE9PWQmJjIhPT1kKXtpZihkPj49Nix3Lm9mZnNldFR5cGU9ZCwyPT09ZCl3Lm9mZnNldD1JLmdldEludDgoMSksbCsrO2Vsc2UgaWYoMT09PWQpdy5vZmZzZXQ9SS5nZXRJbnQxNigxLCEwKSxsKz0yO2Vsc2V7aWYoMCE9PWQpdGhyb3dcXFwiSW52YWxpZCBibG9jayBvZmZzZXQgdHlwZVxcXCI7dy5vZmZzZXQ9SS5nZXRGbG9hdDMyKDEsITApLGwrPTR9aWYoMT09PXcuZW5jb2RpbmcpaWYoZD1JLmdldFVpbnQ4KGwpLGwrKyx3LmJpdHNQZXJQaXhlbD02MyZkLGQ+Pj02LHcubnVtVmFsaWRQaXhlbHNUeXBlPWQsMj09PWQpdy5udW1WYWxpZFBpeGVscz1JLmdldFVpbnQ4KGwpLGwrKztlbHNlIGlmKDE9PT1kKXcubnVtVmFsaWRQaXhlbHM9SS5nZXRVaW50MTYobCwhMCksbCs9MjtlbHNle2lmKDAhPT1kKXRocm93XFxcIkludmFsaWQgdmFsaWQgcGl4ZWwgY291bnQgdHlwZVxcXCI7dy5udW1WYWxpZFBpeGVscz1JLmdldFVpbnQzMihsLCEwKSxsKz00fX12YXIgRDtpZihlKz1sLDMhPT13LmVuY29kaW5nKWlmKDA9PT13LmVuY29kaW5nKXt2YXIgeT0oaS5waXhlbHMubnVtQnl0ZXMtMSkvNDtpZih5IT09TWF0aC5mbG9vcih5KSl0aHJvd1xcXCJ1bmNvbXByZXNzZWQgYmxvY2sgaGFzIGludmFsaWQgbGVuZ3RoXFxcIjtEPW5ldyBBcnJheUJ1ZmZlcig0KnkpLG5ldyBVaW50OEFycmF5KEQpLnNldChuZXcgVWludDhBcnJheShBLGUsNCp5KSk7dmFyIGs9bmV3IEZsb2F0MzJBcnJheShEKTt3LnJhd0RhdGE9ayxlKz00Knl9ZWxzZSBpZigxPT09dy5lbmNvZGluZyl7dmFyIHA9TWF0aC5jZWlsKHcubnVtVmFsaWRQaXhlbHMqdy5iaXRzUGVyUGl4ZWwvOCksbT1NYXRoLmNlaWwocC80KTtEPW5ldyBBcnJheUJ1ZmZlcig0Km0pLG5ldyBVaW50OEFycmF5KEQpLnNldChuZXcgVWludDhBcnJheShBLGUscCkpLHcuc3R1ZmZlZERhdGE9bmV3IFVpbnQzMkFycmF5KEQpLGUrPXB9fWVsc2UgZSsrfXJldHVybiBpLmVvZk9mZnNldD1lLGl9LEk9ZnVuY3Rpb24oQSxlLHQsaSxyLEksZyl7dmFyIG4sYSxvLEI9KDE8PGUpLTEsQz0wLFE9MCxFPU1hdGguY2VpbCgoZy1pKS9yKSxzPTQqQS5sZW5ndGgtTWF0aC5jZWlsKGUqdC84KTtmb3IoQVtBLmxlbmd0aC0xXTw8PTgqcyxuPTA7bjx0O24rKyl7aWYoMD09PVEmJihvPUFbQysrXSxRPTMyKSxRPj1lKWE9bz4+PlEtZSZCLFEtPWU7ZWxzZXt2YXIgZj1lLVE7YT0obyZCKTw8ZiZCLGErPShvPUFbQysrXSk+Pj4oUT0zMi1mKX1JW25dPWE8RT9pK2EqcjpnfXJldHVybiBJfSxBKSxoPShnPWZ1bmN0aW9uKEEsZSx0LGkscixJLGcsbil7dmFyIGEsbyxCLEMsUSxFPSgxPDx0KS0xLHM9MCxmPTAsYz00KkEubGVuZ3RoLU1hdGguY2VpbCh0KmkvOCk7aWYoQVtBLmxlbmd0aC0xXTw8PTgqYyxyKWZvcihhPTA7YTxpO2ErKykwPT09ZiYmKEI9QVtzKytdLGY9MzIpLGY+PXQ/KG89Qj4+PmYtdCZFLGYtPXQpOihvPShCJkUpPDwoQz10LWYpJkUsbys9KEI9QVtzKytdKT4+PihmPTMyLUMpKSxlW2FdPXJbb107ZWxzZSBmb3IoUT1NYXRoLmNlaWwoKG4tSSkvZyksYT0wO2E8aTthKyspMD09PWYmJihCPUFbcysrXSxmPTMyKSxmPj10PyhvPUI+Pj5mLXQmRSxmLT10KToobz0oQiZFKTw8KEM9dC1mKSZFLG8rPShCPUFbcysrXSk+Pj4oZj0zMi1DKSksZVthXT1vPFE/SStvKmc6bn0sbj1mdW5jdGlvbihBLGUsdCxpLHIsSSl7dmFyIGcsbj0oMTw8ZSktMSxhPTAsbz0wLEI9MCxDPTAsUT0wLEU9W10scz00KkEubGVuZ3RoLU1hdGguY2VpbChlKnQvOCk7QVtBLmxlbmd0aC0xXTw8PTgqczt2YXIgZj1NYXRoLmNlaWwoKEktaSkvcik7Zm9yKG89MDtvPHQ7bysrKTA9PT1DJiYoZz1BW2ErK10sQz0zMiksQz49ZT8oUT1nPj4+Qy1lJm4sQy09ZSk6KFE9KGcmbik8PChCPWUtQykmbixRKz0oZz1BW2ErK10pPj4+KEM9MzItQikpLEVbb109UTxmP2krUSpyOkk7cmV0dXJuIEUudW5zaGlmdChpKSxFfSxhPWZ1bmN0aW9uKEEsZSx0LGkscixJLGcsbil7dmFyIGEsbyxCLEMsUT0oMTw8dCktMSxFPTAscz0wLGY9MDtpZihyKWZvcihhPTA7YTxpO2ErKykwPT09cyYmKEI9QVtFKytdLHM9MzIsZj0wKSxzPj10PyhvPUI+Pj5mJlEscy09dCxmKz10KToobz1CPj4+ZiZRLHM9MzItKEM9dC1zKSxvfD0oKEI9QVtFKytdKSYoMTw8QyktMSk8PHQtQyxmPUMpLGVbYV09cltvXTtlbHNle3ZhciBjPU1hdGguY2VpbCgobi1JKS9nKTtmb3IoYT0wO2E8aTthKyspMD09PXMmJihCPUFbRSsrXSxzPTMyLGY9MCkscz49dD8obz1CPj4+ZiZRLHMtPXQsZis9dCk6KG89Qj4+PmYmUSxzPTMyLShDPXQtcyksb3w9KChCPUFbRSsrXSkmKDE8PEMpLTEpPDx0LUMsZj1DKSxlW2FdPW88Yz9JK28qZzpufXJldHVybiBlfSxvPWZ1bmN0aW9uKEEsZSx0LGkscixJKXt2YXIgZyxuPSgxPDxlKS0xLGE9MCxvPTAsQj0wLEM9MCxRPTAsRT0wLHM9W10sZj1NYXRoLmNlaWwoKEktaSkvcik7Zm9yKG89MDtvPHQ7bysrKTA9PT1DJiYoZz1BW2ErK10sQz0zMixFPTApLEM+PWU/KFE9Zz4+PkUmbixDLT1lLEUrPWUpOihRPWc+Pj5FJm4sQz0zMi0oQj1lLUMpLFF8PSgoZz1BW2ErK10pJigxPDxCKS0xKTw8ZS1CLEU9Qiksc1tvXT1RPGY/aStRKnI6STtyZXR1cm4gcy51bnNoaWZ0KGkpLHN9LEI9ZnVuY3Rpb24oQSxlLHQsaSl7dmFyIHIsSSxnLG4sYT0oMTw8dCktMSxvPTAsQj0wLEM9NCpBLmxlbmd0aC1NYXRoLmNlaWwodCppLzgpO2ZvcihBW0EubGVuZ3RoLTFdPDw9OCpDLHI9MDtyPGk7cisrKTA9PT1CJiYoZz1BW28rK10sQj0zMiksQj49dD8oST1nPj4+Qi10JmEsQi09dCk6KEk9KGcmYSk8PChuPXQtQikmYSxJKz0oZz1BW28rK10pPj4+KEI9MzItbikpLGVbcl09STtyZXR1cm4gZX0sQz1mdW5jdGlvbihBLGUsdCxpKXt2YXIgcixJLGcsbixhPSgxPDx0KS0xLG89MCxCPTAsQz0wO2ZvcihyPTA7cjxpO3IrKykwPT09QiYmKGc9QVtvKytdLEI9MzIsQz0wKSxCPj10PyhJPWc+Pj5DJmEsQi09dCxDKz10KTooST1nPj4+QyZhLEI9MzItKG49dC1CKSxJfD0oKGc9QVtvKytdKSYoMTw8biktMSk8PHQtbixDPW4pLGVbcl09STtyZXR1cm4gZX0sUT17SFVGRk1BTl9MVVRfQklUU19NQVg6MTIsY29tcHV0ZUNoZWNrc3VtRmxldGNoZXIzMjpmdW5jdGlvbihBKXtmb3IodmFyIGU9NjU1MzUsdD02NTUzNSxpPUEubGVuZ3RoLHI9TWF0aC5mbG9vcihpLzIpLEk9MDtyOyl7dmFyIGc9cj49MzU5PzM1OTpyO3ItPWc7ZG97ZSs9QVtJKytdPDw4LHQrPWUrPUFbSSsrXX13aGlsZSgtLWcpO2U9KDY1NTM1JmUpKyhlPj4+MTYpLHQ9KDY1NTM1JnQpKyh0Pj4+MTYpfXJldHVybiAxJmkmJih0Kz1lKz1BW0ldPDw4KSwoKHQ9KDY1NTM1JnQpKyh0Pj4+MTYpKTw8MTZ8KGU9KDY1NTM1JmUpKyhlPj4+MTYpKSk+Pj4wfSxyZWFkSGVhZGVySW5mbzpmdW5jdGlvbihBLGUpe3ZhciB0PWUucHRyLGk9bmV3IFVpbnQ4QXJyYXkoQSx0LDYpLHI9e307aWYoci5maWxlSWRlbnRpZmllclN0cmluZz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsaSksMCE9PXIuZmlsZUlkZW50aWZpZXJTdHJpbmcubGFzdEluZGV4T2YoXFxcIkxlcmMyXFxcIiwwKSl0aHJvd1xcXCJVbmV4cGVjdGVkIGZpbGUgaWRlbnRpZmllciBzdHJpbmcgKGV4cGVjdCBMZXJjMiApOiBcXFwiK3IuZmlsZUlkZW50aWZpZXJTdHJpbmc7dCs9Njt2YXIgSSxnPW5ldyBEYXRhVmlldyhBLHQsOCksbj1nLmdldEludDMyKDAsITApO2lmKHIuZmlsZVZlcnNpb249bix0Kz00LG4+PTMmJihyLmNoZWNrc3VtPWcuZ2V0VWludDMyKDQsITApLHQrPTQpLGc9bmV3IERhdGFWaWV3KEEsdCwxMiksci5oZWlnaHQ9Zy5nZXRVaW50MzIoMCwhMCksci53aWR0aD1nLmdldFVpbnQzMig0LCEwKSx0Kz04LG4+PTQ/KHIubnVtRGltcz1nLmdldFVpbnQzMig4LCEwKSx0Kz00KTpyLm51bURpbXM9MSxnPW5ldyBEYXRhVmlldyhBLHQsNDApLHIubnVtVmFsaWRQaXhlbD1nLmdldFVpbnQzMigwLCEwKSxyLm1pY3JvQmxvY2tTaXplPWcuZ2V0SW50MzIoNCwhMCksci5ibG9iU2l6ZT1nLmdldEludDMyKDgsITApLHIuaW1hZ2VUeXBlPWcuZ2V0SW50MzIoMTIsITApLHIubWF4WkVycm9yPWcuZ2V0RmxvYXQ2NCgxNiwhMCksci56TWluPWcuZ2V0RmxvYXQ2NCgyNCwhMCksci56TWF4PWcuZ2V0RmxvYXQ2NCgzMiwhMCksdCs9NDAsZS5oZWFkZXJJbmZvPXIsZS5wdHI9dCxuPj0zJiYoST1uPj00PzUyOjQ4LHRoaXMuY29tcHV0ZUNoZWNrc3VtRmxldGNoZXIzMihuZXcgVWludDhBcnJheShBLHQtSSxyLmJsb2JTaXplLTE0KSkhPT1yLmNoZWNrc3VtKSl0aHJvd1xcXCJDaGVja3N1bSBmYWlsZWQuXFxcIjtyZXR1cm4hMH0sY2hlY2tNaW5NYXhSYW5nZXM6ZnVuY3Rpb24oQSxlKXt2YXIgdD1lLmhlYWRlckluZm8saT10aGlzLmdldERhdGFUeXBlQXJyYXkodC5pbWFnZVR5cGUpLHI9dC5udW1EaW1zKnRoaXMuZ2V0RGF0YVR5cGVTaXplKHQuaW1hZ2VUeXBlKSxJPXRoaXMucmVhZFN1YkFycmF5KEEsZS5wdHIsaSxyKSxnPXRoaXMucmVhZFN1YkFycmF5KEEsZS5wdHIrcixpLHIpO2UucHRyKz0yKnI7dmFyIG4sYT0hMDtmb3Iobj0wO248dC5udW1EaW1zO24rKylpZihJW25dIT09Z1tuXSl7YT0hMTticmVha31yZXR1cm4gdC5taW5WYWx1ZXM9SSx0Lm1heFZhbHVlcz1nLGF9LHJlYWRTdWJBcnJheTpmdW5jdGlvbihBLGUsdCxpKXt2YXIgcjtpZih0PT09VWludDhBcnJheSlyPW5ldyBVaW50OEFycmF5KEEsZSxpKTtlbHNle3ZhciBJPW5ldyBBcnJheUJ1ZmZlcihpKTtuZXcgVWludDhBcnJheShJKS5zZXQobmV3IFVpbnQ4QXJyYXkoQSxlLGkpKSxyPW5ldyB0KEkpfXJldHVybiByfSxyZWFkTWFzazpmdW5jdGlvbihBLGUpe3ZhciB0LGkscj1lLnB0cixJPWUuaGVhZGVySW5mbyxnPUkud2lkdGgqSS5oZWlnaHQsbj1JLm51bVZhbGlkUGl4ZWwsYT1uZXcgRGF0YVZpZXcoQSxyLDQpLG89e307aWYoby5udW1CeXRlcz1hLmdldFVpbnQzMigwLCEwKSxyKz00LCgwPT09bnx8Zz09PW4pJiYwIT09by5udW1CeXRlcyl0aHJvd1xcXCJpbnZhbGlkIG1hc2tcXFwiO2lmKDA9PT1uKXQ9bmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGcvOCkpLG8uYml0c2V0PXQsaT1uZXcgVWludDhBcnJheShnKSxlLnBpeGVscy5yZXN1bHRNYXNrPWkscis9by5udW1CeXRlcztlbHNlIGlmKG8ubnVtQnl0ZXM+MCl7dD1uZXcgVWludDhBcnJheShNYXRoLmNlaWwoZy84KSk7dmFyIEI9KGE9bmV3IERhdGFWaWV3KEEscixvLm51bUJ5dGVzKSkuZ2V0SW50MTYoMCwhMCksQz0yLFE9MCxFPTA7ZG97aWYoQj4wKWZvcig7Qi0tOyl0W1ErK109YS5nZXRVaW50OChDKyspO2Vsc2UgZm9yKEU9YS5nZXRVaW50OChDKyspLEI9LUI7Qi0tOyl0W1ErK109RTtCPWEuZ2V0SW50MTYoQywhMCksQys9Mn13aGlsZShDPG8ubnVtQnl0ZXMpO2lmKC0zMjc2OCE9PUJ8fFE8dC5sZW5ndGgpdGhyb3dcXFwiVW5leHBlY3RlZCBlbmQgb2YgbWFzayBSTEUgZW5jb2RpbmdcXFwiO2k9bmV3IFVpbnQ4QXJyYXkoZyk7dmFyIHM9MCxmPTA7Zm9yKGY9MDtmPGc7ZisrKTcmZj8ocz10W2Y+PjNdLHM8PD03JmYpOnM9dFtmPj4zXSwxMjgmcyYmKGlbZl09MSk7ZS5waXhlbHMucmVzdWx0TWFzaz1pLG8uYml0c2V0PXQscis9by5udW1CeXRlc31yZXR1cm4gZS5wdHI9cixlLm1hc2s9bywhMH0scmVhZERhdGFPbmVTd2VlcDpmdW5jdGlvbihBLGUsdCxpKXt2YXIgcixJPWUucHRyLGc9ZS5oZWFkZXJJbmZvLG49Zy5udW1EaW1zLGE9Zy53aWR0aCpnLmhlaWdodCxvPWcuaW1hZ2VUeXBlLEI9Zy5udW1WYWxpZFBpeGVsKlEuZ2V0RGF0YVR5cGVTaXplKG8pKm4sQz1lLnBpeGVscy5yZXN1bHRNYXNrO2lmKHQ9PT1VaW50OEFycmF5KXI9bmV3IFVpbnQ4QXJyYXkoQSxJLEIpO2Vsc2V7dmFyIEU9bmV3IEFycmF5QnVmZmVyKEIpO25ldyBVaW50OEFycmF5KEUpLnNldChuZXcgVWludDhBcnJheShBLEksQikpLHI9bmV3IHQoRSl9aWYoci5sZW5ndGg9PT1hKm4pZS5waXhlbHMucmVzdWx0UGl4ZWxzPWk/US5zd2FwRGltZW5zaW9uT3JkZXIocixhLG4sdCwhMCk6cjtlbHNle2UucGl4ZWxzLnJlc3VsdFBpeGVscz1uZXcgdChhKm4pO3ZhciBzPTAsZj0wLGM9MCxoPTA7aWYobj4xKXtpZihpKXtmb3IoZj0wO2Y8YTtmKyspaWYoQ1tmXSlmb3IoaD1mLGM9MDtjPG47YysrLGgrPWEpZS5waXhlbHMucmVzdWx0UGl4ZWxzW2hdPXJbcysrXX1lbHNlIGZvcihmPTA7ZjxhO2YrKylpZihDW2ZdKWZvcihoPWYqbixjPTA7YzxuO2MrKyllLnBpeGVscy5yZXN1bHRQaXhlbHNbaCtjXT1yW3MrK119ZWxzZSBmb3IoZj0wO2Y8YTtmKyspQ1tmXSYmKGUucGl4ZWxzLnJlc3VsdFBpeGVsc1tmXT1yW3MrK10pfXJldHVybiBJKz1CLGUucHRyPUksITB9LHJlYWRIdWZmbWFuVHJlZTpmdW5jdGlvbihBLGUpe3ZhciB0PXRoaXMuSFVGRk1BTl9MVVRfQklUU19NQVgsaT1uZXcgRGF0YVZpZXcoQSxlLnB0ciwxNik7aWYoZS5wdHIrPTE2LGkuZ2V0SW50MzIoMCwhMCk8Mil0aHJvd1xcXCJ1bnN1cHBvcnRlZCBIdWZmbWFuIHZlcnNpb25cXFwiO3ZhciByPWkuZ2V0SW50MzIoNCwhMCksST1pLmdldEludDMyKDgsITApLGc9aS5nZXRJbnQzMigxMiwhMCk7aWYoST49ZylyZXR1cm4hMTt2YXIgbj1uZXcgVWludDMyQXJyYXkoZy1JKTtRLmRlY29kZUJpdHMoQSxlLG4pO3ZhciBhLG8sQixDLHM9W107Zm9yKGE9STthPGc7YSsrKXNbbz1hLShhPHI/MDpyKV09e2ZpcnN0Om5bYS1JXSxzZWNvbmQ6bnVsbH07dmFyIGY9QS5ieXRlTGVuZ3RoLWUucHRyLGM9TWF0aC5jZWlsKGYvNCksaD1uZXcgQXJyYXlCdWZmZXIoNCpjKTtuZXcgVWludDhBcnJheShoKS5zZXQobmV3IFVpbnQ4QXJyYXkoQSxlLnB0cixmKSk7dmFyIGwsdT1uZXcgVWludDMyQXJyYXkoaCksdz0wLGQ9MDtmb3IobD11WzBdLGE9STthPGc7YSsrKShDPXNbbz1hLShhPHI/MDpyKV0uZmlyc3QpPjAmJihzW29dLnNlY29uZD1sPDx3Pj4+MzItQywzMi13Pj1DPzMyPT09KHcrPUMpJiYodz0wLGw9dVsrK2RdKToodys9Qy0zMixsPXVbKytkXSxzW29dLnNlY29uZHw9bD4+PjMyLXcpKTt2YXIgRD0wLHk9MCxrPW5ldyBFO2ZvcihhPTA7YTxzLmxlbmd0aDthKyspdm9pZCAwIT09c1thXSYmKEQ9TWF0aC5tYXgoRCxzW2FdLmZpcnN0KSk7eT1EPj10P3Q6RDt2YXIgcCxtLEcsRixTLHY9W107Zm9yKGE9STthPGc7YSsrKWlmKChDPXNbbz1hLShhPHI/MDpyKV0uZmlyc3QpPjApaWYocD1bQyxvXSxDPD15KWZvcihtPXNbb10uc2Vjb25kPDx5LUMsRz0xPDx5LUMsQj0wO0I8RztCKyspdlttfEJdPXA7ZWxzZSBmb3IobT1zW29dLnNlY29uZCxTPWssRj1DLTE7Rj49MDtGLS0pbT4+PkYmMT8oUy5yaWdodHx8KFMucmlnaHQ9bmV3IEUpLFM9Uy5yaWdodCk6KFMubGVmdHx8KFMubGVmdD1uZXcgRSksUz1TLmxlZnQpLDAhPT1GfHxTLnZhbHx8KFMudmFsPXBbMV0pO3JldHVybntkZWNvZGVMdXQ6dixudW1CaXRzTFVUUWljazp5LG51bUJpdHNMVVQ6RCx0cmVlOmssc3R1ZmZlZERhdGE6dSxzcmNQdHI6ZCxiaXRQb3M6d319LHJlYWRIdWZmbWFuOmZ1bmN0aW9uKEEsZSx0LGkpe3ZhciByLEksZyxuLGEsbyxCLEMsRSxzPWUuaGVhZGVySW5mby5udW1EaW1zLGY9ZS5oZWFkZXJJbmZvLmhlaWdodCxjPWUuaGVhZGVySW5mby53aWR0aCxoPWMqZixsPXRoaXMucmVhZEh1ZmZtYW5UcmVlKEEsZSksdT1sLmRlY29kZUx1dCx3PWwudHJlZSxkPWwuc3R1ZmZlZERhdGEsRD1sLnNyY1B0cix5PWwuYml0UG9zLGs9bC5udW1CaXRzTFVUUWljayxwPWwubnVtQml0c0xVVCxtPTA9PT1lLmhlYWRlckluZm8uaW1hZ2VUeXBlPzEyODowLEc9ZS5waXhlbHMucmVzdWx0TWFzayxGPTA7eT4wJiYoRCsrLHk9MCk7dmFyIFMsdj1kW0RdLFI9MT09PWUuZW5jb2RlTW9kZSxVPW5ldyB0KGgqcyksTD1VO2lmKHM8Mnx8Uil7Zm9yKFM9MDtTPHM7UysrKWlmKHM+MSYmKEw9bmV3IHQoVS5idWZmZXIsaCpTLGgpLEY9MCksZS5oZWFkZXJJbmZvLm51bVZhbGlkUGl4ZWw9PT1jKmYpZm9yKEM9MCxvPTA7bzxmO28rKylmb3IoQj0wO0I8YztCKyssQysrKXtpZihJPTAsYT1uPXY8PHk+Pj4zMi1rLDMyLXk8ayYmKGE9bnw9ZFtEKzFdPj4+NjQteS1rKSx1W2FdKUk9dVthXVsxXSx5Kz11W2FdWzBdO2Vsc2UgZm9yKGE9bj12PDx5Pj4+MzItcCwzMi15PHAmJihhPW58PWRbRCsxXT4+PjY0LXktcCkscj13LEU9MDtFPHA7RSsrKWlmKCEocj1uPj4+cC1FLTEmMT9yLnJpZ2h0OnIubGVmdCkubGVmdCYmIXIucmlnaHQpe0k9ci52YWwseT15K0UrMTticmVha315Pj0zMiYmKHktPTMyLHY9ZFsrK0RdKSxnPUktbSxSPyhnKz1CPjA/RjpvPjA/TFtDLWNdOkYsZyY9MjU1LExbQ109ZyxGPWcpOkxbQ109Z31lbHNlIGZvcihDPTAsbz0wO288ZjtvKyspZm9yKEI9MDtCPGM7QisrLEMrKylpZihHW0NdKXtpZihJPTAsYT1uPXY8PHk+Pj4zMi1rLDMyLXk8ayYmKGE9bnw9ZFtEKzFdPj4+NjQteS1rKSx1W2FdKUk9dVthXVsxXSx5Kz11W2FdWzBdO2Vsc2UgZm9yKGE9bj12PDx5Pj4+MzItcCwzMi15PHAmJihhPW58PWRbRCsxXT4+PjY0LXktcCkscj13LEU9MDtFPHA7RSsrKWlmKCEocj1uPj4+cC1FLTEmMT9yLnJpZ2h0OnIubGVmdCkubGVmdCYmIXIucmlnaHQpe0k9ci52YWwseT15K0UrMTticmVha315Pj0zMiYmKHktPTMyLHY9ZFsrK0RdKSxnPUktbSxSPyhCPjAmJkdbQy0xXT9nKz1GOm8+MCYmR1tDLWNdP2crPUxbQy1jXTpnKz1GLGcmPTI1NSxMW0NdPWcsRj1nKTpMW0NdPWd9fWVsc2UgZm9yKEM9MCxvPTA7bzxmO28rKylmb3IoQj0wO0I8YztCKyspaWYoQz1vKmMrQiwhR3x8R1tDXSlmb3IoUz0wO1M8cztTKyssQys9aCl7aWYoST0wLGE9bj12PDx5Pj4+MzItaywzMi15PGsmJihhPW58PWRbRCsxXT4+PjY0LXktayksdVthXSlJPXVbYV1bMV0seSs9dVthXVswXTtlbHNlIGZvcihhPW49djw8eT4+PjMyLXAsMzIteTxwJiYoYT1ufD1kW0QrMV0+Pj42NC15LXApLHI9dyxFPTA7RTxwO0UrKylpZighKHI9bj4+PnAtRS0xJjE/ci5yaWdodDpyLmxlZnQpLmxlZnQmJiFyLnJpZ2h0KXtJPXIudmFsLHk9eStFKzE7YnJlYWt9eT49MzImJih5LT0zMix2PWRbKytEXSksZz1JLW0sTFtDXT1nfWUucHRyPWUucHRyKzQqKEQrMSkrKHk+MD80OjApLGUucGl4ZWxzLnJlc3VsdFBpeGVscz1VLHM+MSYmIWkmJihlLnBpeGVscy5yZXN1bHRQaXhlbHM9US5zd2FwRGltZW5zaW9uT3JkZXIoVSxoLHMsdCkpfSxkZWNvZGVCaXRzOmZ1bmN0aW9uKEEsZSx0LGkscil7dmFyIEk9ZS5oZWFkZXJJbmZvLFE9SS5maWxlVmVyc2lvbixFPTAscz1BLmJ5dGVMZW5ndGgtZS5wdHI+PTU/NTpBLmJ5dGVMZW5ndGgtZS5wdHIsZj1uZXcgRGF0YVZpZXcoQSxlLnB0cixzKSxjPWYuZ2V0VWludDgoMCk7RSsrO3ZhciBoPWM+PjYsbD0wPT09aD80OjMtaCx1PSgzMiZjKT4wLHc9MzEmYyxkPTA7aWYoMT09PWwpZD1mLmdldFVpbnQ4KEUpLEUrKztlbHNlIGlmKDI9PT1sKWQ9Zi5nZXRVaW50MTYoRSwhMCksRSs9MjtlbHNle2lmKDQhPT1sKXRocm93XFxcIkludmFsaWQgdmFsaWQgcGl4ZWwgY291bnQgdHlwZVxcXCI7ZD1mLmdldFVpbnQzMihFLCEwKSxFKz00fXZhciBELHksayxwLG0sRyxGLFMsdixSPTIqSS5tYXhaRXJyb3IsVT1JLm51bURpbXM+MT9JLm1heFZhbHVlc1tyXTpJLnpNYXg7aWYodSl7Zm9yKGUuY291bnRlci5sdXQrKyxTPWYuZ2V0VWludDgoRSksRSsrLHA9TWF0aC5jZWlsKChTLTEpKncvOCksbT1NYXRoLmNlaWwocC80KSx5PW5ldyBBcnJheUJ1ZmZlcig0Km0pLGs9bmV3IFVpbnQ4QXJyYXkoeSksZS5wdHIrPUUsay5zZXQobmV3IFVpbnQ4QXJyYXkoQSxlLnB0cixwKSksRj1uZXcgVWludDMyQXJyYXkoeSksZS5wdHIrPXAsdj0wO1MtMT4+PnY7KXYrKztwPU1hdGguY2VpbChkKnYvOCksbT1NYXRoLmNlaWwocC80KSx5PW5ldyBBcnJheUJ1ZmZlcig0Km0pLChrPW5ldyBVaW50OEFycmF5KHkpKS5zZXQobmV3IFVpbnQ4QXJyYXkoQSxlLnB0cixwKSksRD1uZXcgVWludDMyQXJyYXkoeSksZS5wdHIrPXAsRz1RPj0zP28oRix3LFMtMSxpLFIsVSk6bihGLHcsUy0xLGksUixVKSxRPj0zP2EoRCx0LHYsZCxHKTpnKEQsdCx2LGQsRyl9ZWxzZSBlLmNvdW50ZXIuYml0c3R1ZmZlcisrLHY9dyxlLnB0cis9RSx2PjAmJihwPU1hdGguY2VpbChkKnYvOCksbT1NYXRoLmNlaWwocC80KSx5PW5ldyBBcnJheUJ1ZmZlcig0Km0pLChrPW5ldyBVaW50OEFycmF5KHkpKS5zZXQobmV3IFVpbnQ4QXJyYXkoQSxlLnB0cixwKSksRD1uZXcgVWludDMyQXJyYXkoeSksZS5wdHIrPXAsUT49Mz9udWxsPT1pP0MoRCx0LHYsZCk6YShELHQsdixkLCExLGksUixVKTpudWxsPT1pP0IoRCx0LHYsZCk6ZyhELHQsdixkLCExLGksUixVKSl9LHJlYWRUaWxlczpmdW5jdGlvbihBLGUsdCxpKXt2YXIgcj1lLmhlYWRlckluZm8sST1yLndpZHRoLGc9ci5oZWlnaHQsbj1JKmcsYT1yLm1pY3JvQmxvY2tTaXplLG89ci5pbWFnZVR5cGUsQj1RLmdldERhdGFUeXBlU2l6ZShvKSxDPU1hdGguY2VpbChJL2EpLEU9TWF0aC5jZWlsKGcvYSk7ZS5waXhlbHMubnVtQmxvY2tzWT1FLGUucGl4ZWxzLm51bUJsb2Nrc1g9QyxlLnBpeGVscy5wdHI9MDt2YXIgcyxmLGMsaCxsLHUsdyxkLEQseSxrPTAscD0wLG09MCxHPTAsRj0wLFM9MCx2PTAsUj0wLFU9MCxMPTAsYj0wLE09MCxOPTAseD0wLEo9MCxxPW5ldyB0KGEqYSksWT1nJWF8fGEsSz1JJWF8fGEsSD1yLm51bURpbXMsTz1lLnBpeGVscy5yZXN1bHRNYXNrLFA9ZS5waXhlbHMucmVzdWx0UGl4ZWxzLFQ9ci5maWxlVmVyc2lvbj49NT8xNDoxNSxWPXIuek1heDtmb3IobT0wO208RTttKyspZm9yKEY9bSE9PUUtMT9hOlksRz0wO0c8QztHKyspZm9yKEw9bSpJKmErRyphLGI9SS0oUz1HIT09Qy0xP2E6SyksZD0wO2Q8SDtkKyspe2lmKEg+MT8oeT1QLEw9bSpJKmErRyphLFA9bmV3IHQoZS5waXhlbHMucmVzdWx0UGl4ZWxzLmJ1ZmZlcixuKmQqQixuKSxWPXIubWF4VmFsdWVzW2RdKTp5PW51bGwsdj1BLmJ5dGVMZW5ndGgtZS5wdHIsZj17fSxKPTAsUj0ocz1uZXcgRGF0YVZpZXcoQSxlLnB0cixNYXRoLm1pbigxMCx2KSkpLmdldFVpbnQ4KDApLEorKyxEPXIuZmlsZVZlcnNpb24+PTU/NCZSOjAsVT1SPj42JjI1NSwoUj4+MiZUKSE9KEcqYT4+MyZUKSl0aHJvd1xcXCJpbnRlZ3JpdHkgaXNzdWVcXFwiO2lmKEQmJjA9PT1kKXRocm93XFxcImludGVncml0eSBpc3N1ZVxcXCI7aWYoKGw9MyZSKT4zKXRocm93IGUucHRyKz1KLFxcXCJJbnZhbGlkIGJsb2NrIGVuY29kaW5nIChcXFwiK2wrXFxcIilcXFwiO2lmKDIhPT1sKWlmKDA9PT1sKXtpZihEKXRocm93XFxcImludGVncml0eSBpc3N1ZVxcXCI7aWYoZS5jb3VudGVyLnVuY29tcHJlc3NlZCsrLGUucHRyKz1KLE09KE09RipTKkIpPChOPUEuYnl0ZUxlbmd0aC1lLnB0cik/TTpOLGM9bmV3IEFycmF5QnVmZmVyKE0lQj09MD9NOk0rQi1NJUIpLG5ldyBVaW50OEFycmF5KGMpLnNldChuZXcgVWludDhBcnJheShBLGUucHRyLE0pKSxoPW5ldyB0KGMpLHg9MCxPKWZvcihrPTA7azxGO2srKyl7Zm9yKHA9MDtwPFM7cCsrKU9bTF0mJihQW0xdPWhbeCsrXSksTCsrO0wrPWJ9ZWxzZSBmb3Ioaz0wO2s8RjtrKyspe2ZvcihwPTA7cDxTO3ArKylQW0wrK109aFt4KytdO0wrPWJ9ZS5wdHIrPXgqQn1lbHNlIGlmKHU9US5nZXREYXRhVHlwZVVzZWQoRCYmbzw2PzQ6byxVKSx3PVEuZ2V0T25lUGl4ZWwoZixKLHUscyksSis9US5nZXREYXRhVHlwZVNpemUodSksMz09PWwpaWYoZS5wdHIrPUosZS5jb3VudGVyLmNvbnN0YW50b2Zmc2V0KyssTylmb3Ioaz0wO2s8RjtrKyspe2ZvcihwPTA7cDxTO3ArKylPW0xdJiYoUFtMXT1EP01hdGgubWluKFYseVtMXSt3KTp3KSxMKys7TCs9Yn1lbHNlIGZvcihrPTA7azxGO2srKyl7Zm9yKHA9MDtwPFM7cCsrKVBbTF09RD9NYXRoLm1pbihWLHlbTF0rdyk6dyxMKys7TCs9Yn1lbHNlIGlmKGUucHRyKz1KLFEuZGVjb2RlQml0cyhBLGUscSx3LGQpLEo9MCxEKWlmKE8pZm9yKGs9MDtrPEY7aysrKXtmb3IocD0wO3A8UztwKyspT1tMXSYmKFBbTF09cVtKKytdK3lbTF0pLEwrKztMKz1ifWVsc2UgZm9yKGs9MDtrPEY7aysrKXtmb3IocD0wO3A8UztwKyspUFtMXT1xW0orK10reVtMXSxMKys7TCs9Yn1lbHNlIGlmKE8pZm9yKGs9MDtrPEY7aysrKXtmb3IocD0wO3A8UztwKyspT1tMXSYmKFBbTF09cVtKKytdKSxMKys7TCs9Yn1lbHNlIGZvcihrPTA7azxGO2srKyl7Zm9yKHA9MDtwPFM7cCsrKVBbTCsrXT1xW0orK107TCs9Yn1lbHNle2lmKEQpaWYoTylmb3Ioaz0wO2s8RjtrKyspZm9yKHA9MDtwPFM7cCsrKU9bTF0mJihQW0xdPXlbTF0pLEwrKztlbHNlIGZvcihrPTA7azxGO2srKylmb3IocD0wO3A8UztwKyspUFtMXT15W0xdLEwrKztlLmNvdW50ZXIuY29uc3RhbnQrKyxlLnB0cis9Sn19SD4xJiYhaSYmKGUucGl4ZWxzLnJlc3VsdFBpeGVscz1RLnN3YXBEaW1lbnNpb25PcmRlcihlLnBpeGVscy5yZXN1bHRQaXhlbHMsbixILHQpKX0sZm9ybWF0RmlsZUluZm86ZnVuY3Rpb24oQSl7cmV0dXJue2ZpbGVJZGVudGlmaWVyU3RyaW5nOkEuaGVhZGVySW5mby5maWxlSWRlbnRpZmllclN0cmluZyxmaWxlVmVyc2lvbjpBLmhlYWRlckluZm8uZmlsZVZlcnNpb24saW1hZ2VUeXBlOkEuaGVhZGVySW5mby5pbWFnZVR5cGUsaGVpZ2h0OkEuaGVhZGVySW5mby5oZWlnaHQsd2lkdGg6QS5oZWFkZXJJbmZvLndpZHRoLG51bVZhbGlkUGl4ZWw6QS5oZWFkZXJJbmZvLm51bVZhbGlkUGl4ZWwsbWljcm9CbG9ja1NpemU6QS5oZWFkZXJJbmZvLm1pY3JvQmxvY2tTaXplLGJsb2JTaXplOkEuaGVhZGVySW5mby5ibG9iU2l6ZSxtYXhaRXJyb3I6QS5oZWFkZXJJbmZvLm1heFpFcnJvcixwaXhlbFR5cGU6US5nZXRQaXhlbFR5cGUoQS5oZWFkZXJJbmZvLmltYWdlVHlwZSksZW9mT2Zmc2V0OkEuZW9mT2Zmc2V0LG1hc2s6QS5tYXNrP3tudW1CeXRlczpBLm1hc2subnVtQnl0ZXN9Om51bGwscGl4ZWxzOntudW1CbG9ja3NYOkEucGl4ZWxzLm51bUJsb2Nrc1gsbnVtQmxvY2tzWTpBLnBpeGVscy5udW1CbG9ja3NZLG1heFZhbHVlOkEuaGVhZGVySW5mby56TWF4LG1pblZhbHVlOkEuaGVhZGVySW5mby56TWluLG5vRGF0YVZhbHVlOkEubm9EYXRhVmFsdWV9fX0sY29uc3RydWN0Q29uc3RhbnRTdXJmYWNlOmZ1bmN0aW9uKEEsZSl7dmFyIHQ9QS5oZWFkZXJJbmZvLnpNYXgsaT1BLmhlYWRlckluZm8uek1pbixyPUEuaGVhZGVySW5mby5tYXhWYWx1ZXMsST1BLmhlYWRlckluZm8ubnVtRGltcyxnPUEuaGVhZGVySW5mby5oZWlnaHQqQS5oZWFkZXJJbmZvLndpZHRoLG49MCxhPTAsbz0wLEI9QS5waXhlbHMucmVzdWx0TWFzayxDPUEucGl4ZWxzLnJlc3VsdFBpeGVscztpZihCKWlmKEk+MSl7aWYoZSlmb3Iobj0wO248STtuKyspZm9yKG89bipnLHQ9cltuXSxhPTA7YTxnO2ErKylCW2FdJiYoQ1tvK2FdPXQpO2Vsc2UgZm9yKGE9MDthPGc7YSsrKWlmKEJbYV0pZm9yKG89YSpJLG49MDtuPEk7bisrKUNbbytJXT1yW25dfWVsc2UgZm9yKGE9MDthPGc7YSsrKUJbYV0mJihDW2FdPXQpO2Vsc2UgaWYoST4xJiZpIT09dClpZihlKWZvcihuPTA7bjxJO24rKylmb3Iobz1uKmcsdD1yW25dLGE9MDthPGc7YSsrKUNbbythXT10O2Vsc2UgZm9yKGE9MDthPGc7YSsrKWZvcihvPWEqSSxuPTA7bjxJO24rKylDW28rbl09cltuXTtlbHNlIGZvcihhPTA7YTxnKkk7YSsrKUNbYV09dH0sZ2V0RGF0YVR5cGVBcnJheTpmdW5jdGlvbihBKXt2YXIgZTtzd2l0Y2goQSl7Y2FzZSAwOmU9SW50OEFycmF5O2JyZWFrO2Nhc2UgMTplPVVpbnQ4QXJyYXk7YnJlYWs7Y2FzZSAyOmU9SW50MTZBcnJheTticmVhaztjYXNlIDM6ZT1VaW50MTZBcnJheTticmVhaztjYXNlIDQ6ZT1JbnQzMkFycmF5O2JyZWFrO2Nhc2UgNTplPVVpbnQzMkFycmF5O2JyZWFrO2Nhc2UgNjpkZWZhdWx0OmU9RmxvYXQzMkFycmF5O2JyZWFrO2Nhc2UgNzplPUZsb2F0NjRBcnJheX1yZXR1cm4gZX0sZ2V0UGl4ZWxUeXBlOmZ1bmN0aW9uKEEpe3ZhciBlO3N3aXRjaChBKXtjYXNlIDA6ZT1cXFwiUzhcXFwiO2JyZWFrO2Nhc2UgMTplPVxcXCJVOFxcXCI7YnJlYWs7Y2FzZSAyOmU9XFxcIlMxNlxcXCI7YnJlYWs7Y2FzZSAzOmU9XFxcIlUxNlxcXCI7YnJlYWs7Y2FzZSA0OmU9XFxcIlMzMlxcXCI7YnJlYWs7Y2FzZSA1OmU9XFxcIlUzMlxcXCI7YnJlYWs7Y2FzZSA2OmRlZmF1bHQ6ZT1cXFwiRjMyXFxcIjticmVhaztjYXNlIDc6ZT1cXFwiRjY0XFxcIn1yZXR1cm4gZX0saXNWYWxpZFBpeGVsVmFsdWU6ZnVuY3Rpb24oQSxlKXtpZihudWxsPT1lKXJldHVybiExO3ZhciB0O3N3aXRjaChBKXtjYXNlIDA6dD1lPj0tMTI4JiZlPD0xMjc7YnJlYWs7Y2FzZSAxOnQ9ZT49MCYmZTw9MjU1O2JyZWFrO2Nhc2UgMjp0PWU+PS0zMjc2OCYmZTw9MzI3Njc7YnJlYWs7Y2FzZSAzOnQ9ZT49MCYmZTw9NjU1MzY7YnJlYWs7Y2FzZSA0OnQ9ZT49LTIxNDc0ODM2NDgmJmU8PTIxNDc0ODM2NDc7YnJlYWs7Y2FzZSA1OnQ9ZT49MCYmZTw9NDI5NDk2NzI5NjticmVhaztjYXNlIDY6dD1lPj0tMzQwMjc5OTkzODc5MDE0ODRlMjImJmU8PTM0MDI3OTk5Mzg3OTAxNDg0ZTIyO2JyZWFrO2Nhc2UgNzp0PWU+PS0xNzk3NjkzMTM0ODYyMzE1N2UyOTImJmU8PTE3OTc2OTMxMzQ4NjIzMTU3ZTI5MjticmVhaztkZWZhdWx0OnQ9ITF9cmV0dXJuIHR9LGdldERhdGFUeXBlU2l6ZTpmdW5jdGlvbihBKXt2YXIgZT0wO3N3aXRjaChBKXtjYXNlIDA6Y2FzZSAxOmU9MTticmVhaztjYXNlIDI6Y2FzZSAzOmU9MjticmVhaztjYXNlIDQ6Y2FzZSA1OmNhc2UgNjplPTQ7YnJlYWs7Y2FzZSA3OmU9ODticmVhaztkZWZhdWx0OmU9QX1yZXR1cm4gZX0sZ2V0RGF0YVR5cGVVc2VkOmZ1bmN0aW9uKEEsZSl7dmFyIHQ9QTtzd2l0Y2goQSl7Y2FzZSAyOmNhc2UgNDp0PUEtZTticmVhaztjYXNlIDM6Y2FzZSA1OnQ9QS0yKmU7YnJlYWs7Y2FzZSA2OnQ9MD09PWU/QToxPT09ZT8yOjE7YnJlYWs7Y2FzZSA3OnQ9MD09PWU/QTpBLTIqZSsxO2JyZWFrO2RlZmF1bHQ6dD1BfXJldHVybiB0fSxnZXRPbmVQaXhlbDpmdW5jdGlvbihBLGUsdCxpKXt2YXIgcj0wO3N3aXRjaCh0KXtjYXNlIDA6cj1pLmdldEludDgoZSk7YnJlYWs7Y2FzZSAxOnI9aS5nZXRVaW50OChlKTticmVhaztjYXNlIDI6cj1pLmdldEludDE2KGUsITApO2JyZWFrO2Nhc2UgMzpyPWkuZ2V0VWludDE2KGUsITApO2JyZWFrO2Nhc2UgNDpyPWkuZ2V0SW50MzIoZSwhMCk7YnJlYWs7Y2FzZSA1OnI9aS5nZXRVSW50MzIoZSwhMCk7YnJlYWs7Y2FzZSA2OnI9aS5nZXRGbG9hdDMyKGUsITApO2JyZWFrO2Nhc2UgNzpyPWkuZ2V0RmxvYXQ2NChlLCEwKTticmVhaztkZWZhdWx0OnRocm93XFxcInRoZSBkZWNvZGVyIGRvZXMgbm90IHVuZGVyc3RhbmQgdGhpcyBwaXhlbCB0eXBlXFxcIn1yZXR1cm4gcn0sc3dhcERpbWVuc2lvbk9yZGVyOmZ1bmN0aW9uKEEsZSx0LGkscil7dmFyIEk9MCxnPTAsbj0wLGE9MCxvPUE7aWYodD4xKWlmKG89bmV3IGkoZSp0KSxyKWZvcihJPTA7STxlO0krKylmb3IoYT1JLG49MDtuPHQ7bisrLGErPWUpb1thXT1BW2crK107ZWxzZSBmb3IoST0wO0k8ZTtJKyspZm9yKGE9SSxuPTA7bjx0O24rKyxhKz1lKW9bZysrXT1BW2FdO3JldHVybiBvfX0sRT1mdW5jdGlvbihBLGUsdCl7dGhpcy52YWw9QSx0aGlzLmxlZnQ9ZSx0aGlzLnJpZ2h0PXR9LHtkZWNvZGU6ZnVuY3Rpb24oQSxlKXt2YXIgdD0oZT1lfHx7fSkubm9EYXRhVmFsdWUsaT0wLHI9e307ci5wdHI9ZS5pbnB1dE9mZnNldHx8MCxyLnBpeGVscz17fSxRLnJlYWRIZWFkZXJJbmZvKEEscik7dmFyIEk9ci5oZWFkZXJJbmZvLGc9SS5maWxlVmVyc2lvbixuPVEuZ2V0RGF0YVR5cGVBcnJheShJLmltYWdlVHlwZSk7aWYoZz41KXRocm93XFxcInVuc3VwcG9ydGVkIGxlcmMgdmVyc2lvbiAyLlxcXCIrZztRLnJlYWRNYXNrKEEsciksSS5udW1WYWxpZFBpeGVsPT09SS53aWR0aCpJLmhlaWdodHx8ci5waXhlbHMucmVzdWx0TWFza3x8KHIucGl4ZWxzLnJlc3VsdE1hc2s9ZS5tYXNrRGF0YSk7dmFyIGE9SS53aWR0aCpJLmhlaWdodDtyLnBpeGVscy5yZXN1bHRQaXhlbHM9bmV3IG4oYSpJLm51bURpbXMpLHIuY291bnRlcj17b25lc3dlZXA6MCx1bmNvbXByZXNzZWQ6MCxsdXQ6MCxiaXRzdHVmZmVyOjAsY29uc3RhbnQ6MCxjb25zdGFudG9mZnNldDowfTt2YXIgbyxCPSFlLnJldHVyblBpeGVsSW50ZXJsZWF2ZWREaW1zO2lmKDAhPT1JLm51bVZhbGlkUGl4ZWwpaWYoSS56TWF4PT09SS56TWluKVEuY29uc3RydWN0Q29uc3RhbnRTdXJmYWNlKHIsQik7ZWxzZSBpZihnPj00JiZRLmNoZWNrTWluTWF4UmFuZ2VzKEEscikpUS5jb25zdHJ1Y3RDb25zdGFudFN1cmZhY2UocixCKTtlbHNle3ZhciBDPW5ldyBEYXRhVmlldyhBLHIucHRyLDIpLEU9Qy5nZXRVaW50OCgwKTtpZihyLnB0cisrLEUpUS5yZWFkRGF0YU9uZVN3ZWVwKEEscixuLEIpO2Vsc2UgaWYoZz4xJiZJLmltYWdlVHlwZTw9MSYmTWF0aC5hYnMoSS5tYXhaRXJyb3ItLjUpPDFlLTUpe3ZhciBzPUMuZ2V0VWludDgoMSk7aWYoci5wdHIrKyxyLmVuY29kZU1vZGU9cyxzPjJ8fGc8NCYmcz4xKXRocm93XFxcIkludmFsaWQgSHVmZm1hbiBmbGFnIFxcXCIrcztzP1EucmVhZEh1ZmZtYW4oQSxyLG4sQik6US5yZWFkVGlsZXMoQSxyLG4sQil9ZWxzZSBRLnJlYWRUaWxlcyhBLHIsbixCKX1yLmVvZk9mZnNldD1yLnB0cixlLmlucHV0T2Zmc2V0PyhvPXIuaGVhZGVySW5mby5ibG9iU2l6ZStlLmlucHV0T2Zmc2V0LXIucHRyLE1hdGguYWJzKG8pPj0xJiYoci5lb2ZPZmZzZXQ9ZS5pbnB1dE9mZnNldCtyLmhlYWRlckluZm8uYmxvYlNpemUpKToobz1yLmhlYWRlckluZm8uYmxvYlNpemUtci5wdHIsTWF0aC5hYnMobyk+PTEmJihyLmVvZk9mZnNldD1yLmhlYWRlckluZm8uYmxvYlNpemUpKTt2YXIgZj17d2lkdGg6SS53aWR0aCxoZWlnaHQ6SS5oZWlnaHQscGl4ZWxEYXRhOnIucGl4ZWxzLnJlc3VsdFBpeGVscyxtaW5WYWx1ZTpJLnpNaW4sbWF4VmFsdWU6SS56TWF4LHZhbGlkUGl4ZWxDb3VudDpJLm51bVZhbGlkUGl4ZWwsZGltQ291bnQ6SS5udW1EaW1zLGRpbVN0YXRzOnttaW5WYWx1ZXM6SS5taW5WYWx1ZXMsbWF4VmFsdWVzOkkubWF4VmFsdWVzfSxtYXNrRGF0YTpyLnBpeGVscy5yZXN1bHRNYXNrfTtpZihyLnBpeGVscy5yZXN1bHRNYXNrJiZRLmlzVmFsaWRQaXhlbFZhbHVlKEkuaW1hZ2VUeXBlLHQpKXt2YXIgYz1yLnBpeGVscy5yZXN1bHRNYXNrO2ZvcihpPTA7aTxhO2krKyljW2ldfHwoZi5waXhlbERhdGFbaV09dCk7Zi5ub0RhdGFWYWx1ZT10fXJldHVybiByLm5vRGF0YVZhbHVlPXQsZS5yZXR1cm5GaWxlSW5mbyYmKGYuZmlsZUluZm89US5mb3JtYXRGaWxlSW5mbyhyKSksZn0sZ2V0QmFuZENvdW50OmZ1bmN0aW9uKEEpe2Zvcih2YXIgZT0wLHQ9MCxpPXtwdHI6MCxwaXhlbHM6e319O3Q8QS5ieXRlTGVuZ3RoLTU4OylRLnJlYWRIZWFkZXJJbmZvKEEsaSksdCs9aS5oZWFkZXJJbmZvLmJsb2JTaXplLGUrKyxpLnB0cj10O3JldHVybiBlfX0pLGw9KHM9bmV3IEFycmF5QnVmZmVyKDQpLGY9bmV3IFVpbnQ4QXJyYXkocyksbmV3IFVpbnQzMkFycmF5KHMpWzBdPTEsMT09PWZbMF0pLHU9e2RlY29kZTpmdW5jdGlvbihBLGUpe2lmKCFsKXRocm93XFxcIkJpZyBlbmRpYW4gc3lzdGVtIGlzIG5vdCBzdXBwb3J0ZWQuXFxcIjt2YXIgdCxpLHI9KGU9ZXx8e30pLmlucHV0T2Zmc2V0fHwwLEk9bmV3IFVpbnQ4QXJyYXkoQSxyLDEwKSxnPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxJKTtpZihcXFwiQ250WkltYWdlXFxcIj09PWcudHJpbSgpKXQ9YyxpPTE7ZWxzZXtpZihcXFwiTGVyYzJcXFwiIT09Zy5zdWJzdHJpbmcoMCw1KSl0aHJvd1xcXCJVbmV4cGVjdGVkIGZpbGUgaWRlbnRpZmllciBzdHJpbmc6IFxcXCIrZzt0PWgsaT0yfWZvcih2YXIgbixhLG8sQixDLFEsRT0wLHM9QS5ieXRlTGVuZ3RoLTEwLGY9W10sdT17d2lkdGg6MCxoZWlnaHQ6MCxwaXhlbHM6W10scGl4ZWxUeXBlOmUucGl4ZWxUeXBlLG1hc2s6bnVsbCxzdGF0aXN0aWNzOltdfSx3PTA7cjxzOyl7dmFyIGQ9dC5kZWNvZGUoQSx7aW5wdXRPZmZzZXQ6cixlbmNvZGVkTWFza0RhdGE6bixtYXNrRGF0YTpvLHJldHVybk1hc2s6MD09PUUscmV0dXJuRW5jb2RlZE1hc2s6MD09PUUscmV0dXJuRmlsZUluZm86ITAscmV0dXJuUGl4ZWxJbnRlcmxlYXZlZERpbXM6ZS5yZXR1cm5QaXhlbEludGVybGVhdmVkRGltcyxwaXhlbFR5cGU6ZS5waXhlbFR5cGV8fG51bGwsbm9EYXRhVmFsdWU6ZS5ub0RhdGFWYWx1ZXx8bnVsbH0pO3I9ZC5maWxlSW5mby5lb2ZPZmZzZXQsbz1kLm1hc2tEYXRhLDA9PT1FJiYobj1kLmVuY29kZWRNYXNrRGF0YSx1LndpZHRoPWQud2lkdGgsdS5oZWlnaHQ9ZC5oZWlnaHQsdS5kaW1Db3VudD1kLmRpbUNvdW50fHwxLHUucGl4ZWxUeXBlPWQucGl4ZWxUeXBlfHxkLmZpbGVJbmZvLnBpeGVsVHlwZSx1Lm1hc2s9byksaT4xJiYobyYmZi5wdXNoKG8pLGQuZmlsZUluZm8ubWFzayYmZC5maWxlSW5mby5tYXNrLm51bUJ5dGVzPjAmJncrKyksRSsrLHUucGl4ZWxzLnB1c2goZC5waXhlbERhdGEpLHUuc3RhdGlzdGljcy5wdXNoKHttaW5WYWx1ZTpkLm1pblZhbHVlLG1heFZhbHVlOmQubWF4VmFsdWUsbm9EYXRhVmFsdWU6ZC5ub0RhdGFWYWx1ZSxkaW1TdGF0czpkLmRpbVN0YXRzfSl9aWYoaT4xJiZ3PjEpe2ZvcihRPXUud2lkdGgqdS5oZWlnaHQsdS5iYW5kTWFza3M9Ziwobz1uZXcgVWludDhBcnJheShRKSkuc2V0KGZbMF0pLEI9MTtCPGYubGVuZ3RoO0IrKylmb3IoYT1mW0JdLEM9MDtDPFE7QysrKW9bQ109b1tDXSZhW0NdO3UubWFza0RhdGE9b31yZXR1cm4gdX19O1RBLmV4cG9ydHM/VEEuZXhwb3J0cz11OnRoaXMuTGVyYz11fSgpO3ZhciBaQSxqQSxXQSx6QT1YQS5leHBvcnRzLCRBPXtlbnY6e2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGg6ZnVuY3Rpb24oQSl7V0E9bmV3IFVpbnQ4QXJyYXkoakEuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKX19fSxBZT1mdW5jdGlvbigpe2Z1bmN0aW9uIEEoKXtCKHRoaXMsQSl9cmV0dXJuIFEoQSxbe2tleTpcXFwiaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gWkF8fChaQT1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGZldGNoP2ZldGNoKFxcXCJkYXRhOmFwcGxpY2F0aW9uL3dhc207YmFzZTY0LFxcXCIrZWUpLnRoZW4oKGZ1bmN0aW9uKEEpe3JldHVybiBBLmFycmF5QnVmZmVyKCl9KSkudGhlbigoZnVuY3Rpb24oQSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKEEsJEEpfSkpLnRoZW4odGhpcy5faW5pdCk6V2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoQnVmZmVyLmZyb20oZWUsXFxcImJhc2U2NFxcXCIpLCRBKS50aGVuKHRoaXMuX2luaXQpKX19LHtrZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbihBKXtqQT1BLmluc3RhbmNlLCRBLmVudi5lbXNjcmlwdGVuX25vdGlmeV9tZW1vcnlfZ3Jvd3RoKDApfX0se2tleTpcXFwiZGVjb2RlXFxcIix2YWx1ZTpmdW5jdGlvbihBKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MDtpZighakEpdGhyb3cgbmV3IEVycm9yKFxcXCJaU1RERGVjb2RlcjogQXdhaXQgLmluaXQoKSBiZWZvcmUgZGVjb2RpbmcuXFxcIik7dmFyIHQ9QS5ieXRlTGVuZ3RoLGk9akEuZXhwb3J0cy5tYWxsb2ModCk7V0Euc2V0KEEsaSksZT1lfHxOdW1iZXIoakEuZXhwb3J0cy5aU1REX2ZpbmREZWNvbXByZXNzZWRTaXplKGksdCkpO3ZhciByPWpBLmV4cG9ydHMubWFsbG9jKGUpLEk9akEuZXhwb3J0cy5aU1REX2RlY29tcHJlc3MocixlLGksdCksZz1XQS5zbGljZShyLHIrSSk7cmV0dXJuIGpBLmV4cG9ydHMuZnJlZShpKSxqQS5leHBvcnRzLmZyZWUociksZ319XSksQX0oKSxlZT1cXFwiQUdGemJRRUFBQUFCcFFFVllBRi9BWDlnQW45L0FHQURmMzkvQVg5Z0JYOS9mMzkvQVg5Z0FYOEFZQUovZndGL1lBUi9mMzkvQVg5Z0EzOS9md0JnQm45L2YzOS9md0YvWUFkL2YzOS9mMzkvQVg5Z0FuOS9BWDVnQW41K0FYNWdBQUJnQlg5L2YzOS9BR0FHZjM5L2YzOS9BR0FJZjM5L2YzOS9mMzhBWUFsL2YzOS9mMzkvZjM4QVlBQUJmMkFJZjM5L2YzOS9mMzhCZjJBTmYzOS9mMzkvZjM5L2YzOS9md0YvWUFGL0FYNENKd0VEWlc1MkgyVnRjMk55YVhCMFpXNWZibTkwYVdaNVgyMWxiVzl5ZVY5bmNtOTNkR2dBQkFOcGFBRUZBQUFGQWdFRkN3QUNBUUFCQWdJRkJRY0FBd0FCRGdzQkFRY0FFaE1IQUFVQkRBUUVBQUFOQndRQ0FnWUNCQWdEQXdNREJnRUFDUWtIQmdJQ0FBWUdBZ1FVQndZR0F3SUdBQU1DQVFnQkJ3VUdDZ29FRVFBRUJBRUlBd2dEQlFnREVBOElBQWNBQkFVQmNBRUNBZ1VFQVFDQUFnWUpBWDhCUWFDZ3dBSUxCMkFIQm0xbGJXOXllUUlBQm0xaGJHeHZZd0FvQkdaeVpXVUFKZ3hhVTFSRVgybHpSWEp5YjNJQWFCbGFVMVJFWDJacGJtUkVaV052YlhCeVpYTnpaV1JUYVhwbEFGUVBXbE5VUkY5a1pXTnZiWEJ5WlhOekFFb0dYM04wWVhKMEFDUUpCd0VBUVFFTEFTUUt1c3NCYUE4QUlBQWdBQ2dDQkNBQmFqWUNCQXNaQUNBQUtBSUFJQUFvQWdSQkgzRjBRUUFnQVd0QkgzRjJDd2dBSUFCQmlIOUxDMzRCQkg5QkF5RUJJQUFvQWdRaUEwRWdUUVJBSUFBb0FnZ2lBU0FBS0FJUVR3UkFJQUFRRFE4TElBQW9BZ3dpQWlBQlJnUkFRUUZCQWlBRFFTQkpHdzhMSUFBZ0FTQUJJQUpySUFOQkEzWWlCQ0FCSUFScklBSkpJZ0ViSWdKcklnUTJBZ2dnQUNBRElBSkJBM1JyTmdJRUlBQWdCQ2dBQURZQ0FBc2dBUXNVQVFGL0lBQWdBUkFDSVFJZ0FDQUJFQUVnQWd2M0FRRUNmeUFDUlFSQUlBQkNBRGNDQUNBQVFRQTJBaEFnQUVJQU53SUlRYmgvRHdzZ0FDQUJOZ0lNSUFBZ0FVRUVhallDRUNBQ1FRUlBCRUFnQUNBQklBSnFJZ0ZCZkdvaUF6WUNDQ0FBSUFNb0FBQTJBZ0FnQVVGL2FpMEFBQ0lCQkVBZ0FFRUlJQUVRRkdzMkFnUWdBZzhMSUFCQkFEWUNCRUYvRHdzZ0FDQUJOZ0lJSUFBZ0FTMEFBQ0lETmdJQUlBSkJmbW9pQkVFQlRRUkFJQVJCQVd0RkJFQWdBQ0FCTFFBQ1FSQjBJQU55SWdNMkFnQUxJQUFnQVMwQUFVRUlkQ0FEYWpZQ0FBc2dBU0FDYWtGL2FpMEFBQ0lCUlFSQUlBQkJBRFlDQkVGc0R3c2dBRUVvSUFFUUZDQUNRUU4wYW1zMkFnUWdBZ3NXQUNBQUlBRXBBQUEzQUFBZ0FDQUJLUUFJTndBSUN5OEJBWDhnQVVFQ2RFR2dIV29vQWdBZ0FDZ0NBRUVnSUFFZ0FDZ0NCR3ByUVI5eGRuRWhBaUFBSUFFUUFTQUNDeUVBSUFGQ3o5YlR2dExIcTlsQ2ZpQUFmRUlmaVVLSGxhK3ZtTGJlbTU1L2Znc2RBUUYvSUFBb0FnZ2dBQ2dDREVZRWZ5QUFLQUlFUVNCR0JVRUFDd3VDQkFFRGZ5QUNRWURBQUU4RVFDQUFJQUVnQWhCbklBQVBDeUFBSUFKcUlRTUNRQ0FBSUFGelFRTnhSUVJBQWtBZ0FrRUJTQVJBSUFBaEFnd0JDeUFBUVFOeFJRUkFJQUFoQWd3QkN5QUFJUUlEUUNBQ0lBRXRBQUE2QUFBZ0FVRUJhaUVCSUFKQkFXb2lBaUFEVHcwQklBSkJBM0VOQUFzTEFrQWdBMEY4Y1NJRVFjQUFTUTBBSUFJZ0JFRkFhaUlGU3cwQUEwQWdBaUFCS0FJQU5nSUFJQUlnQVNnQ0JEWUNCQ0FDSUFFb0FnZzJBZ2dnQWlBQktBSU1OZ0lNSUFJZ0FTZ0NFRFlDRUNBQ0lBRW9BaFEyQWhRZ0FpQUJLQUlZTmdJWUlBSWdBU2dDSERZQ0hDQUNJQUVvQWlBMkFpQWdBaUFCS0FJa05nSWtJQUlnQVNnQ0tEWUNLQ0FDSUFFb0FpdzJBaXdnQWlBQktBSXdOZ0l3SUFJZ0FTZ0NORFlDTkNBQ0lBRW9BamcyQWpnZ0FpQUJLQUk4TmdJOElBRkJRR3NoQVNBQ1FVQnJJZ0lnQlUwTkFBc0xJQUlnQkU4TkFRTkFJQUlnQVNnQ0FEWUNBQ0FCUVFScUlRRWdBa0VFYWlJQ0lBUkpEUUFMREFFTElBTkJCRWtFUUNBQUlRSU1BUXNnQTBGOGFpSUVJQUJKQkVBZ0FDRUNEQUVMSUFBaEFnTkFJQUlnQVMwQUFEb0FBQ0FDSUFFdEFBRTZBQUVnQWlBQkxRQUNPZ0FDSUFJZ0FTMEFBem9BQXlBQlFRUnFJUUVnQWtFRWFpSUNJQVJORFFBTEN5QUNJQU5KQkVBRFFDQUNJQUV0QUFBNkFBQWdBVUVCYWlFQklBSkJBV29pQWlBRFJ3MEFDd3NnQUFzTUFDQUFJQUVwQUFBM0FBQUxRUUVDZnlBQUtBSUlJZ0VnQUNnQ0VFa0VRRUVERHdzZ0FDQUFLQUlFSWdKQkIzRTJBZ1FnQUNBQklBSkJBM1pySWdFMkFnZ2dBQ0FCS0FBQU5nSUFRUUFMREFBZ0FDQUJLQUlBTmdBQUMvY0NBUUovQWtBZ0FDQUJSZzBBQWtBZ0FTQUNhaUFBU3dSQUlBQWdBbW9pQkNBQlN3MEJDeUFBSUFFZ0FoQUxEd3NnQUNBQmMwRURjU0VEQWtBQ1FDQUFJQUZKQkVBZ0F3UkFJQUFoQXd3REN5QUFRUU54UlFSQUlBQWhBd3dDQ3lBQUlRTURRQ0FDUlEwRUlBTWdBUzBBQURvQUFDQUJRUUZxSVFFZ0FrRi9haUVDSUFOQkFXb2lBMEVEY1EwQUN3d0JDd0pBSUFNTkFDQUVRUU54QkVBRFFDQUNSUTBGSUFBZ0FrRi9haUlDYWlJRElBRWdBbW90QUFBNkFBQWdBMEVEY1EwQUN3c2dBa0VEVFEwQUEwQWdBQ0FDUVh4cUlnSnFJQUVnQW1vb0FnQTJBZ0FnQWtFRFN3MEFDd3NnQWtVTkFnTkFJQUFnQWtGL2FpSUNhaUFCSUFKcUxRQUFPZ0FBSUFJTkFBc01BZ3NnQWtFRFRRMEFJQUloQkFOQUlBTWdBU2dDQURZQ0FDQUJRUVJxSVFFZ0EwRUVhaUVESUFSQmZHb2lCRUVEU3cwQUN5QUNRUU54SVFJTElBSkZEUUFEUUNBRElBRXRBQUE2QUFBZ0EwRUJhaUVESUFGQkFXb2hBU0FDUVg5cUlnSU5BQXNMSUFBTDh3SUNBbjhCZmdKQUlBSkZEUUFnQUNBQ2FpSURRWDlxSUFFNkFBQWdBQ0FCT2dBQUlBSkJBMGtOQUNBRFFYNXFJQUU2QUFBZ0FDQUJPZ0FCSUFOQmZXb2dBVG9BQUNBQUlBRTZBQUlnQWtFSFNRMEFJQU5CZkdvZ0FUb0FBQ0FBSUFFNkFBTWdBa0VKU1EwQUlBQkJBQ0FBYTBFRGNTSUVhaUlESUFGQi93RnhRWUdDaEFoc0lnRTJBZ0FnQXlBQ0lBUnJRWHh4SWdScUlnSkJmR29nQVRZQ0FDQUVRUWxKRFFBZ0F5QUJOZ0lJSUFNZ0FUWUNCQ0FDUVhocUlBRTJBZ0FnQWtGMGFpQUJOZ0lBSUFSQkdVa05BQ0FESUFFMkFoZ2dBeUFCTmdJVUlBTWdBVFlDRUNBRElBRTJBZ3dnQWtGd2FpQUJOZ0lBSUFKQmJHb2dBVFlDQUNBQ1FXaHFJQUUyQWdBZ0FrRmthaUFCTmdJQUlBUWdBMEVFY1VFWWNpSUVheUlDUVNCSkRRQWdBYTBpQlVJZ2hpQUZoQ0VGSUFNZ0JHb2hBUU5BSUFFZ0JUY0RHQ0FCSUFVM0F4QWdBU0FGTndNSUlBRWdCVGNEQUNBQlFTQnFJUUVnQWtGZ2FpSUNRUjlMRFFBTEN5QUFDeThCQW44Z0FDZ0NCQ0FBS0FJQVFRSjBhaUlDTFFBQ0lRTWdBQ0FDTHdFQUlBRWdBaTBBQXhBSWFqWUNBQ0FEQ3k4QkFuOGdBQ2dDQkNBQUtBSUFRUUowYWlJQ0xRQUNJUU1nQUNBQ0x3RUFJQUVnQWkwQUF4QUZhallDQUNBREN4OEFJQUFnQVNBQ0tBSUVFQWcyQWdBZ0FSQUVHaUFBSUFKQkNHbzJBZ1FMQ0FBZ0FHZEJIM01MdWdVQkRYOGpBRUVRYXlJS0pBQUNmeUFFUVFOTkJFQWdDa0VBTmdJTUlBcEJER29nQXlBRUVBc2FJQUFnQVNBQ0lBcEJER3BCQkJBVklnQkJiQ0FBRUFNYklBQWdBQ0FFU3hzTUFRc2dBRUVBSUFFb0FnQkJBWFJCQW1vUUVDRU5RVlFnQXlnQUFDSUdRUTl4SWdCQkNrc05BQm9nQWlBQVFRVnFOZ0lBSUFNZ0JHb2lBa0Y4YWlFTUlBSkJlV29oRGlBQ1FYdHFJUkFnQUVFR2FpRUxRUVFoQlNBR1FRUjJJUVJCSUNBQWRDSUFRUUZ5SVFrZ0FTZ0NBQ0VQUVFBaEFpQURJUVlDUUFOQUlBbEJBa2dnQWlBUFMzSkZCRUFnQWlFSEFrQWdDQVJBQTBBZ0JFSC8vd054UWYvL0EwWUVRQ0FIUVJocUlRY2dCaUFRU1FSL0lBWkJBbW9pQmlnQUFDQUZkZ1VnQlVFUWFpRUZJQVJCRUhZTElRUU1BUXNMQTBBZ0JFRURjU0lJUVFOR0JFQWdCVUVDYWlFRklBUkJBblloQkNBSFFRTnFJUWNNQVFzTElBY2dDR29pQnlBUFN3MEVJQVZCQW1vaEJRTkFJQUlnQjBrRVFDQU5JQUpCQVhScVFRQTdBUUFnQWtFQmFpRUNEQUVMQ3lBR0lBNUxRUUFnQmlBRlFRTjFhaUlISUF4TEcwVUVRQ0FIS0FBQUlBVkJCM0VpQlhZaEJBd0NDeUFFUVFKMklRUUxJQVloQndzQ2Z5QUxRWDlxSUFRZ0FFRi9hbkVpQmlBQVFRRjBRWDlxSWdnZ0NXc2lFVWtOQUJvZ0JDQUljU0lFUVFBZ0VTQUVJQUJJRzJzaEJpQUxDeUVJSUEwZ0FrRUJkR29nQmtGL2FpSUVPd0VBSUFsQkFTQUdheUFFSUFaQkFVZ2JheUVKQTBBZ0NTQUFTQVJBSUFCQkFYVWhBQ0FMUVg5cUlRc01BUXNMQW44Z0J5QU9TMEVBSUFjZ0JTQUlhaUlGUVFOMWFpSUdJQXhMRzBVRVFDQUZRUWR4REFFTElBVWdEQ0lHSUFkclFRTjBhd3NoQlNBQ1FRRnFJUUlnQkVVaENDQUdLQUFBSUFWQkgzRjJJUVFNQVFzTFFXd2dDVUVCUnlBRlFTQktjZzBCR2lBQklBSkJmMm8yQWdBZ0JpQUZRUWRxUVFOMWFpQURhd3dCQzBGUUN5RUFJQXBCRUdva0FDQUFDd2tBUVFGQkJTQUFHd3NNQUNBQUlBRW9BQUEyQUFBTHFnTUJDbjhqQUVId0FHc2lDaVFBSUFKQkFXb2hEaUFBUVFocUlRdEJnSUFFSUFWQmYycDBRUkIxSVF4QkFDRUNRUUVoQmtFQklBVjBJZ2xCZjJvaUR5RUlBMEFnQWlBT1JrVUVRQUpBSUFFZ0FrRUJkQ0lOYWk4QkFDSUhRZi8vQTBZRVFDQUxJQWhCQTNScUlBSTJBZ1FnQ0VGL2FpRUlRUUVoQnd3QkN5QUdRUUFnRENBSFFSQjBRUkIxU2hzaEJnc2dDaUFOYWlBSE93RUFJQUpCQVdvaEFnd0JDd3NnQUNBRk5nSUVJQUFnQmpZQ0FDQUpRUU4ySUFsQkFYWnFRUU5xSVF4QkFDRUFRUUFoQmtFQUlRSURRQ0FHSUE1R0JFQURRQUpBSUFBZ0NVWU5BQ0FLSUFzZ0FFRURkR29pQVNnQ0JDSUdRUUYwYWlJQ0lBSXZBUUFpQWtFQmFqc0JBQ0FCSUFVZ0FoQVVheUlJT2dBRElBRWdBaUFJUWY4QmNYUWdDV3M3QVFBZ0FTQUVJQVpCQW5RaUFtb29BZ0E2QUFJZ0FTQUNJQU5xS0FJQU5nSUVJQUJCQVdvaEFBd0JDd3NGSUFFZ0JrRUJkR291QVFBaERVRUFJUWNEUUNBSElBMU9SUVJBSUFzZ0FrRURkR29nQmpZQ0JBTkFJQUlnREdvZ0QzRWlBaUFJU3cwQUN5QUhRUUZxSVFjTUFRc0xJQVpCQVdvaEJnd0JDd3NnQ2tId0FHb2tBQXNqQUVJQUlBRVFDU0FBaFVLSGxhK3ZtTGJlbTU1L2ZrTGozTXFWL003eTlZVi9mQXNRQUNBQVFuNDNBd2dnQUNBQk5nSUFDeVFCQVg4Z0FBUkFJQUVvQWdRaUFnUkFJQUVvQWdnZ0FDQUNFUUVBRHdzZ0FCQW1Dd3NmQUNBQUlBRWdBaThCQUJBSU5nSUFJQUVRQkJvZ0FDQUNRUVJxTmdJRUMwb0JBWDlCb0NBb0FnQWlBU0FBYWlJQVFYOU1CRUJCaUNCQk1EWUNBRUYvRHdzQ1FDQUFQd0JCRUhSTkRRQWdBQkJtRFFCQmlDQkJNRFlDQUVGL0R3dEJvQ0FnQURZQ0FDQUJDOWNCQVFoL1FicC9JUW9DUUNBQ0tBSUVJZ2dnQWlnQ0FDSUphaUlPSUFFZ0FHdExEUUJCYkNFS0lBa2dCQ0FES0FJQUlndHJTdzBBSUFBZ0NXb2lCQ0FDS0FJSUlneHJJUTBnQUNBQlFXQnFJZzhnQ3lBSlFRQVFLU0FESUFrZ0MybzJBZ0FDUUFKQUlBd2dCQ0FGYTAwRVFDQU5JUVVNQVFzZ0RDQUVJQVpyU3cwQ0lBY2dEU0FGYXlJQWFpSUJJQWhxSUFkTkJFQWdCQ0FCSUFnUUR4b01BZ3NnQkNBQlFRQWdBR3NRRHlFQklBSWdBQ0FJYWlJSU5nSUVJQUVnQUdzaEJBc2dCQ0FQSUFVZ0NFRUJFQ2tMSUE0aENnc2dDZ3ViQWdFQmZ5TUFRWUFCYXlJTkpBQWdEU0FETmdKOEFrQWdBa0VEU3dSQVFYOGhDUXdCQ3dKQUFrQUNRQUpBSUFKQkFXc09Bd0FEQWdFTElBWkZCRUJCdUg4aENRd0VDMEZzSVFrZ0JTMEFBQ0lDSUFOTERRTWdBQ0FISUFKQkFuUWlBbW9vQWdBZ0FpQUlhaWdDQUJBN0lBRWdBRFlDQUVFQklRa01Bd3NnQVNBSk5nSUFRUUFoQ1F3Q0N5QUtSUVJBUVd3aENRd0NDMEVBSVFrZ0MwVWdERUVaU0hJTkFVRUlJQVIwUVFocUlRQkJBQ0VDQTBBZ0FpQUFUdzBDSUFKQlFHc2hBZ3dBQUFzQUMwRnNJUWtnRFNBTlFmd0FhaUFOUWZnQWFpQUZJQVlRRlNJQ0VBTU5BQ0FOS0FKNElnTWdCRXNOQUNBQUlBMGdEU2dDZkNBSElBZ2dBeEFZSUFFZ0FEWUNBQ0FDSVFrTElBMUJnQUZxSkFBZ0NRc0xBQ0FBSUFFZ0FoQUxHZ3NRQUNBQUx3QUFJQUF0QUFKQkVIUnlDeThBQW45QnVIOGdBVUVJU1EwQUdrRnlJQUFvQUFRaUFFRjNTdzBBR2tHNGZ5QUFRUWhxSWdBZ0FDQUJTeHNMQ3drQUlBQWdBVHNBQUFzREFBRUxpZ1lCQlg4Z0FDQUFLQUlBSWdWQmZuRTJBZ0JCQUNBQUlBVkJBWFpxUVlRZ0tBSUFJZ1FnQUVZYklRRUNRQUpBSUFBb0FnUWlBa1VOQUNBQ0tBSUFJZ05CQVhFTkFDQUNRUWhxSWdVZ0EwRUJka0Y0YWlJRFFRZ2dBMEVJU3h0blFSOXpRUUowUVlBZmFpSURLQUlBUmdSQUlBTWdBaWdDRERZQ0FBc2dBaWdDQ0NJREJFQWdBeUFDS0FJTU5nSUVDeUFDS0FJTUlnTUVRQ0FESUFJb0FnZzJBZ0FMSUFJZ0FpZ0NBQ0FBS0FJQVFYNXhhallDQUVHRUlDRUFBa0FDUUNBQlJRMEFJQUVnQWpZQ0JDQUJLQUlBSWdOQkFYRU5BU0FEUVFGMlFYaHFJZ05CQ0NBRFFRaExHMmRCSDNOQkFuUkJnQjlxSWdNb0FnQWdBVUVJYWtZRVFDQURJQUVvQWd3MkFnQUxJQUVvQWdnaUF3UkFJQU1nQVNnQ0REWUNCQXNnQVNnQ0RDSURCRUFnQXlBQktBSUlOZ0lBUVlRZ0tBSUFJUVFMSUFJZ0FpZ0NBQ0FCS0FJQVFYNXhhallDQUNBQklBUkdEUUFnQVNBQktBSUFRUUYyYWtFRWFpRUFDeUFBSUFJMkFnQUxJQUlvQWdCQkFYWkJlR29pQUVFSUlBQkJDRXNiWjBFZmMwRUNkRUdBSDJvaUFTZ0NBQ0VBSUFFZ0JUWUNBQ0FDSUFBMkFnd2dBa0VBTmdJSUlBQkZEUUVnQUNBRk5nSUFEd3NDUUNBQlJRMEFJQUVvQWdBaUFrRUJjUTBBSUFKQkFYWkJlR29pQWtFSUlBSkJDRXNiWjBFZmMwRUNkRUdBSDJvaUFpZ0NBQ0FCUVFocVJnUkFJQUlnQVNnQ0REWUNBQXNnQVNnQ0NDSUNCRUFnQWlBQktBSU1OZ0lFQ3lBQktBSU1JZ0lFUUNBQ0lBRW9BZ2cyQWdCQmhDQW9BZ0FoQkFzZ0FDQUFLQUlBSUFFb0FnQkJmbkZxSWdJMkFnQUNRQ0FCSUFSSEJFQWdBU0FCS0FJQVFRRjJhaUFBTmdJRUlBQW9BZ0FoQWd3QkMwR0VJQ0FBTmdJQUN5QUNRUUYyUVhocUlnRkJDQ0FCUVFoTEcyZEJIM05CQW5SQmdCOXFJZ0lvQWdBaEFTQUNJQUJCQ0dvaUFqWUNBQ0FBSUFFMkFnd2dBRUVBTmdJSUlBRkZEUUVnQVNBQ05nSUFEd3NnQlVFQmRrRjRhaUlCUVFnZ0FVRUlTeHRuUVI5elFRSjBRWUFmYWlJQ0tBSUFJUUVnQWlBQVFRaHFJZ0kyQWdBZ0FDQUJOZ0lNSUFCQkFEWUNDQ0FCUlEwQUlBRWdBallDQUFzTERnQWdBQVJBSUFCQmVHb1FKUXNMZ0FJQkEzOENRQ0FBUVE5cVFYaHhRWVFnS0FJQUtBSUFRUUYyYXlJQ0VCMUJmMFlOQUFKQVFZUWdLQUlBSWdBb0FnQWlBVUVCY1EwQUlBRkJBWFpCZUdvaUFVRUlJQUZCQ0VzYlowRWZjMEVDZEVHQUgyb2lBU2dDQUNBQVFRaHFSZ1JBSUFFZ0FDZ0NERFlDQUFzZ0FDZ0NDQ0lCQkVBZ0FTQUFLQUlNTmdJRUN5QUFLQUlNSWdGRkRRQWdBU0FBS0FJSU5nSUFDMEVCSVFFZ0FDQUFLQUlBSUFKQkFYUnFJZ0kyQWdBZ0FrRUJjUTBBSUFKQkFYWkJlR29pQWtFSUlBSkJDRXNiWjBFZmMwRUNkRUdBSDJvaUF5Z0NBQ0VDSUFNZ0FFRUlhaUlETmdJQUlBQWdBallDRENBQVFRQTJBZ2dnQWtVTkFDQUNJQU0yQWdBTElBRUx0d0lCQTM4Q1FBSkFJQUJCQVNBQUd5SUNFRGdpQUEwQUFrQUNRRUdFSUNnQ0FDSUFSUTBBSUFBb0FnQWlBMEVCY1EwQUlBQWdBMEVCY2pZQ0FDQURRUUYyUVhocUlnRkJDQ0FCUVFoTEcyZEJIM05CQW5SQmdCOXFJZ0VvQWdBZ0FFRUlha1lFUUNBQklBQW9BZ3cyQWdBTElBQW9BZ2dpQVFSQUlBRWdBQ2dDRERZQ0JBc2dBQ2dDRENJQkJFQWdBU0FBS0FJSU5nSUFDeUFDRUNjaEFrRUFJUUZCaENBb0FnQWhBQ0FDRFFFZ0FDQUFLQUlBUVg1eE5nSUFRUUFQQ3lBQ1FROXFRWGh4SWdNUUhTSUNRWDlHRFFJZ0FrRUhha0Y0Y1NJQUlBSkhCRUFnQUNBQ2F4QWRRWDlHRFFNTEFrQkJoQ0FvQWdBaUFVVUVRRUdBSUNBQU5nSUFEQUVMSUFBZ0FUWUNCQXRCaENBZ0FEWUNBQ0FBSUFOQkFYUkJBWEkyQWdBTUFRc2dBRVVOQVFzZ0FFRUlhaUVCQ3lBQkM3a0RBUUovSUFBZ0Eyb2hCUUpBSUFOQkIwd0VRQU5BSUFBZ0JVOE5BaUFBSUFJdEFBQTZBQUFnQUVFQmFpRUFJQUpCQVdvaEFnd0FBQXNBQ3lBRVFRRkdCRUFDUUNBQUlBSnJJZ1pCQjAwRVFDQUFJQUl0QUFBNkFBQWdBQ0FDTFFBQk9nQUJJQUFnQWkwQUFqb0FBaUFBSUFJdEFBTTZBQU1nQUVFRWFpQUNJQVpCQW5RaUJrSEFIbW9vQWdCcUlnSVFGeUFDSUFaQjRCNXFLQUlBYXlFQ0RBRUxJQUFnQWhBTUN5QUNRUWhxSVFJZ0FFRUlhaUVBQ3dKQUFrQUNRQUpBSUFVZ0FVMEVRQ0FBSUFOcUlRRWdCRUVCUnlBQUlBSnJRUTlLY2cwQkEwQWdBQ0FDRUF3Z0FrRUlhaUVDSUFCQkNHb2lBQ0FCU1EwQUN3d0ZDeUFBSUFGTEJFQWdBQ0VCREFRTElBUkJBVWNnQUNBQ2EwRVBTbklOQVNBQUlRTWdBaUVFQTBBZ0F5QUVFQXdnQkVFSWFpRUVJQU5CQ0dvaUF5QUJTUTBBQ3d3Q0N3TkFJQUFnQWhBSElBSkJFR29oQWlBQVFSQnFJZ0FnQVVrTkFBc01Bd3NnQUNFRElBSWhCQU5BSUFNZ0JCQUhJQVJCRUdvaEJDQURRUkJxSWdNZ0FVa05BQXNMSUFJZ0FTQUFhMm9oQWdzRFFDQUJJQVZQRFFFZ0FTQUNMUUFBT2dBQUlBRkJBV29oQVNBQ1FRRnFJUUlNQUFBTEFBc0xRUUVDZnlBQUlBQW9BcmpnQVNJRE5nTEU0QUVnQUNnQ3ZPQUJJUVFnQUNBQk5nSzg0QUVnQUNBQklBSnFOZ0s0NEFFZ0FDQUJJQVFnQTJ0cU5nTEE0QUVMcGdFQkFYOGdBQ0FBS0FMczRRRVFGallDeU9BQklBQkNBRGNEK09BQklBQkNBRGNEdU9BQklBQkJ3T0FCYWtJQU53TUFJQUJCcU5BQWFpSUJRWXlBZ09BQU5nSUFJQUJCQURZQ21PSUJJQUJDQURjRGlPRUJJQUJDQXpjRGdPRUJJQUJCck5BQmFrSGdFaWtDQURjQ0FDQUFRYlRRQVdwQjZCSW9BZ0EyQWdBZ0FDQUJOZ0lNSUFBZ0FFR1lJR28yQWdnZ0FDQUFRYUF3YWpZQ0JDQUFJQUJCRUdvMkFnQUxZUUVCZjBHNGZ5RURBa0FnQVVFRFNRMEFJQUlnQUJBaElnRkJBM1lpQURZQ0NDQUNJQUZCQVhFMkFnUWdBaUFCUVFGMlFRTnhJZ00yQWdBQ1FDQURRWDlxSWdGQkFrc05BQUpBSUFGQkFXc09BZ0VBQWd0QmJBOExJQUFoQXdzZ0F3c01BQ0FBSUFFZ0FrRUFFQzRMaUFRQ0EzOENmaUFERUJZaEJDQUFRUUJCS0JBUUlRQWdCQ0FDU3dSQUlBUVBDeUFCUlFSQVFYOFBDd0pBQWtBZ0EwRUJSZzBBSUFFb0FBQWlCa0dvNnI1cFJnMEFRWFloQXlBR1FYQnhRZERVdE1JQlJ3MEJRUWdoQXlBQ1FRaEpEUUVnQUVFQVFTZ1FFQ0VBSUFFb0FBUWhBU0FBUVFFMkFoUWdBQ0FCclRjREFFRUFEd3NnQVNBQ0lBTVFMeUlESUFKTERRQWdBQ0FETmdJWVFYSWhBeUFCSUFScUlnVkJmMm90QUFBaUFrRUljUTBBSUFKQklIRWlCa1VFUUVGd0lRTWdCUzBBQUNJRlFhY0JTdzBCSUFWQkIzR3RRZ0VnQlVFRGRrRUthcTJHSWdkQ0E0aCtJQWQ4SVFnZ0JFRUJhaUVFQ3lBQ1FRWjJJUU1nQWtFQ2RpRUZBa0FnQWtFRGNVRi9haUlDUVFKTEJFQkJBQ0VDREFFTEFrQUNRQUpBSUFKQkFXc09BZ0VDQUFzZ0FTQUVhaTBBQUNFQ0lBUkJBV29oQkF3Q0N5QUJJQVJxTHdBQUlRSWdCRUVDYWlFRURBRUxJQUVnQkdvb0FBQWhBaUFFUVFScUlRUUxJQVZCQVhFaEJRSitBa0FDUUFKQUlBTkJmMm9pQTBFQ1RRUkFJQU5CQVdzT0FnSURBUXRDZnlBR1JRMERHaUFCSUFScU1RQUFEQU1MSUFFZ0JHb3ZBQUN0UW9BQ2ZBd0NDeUFCSUFScUtBQUFyUXdCQ3lBQklBUnFLUUFBQ3lFSElBQWdCVFlDSUNBQUlBSTJBaHdnQUNBSE53TUFRUUFoQXlBQVFRQTJBaFFnQUNBSElBZ2dCaHNpQnpjRENDQUFJQWRDZ0lBSUlBZENnSUFJVkJzK0FoQUxJQU1MV3dFQmYwRzRmeUVESUFJUUZpSUNJQUZOQkg4Z0FDQUNha0YvYWkwQUFDSUFRUU54UVFKMFFhQWVhaWdDQUNBQ2FpQUFRUVoySWdGQkFuUkJzQjVxS0FJQWFpQUFRU0J4SWdCRmFpQUJSU0FBUVFWMmNXb0ZRYmgvQ3dzZEFDQUFLQUtRNGdFUVdpQUFRUUEyQXFEaUFTQUFRZ0EzQTVEaUFRdTFBd0VGZnlNQVFaQUNheUlLSkFCQnVIOGhCZ0pBSUFWRkRRQWdCQ3dBQUNJSVFmOEJjU0VIQWtBZ0NFRi9UQVJBSUFkQmduOXFRUUYySWdnZ0JVOE5Ba0ZzSVFZZ0IwR0JmMm9pQlVHQUFrOE5BaUFFUVFGcUlRZEJBQ0VHQTBBZ0JpQUZUd1JBSUFVaEJpQUlJUWNNQXdVZ0FDQUdhaUFISUFaQkFYWnFJZ1F0QUFCQkJIWTZBQUFnQUNBR1FRRnlhaUFFTFFBQVFROXhPZ0FBSUFaQkFtb2hCZ3dCQ3dBQUN3QUxJQWNnQlU4TkFTQUFJQVJCQVdvZ0J5QUtFRk1pQmhBRERRRUxJQVloQkVFQUlRWWdBVUVBUVRRUUVDRUpRUUFoQlFOQUlBUWdCa2NFUUNBQUlBWnFJZ2d0QUFBaUFVRUxTd1JBUVd3aEJnd0RCU0FKSUFGQkFuUnFJZ0VnQVNnQ0FFRUJhallDQUNBR1FRRnFJUVpCQVNBSUxRQUFkRUVCZFNBRmFpRUZEQUlMQUFzTFFXd2hCaUFGUlEwQUlBVVFGRUVCYWlJQlFReExEUUFnQXlBQk5nSUFRUUZCQVNBQmRDQUZheUlERUJRaUFYUWdBMGNOQUNBQUlBUnFJQUZCQVdvaUFEb0FBQ0FKSUFCQkFuUnFJZ0FnQUNnQ0FFRUJhallDQUNBSktBSUVJZ0JCQWtrZ0FFRUJjWElOQUNBQ0lBUkJBV28yQWdBZ0IwRUJhaUVHQ3lBS1FaQUNhaVFBSUFZTHhoRUJESDhqQUVId0FHc2lCU1FBUVd3aEN3SkFJQU5CQ2trTkFDQUNMd0FBSVFvZ0FpOEFBaUVKSUFJdkFBUWhCeUFGUVFocUlBUVFEZ0pBSUFNZ0J5QUpJQXBxYWtFR2FpSU1TUTBBSUFVdEFBb2hDQ0FGUWRnQWFpQUNRUVpxSWdJZ0NoQUdJZ3NRQXcwQklBVkJRR3NnQWlBS2FpSUNJQWtRQmlJTEVBTU5BU0FGUVNocUlBSWdDV29pQWlBSEVBWWlDeEFERFFFZ0JVRVFhaUFDSUFkcUlBTWdER3NRQmlJTEVBTU5BU0FBSUFGcUlnOUJmV29oRUNBRVFRUnFJUVpCQVNFTElBQWdBVUVEYWtFQ2RpSURhaUlNSUFOcUlnSWdBMm9pRGlFRElBSWhCQ0FNSVFjRFFDQUxJQU1nRUVseEJFQWdBQ0FHSUFWQjJBQnFJQWdRQWtFQ2RHb2lDUzhCQURzQUFDQUZRZGdBYWlBSkxRQUNFQUVnQ1MwQUF5RUxJQWNnQmlBRlFVQnJJQWdRQWtFQ2RHb2lDUzhCQURzQUFDQUZRVUJySUFrdEFBSVFBU0FKTFFBRElRb2dCQ0FHSUFWQktHb2dDQkFDUVFKMGFpSUpMd0VBT3dBQUlBVkJLR29nQ1MwQUFoQUJJQWt0QUFNaENTQURJQVlnQlVFUWFpQUlFQUpCQW5ScUlnMHZBUUE3QUFBZ0JVRVFhaUFOTFFBQ0VBRWdEUzBBQXlFTklBQWdDMm9pQ3lBR0lBVkIyQUJxSUFnUUFrRUNkR29pQUM4QkFEc0FBQ0FGUWRnQWFpQUFMUUFDRUFFZ0FDMEFBeUVBSUFjZ0Ntb2lDaUFHSUFWQlFHc2dDQkFDUVFKMGFpSUhMd0VBT3dBQUlBVkJRR3NnQnkwQUFoQUJJQWN0QUFNaEJ5QUVJQWxxSWdrZ0JpQUZRU2hxSUFnUUFrRUNkR29pQkM4QkFEc0FBQ0FGUVNocUlBUXRBQUlRQVNBRUxRQURJUVFnQXlBTmFpSURJQVlnQlVFUWFpQUlFQUpCQW5ScUlnMHZBUUE3QUFBZ0JVRVFhaUFOTFFBQ0VBRWdBQ0FMYWlFQUlBY2dDbW9oQnlBRUlBbHFJUVFnQXlBTkxRQURhaUVESUFWQjJBQnFFQTBnQlVGQWF4QU5jaUFGUVNocUVBMXlJQVZCRUdvUURYSkZJUXNNQVFzTElBUWdEa3NnQnlBQ1MzSU5BRUZzSVFzZ0FDQU1TdzBCSUF4QmZXb2hDUU5BUVFBZ0FDQUpTU0FGUWRnQWFoQUVHd1JBSUFBZ0JpQUZRZGdBYWlBSUVBSkJBblJxSWdvdkFRQTdBQUFnQlVIWUFHb2dDaTBBQWhBQklBQWdDaTBBQTJvaUFDQUdJQVZCMkFCcUlBZ1FBa0VDZEdvaUNpOEJBRHNBQUNBRlFkZ0FhaUFLTFFBQ0VBRWdBQ0FLTFFBRGFpRUFEQUVGSUF4QmZtb2hDZ05BSUFWQjJBQnFFQVFnQUNBS1MzSkZCRUFnQUNBR0lBVkIyQUJxSUFnUUFrRUNkR29pQ1M4QkFEc0FBQ0FGUWRnQWFpQUpMUUFDRUFFZ0FDQUpMUUFEYWlFQURBRUxDd05BSUFBZ0NrMEVRQ0FBSUFZZ0JVSFlBR29nQ0JBQ1FRSjBhaUlKTHdFQU93QUFJQVZCMkFCcUlBa3RBQUlRQVNBQUlBa3RBQU5xSVFBTUFRc0xBa0FnQUNBTVR3MEFJQUFnQmlBRlFkZ0FhaUFJRUFJaUFFRUNkR29pREMwQUFEb0FBQ0FNTFFBRFFRRkdCRUFnQlVIWUFHb2dEQzBBQWhBQkRBRUxJQVVvQWx4Qkgwc05BQ0FGUWRnQWFpQUdJQUJCQW5ScUxRQUNFQUVnQlNnQ1hFRWhTUTBBSUFWQklEWUNYQXNnQWtGOWFpRU1BMEJCQUNBSElBeEpJQVZCUUdzUUJCc0VRQ0FISUFZZ0JVRkFheUFJRUFKQkFuUnFJZ0F2QVFBN0FBQWdCVUZBYXlBQUxRQUNFQUVnQnlBQUxRQURhaUlBSUFZZ0JVRkFheUFJRUFKQkFuUnFJZ2N2QVFBN0FBQWdCVUZBYXlBSExRQUNFQUVnQUNBSExRQURhaUVIREFFRklBSkJmbW9oREFOQUlBVkJRR3NRQkNBSElBeExja1VFUUNBSElBWWdCVUZBYXlBSUVBSkJBblJxSWdBdkFRQTdBQUFnQlVGQWF5QUFMUUFDRUFFZ0J5QUFMUUFEYWlFSERBRUxDd05BSUFjZ0RFMEVRQ0FISUFZZ0JVRkFheUFJRUFKQkFuUnFJZ0F2QVFBN0FBQWdCVUZBYXlBQUxRQUNFQUVnQnlBQUxRQURhaUVIREFFTEN3SkFJQWNnQWs4TkFDQUhJQVlnQlVGQWF5QUlFQUlpQUVFQ2RHb2lBaTBBQURvQUFDQUNMUUFEUVFGR0JFQWdCVUZBYXlBQ0xRQUNFQUVNQVFzZ0JTZ0NSRUVmU3cwQUlBVkJRR3NnQmlBQVFRSjBhaTBBQWhBQklBVW9Ba1JCSVVrTkFDQUZRU0EyQWtRTElBNUJmV29oQWdOQVFRQWdCQ0FDU1NBRlFTaHFFQVFiQkVBZ0JDQUdJQVZCS0dvZ0NCQUNRUUowYWlJQUx3RUFPd0FBSUFWQktHb2dBQzBBQWhBQklBUWdBQzBBQTJvaUFDQUdJQVZCS0dvZ0NCQUNRUUowYWlJRUx3RUFPd0FBSUFWQktHb2dCQzBBQWhBQklBQWdCQzBBQTJvaEJBd0JCU0FPUVg1cUlRSURRQ0FGUVNocUVBUWdCQ0FDUzNKRkJFQWdCQ0FHSUFWQktHb2dDQkFDUVFKMGFpSUFMd0VBT3dBQUlBVkJLR29nQUMwQUFoQUJJQVFnQUMwQUEyb2hCQXdCQ3dzRFFDQUVJQUpOQkVBZ0JDQUdJQVZCS0dvZ0NCQUNRUUowYWlJQUx3RUFPd0FBSUFWQktHb2dBQzBBQWhBQklBUWdBQzBBQTJvaEJBd0JDd3NDUUNBRUlBNVBEUUFnQkNBR0lBVkJLR29nQ0JBQ0lnQkJBblJxSWdJdEFBQTZBQUFnQWkwQUEwRUJSZ1JBSUFWQktHb2dBaTBBQWhBQkRBRUxJQVVvQWl4Qkgwc05BQ0FGUVNocUlBWWdBRUVDZEdvdEFBSVFBU0FGS0FJc1FTRkpEUUFnQlVFZ05nSXNDd05BUVFBZ0F5QVFTU0FGUVJCcUVBUWJCRUFnQXlBR0lBVkJFR29nQ0JBQ1FRSjBhaUlBTHdFQU93QUFJQVZCRUdvZ0FDMEFBaEFCSUFNZ0FDMEFBMm9pQUNBR0lBVkJFR29nQ0JBQ1FRSjBhaUlDTHdFQU93QUFJQVZCRUdvZ0FpMEFBaEFCSUFBZ0FpMEFBMm9oQXd3QkJTQVBRWDVxSVFJRFFDQUZRUkJxRUFRZ0F5QUNTM0pGQkVBZ0F5QUdJQVZCRUdvZ0NCQUNRUUowYWlJQUx3RUFPd0FBSUFWQkVHb2dBQzBBQWhBQklBTWdBQzBBQTJvaEF3d0JDd3NEUUNBRElBSk5CRUFnQXlBR0lBVkJFR29nQ0JBQ1FRSjBhaUlBTHdFQU93QUFJQVZCRUdvZ0FDMEFBaEFCSUFNZ0FDMEFBMm9oQXd3QkN3c0NRQ0FESUE5UERRQWdBeUFHSUFWQkVHb2dDQkFDSWdCQkFuUnFJZ0l0QUFBNkFBQWdBaTBBQTBFQlJnUkFJQVZCRUdvZ0FpMEFBaEFCREFFTElBVW9BaFJCSDBzTkFDQUZRUkJxSUFZZ0FFRUNkR290QUFJUUFTQUZLQUlVUVNGSkRRQWdCVUVnTmdJVUN5QUJRV3dnQlVIWUFHb1FDaUFGUVVCckVBcHhJQVZCS0dvUUNuRWdCVUVRYWhBS2NSc2hDd3dKQ3dBQUN3QUxBQUFMQUFzQUFBc0FDd0FBQ3dBTFFXd2hDd3NnQlVId0FHb2tBQ0FMQzdVRUFRNS9Jd0JCRUdzaUJpUUFJQVpCQkdvZ0FCQU9RVlFoQlFKQUlBUkIzQXRKRFFBZ0JpMEFCQ0VISUFOQjhBUnFRUUJCN0FBUUVDRUlJQWRCREVzTkFDQURRZHdKYWlJSklBZ2dCa0VJYWlBR1FReHFJQUVnQWhBeEloQVFBMFVFUUNBR0tBSU1JZ1FnQjBzTkFTQURRZHdGYWlFUElBTkJwQVZxSVJFZ0FFRUVhaUVTSUFOQnFBVnFJUUVnQkNFRkEwQWdCU0lDUVg5cUlRVWdDQ0FDUVFKMGFpZ0NBRVVOQUFzZ0FrRUJhaUVPUVFFaEJRTkFJQVVnRGs5RkJFQWdDQ0FGUVFKMElndHFLQUlBSVF3Z0FTQUxhaUFLTmdJQUlBVkJBV29oQlNBS0lBeHFJUW9NQVFzTElBRWdDallDQUVFQUlRVWdCaWdDQ0NFTEEwQWdCU0FMUmtVRVFDQUJJQVVnQ1dvdEFBQWlERUVDZEdvaURTQU5LQUlBSWcxQkFXbzJBZ0FnRHlBTlFRRjBhaUlOSUF3NkFBRWdEU0FGT2dBQUlBVkJBV29oQlF3QkN3dEJBQ0VCSUFOQkFEWUNxQVVnQkVGL2N5QUhhaUVKUVFFaEJRTkFJQVVnRGs5RkJFQWdDQ0FGUVFKMElndHFLQUlBSVF3Z0F5QUxhaUFCTmdJQUlBd2dCU0FKYW5RZ0FXb2hBU0FGUVFGcUlRVU1BUXNMSUFjZ0JFRUJhaUlCSUFKcklnUnJRUUZxSVFnRFFFRUJJUVVnQkNBSVQwVUVRQU5BSUFVZ0RrOUZCRUFnQlVFQ2RDSUpJQU1nQkVFMGJHcHFJQU1nQ1dvb0FnQWdCSFkyQWdBZ0JVRUJhaUVGREFFTEN5QUVRUUZxSVFRTUFRc0xJQklnQnlBUElBb2dFU0FESUFJZ0FSQmtJQVpCQVRvQUJTQUdJQWM2QUFZZ0FDQUdLQUlFTmdJQUN5QVFJUVVMSUFaQkVHb2tBQ0FGQzhFTkFRdC9Jd0JCOEFCcklnVWtBRUZzSVFrQ1FDQURRUXBKRFFBZ0FpOEFBQ0VLSUFJdkFBSWhEQ0FDTHdBRUlRWWdCVUVJYWlBRUVBNENRQ0FESUFZZ0NpQU1hbXBCQm1vaURVa05BQ0FGTFFBS0lRY2dCVUhZQUdvZ0FrRUdhaUlDSUFvUUJpSUpFQU1OQVNBRlFVQnJJQUlnQ21vaUFpQU1FQVlpQ1JBRERRRWdCVUVvYWlBQ0lBeHFJZ0lnQmhBR0lna1FBdzBCSUFWQkVHb2dBaUFHYWlBRElBMXJFQVlpQ1JBRERRRWdBQ0FCYWlJT1FYMXFJUThnQkVFRWFpRUdRUUVoQ1NBQUlBRkJBMnBCQW5ZaUFtb2lDaUFDYWlJTUlBSnFJZzBoQXlBTUlRUWdDaUVDQTBBZ0NTQURJQTlKY1FSQUlBWWdCVUhZQUdvZ0J4QUNRUUYwYWlJSUxRQUFJUXNnQlVIWUFHb2dDQzBBQVJBQklBQWdDem9BQUNBR0lBVkJRR3NnQnhBQ1FRRjBhaUlJTFFBQUlRc2dCVUZBYXlBSUxRQUJFQUVnQWlBTE9nQUFJQVlnQlVFb2FpQUhFQUpCQVhScUlnZ3RBQUFoQ3lBRlFTaHFJQWd0QUFFUUFTQUVJQXM2QUFBZ0JpQUZRUkJxSUFjUUFrRUJkR29pQ0MwQUFDRUxJQVZCRUdvZ0NDMEFBUkFCSUFNZ0N6b0FBQ0FHSUFWQjJBQnFJQWNRQWtFQmRHb2lDQzBBQUNFTElBVkIyQUJxSUFndEFBRVFBU0FBSUFzNkFBRWdCaUFGUVVCcklBY1FBa0VCZEdvaUNDMEFBQ0VMSUFWQlFHc2dDQzBBQVJBQklBSWdDem9BQVNBR0lBVkJLR29nQnhBQ1FRRjBhaUlJTFFBQUlRc2dCVUVvYWlBSUxRQUJFQUVnQkNBTE9nQUJJQVlnQlVFUWFpQUhFQUpCQVhScUlnZ3RBQUFoQ3lBRlFSQnFJQWd0QUFFUUFTQURJQXM2QUFFZ0EwRUNhaUVESUFSQkFtb2hCQ0FDUVFKcUlRSWdBRUVDYWlFQUlBa2dCVUhZQUdvUURVVnhJQVZCUUdzUURVVnhJQVZCS0dvUURVVnhJQVZCRUdvUURVVnhJUWtNQVFzTElBUWdEVXNnQWlBTVMzSU5BRUZzSVFrZ0FDQUtTdzBCSUFwQmZXb2hDUU5BSUFWQjJBQnFFQVFnQUNBSlQzSkZCRUFnQmlBRlFkZ0FhaUFIRUFKQkFYUnFJZ2d0QUFBaEN5QUZRZGdBYWlBSUxRQUJFQUVnQUNBTE9nQUFJQVlnQlVIWUFHb2dCeEFDUVFGMGFpSUlMUUFBSVFzZ0JVSFlBR29nQ0MwQUFSQUJJQUFnQ3pvQUFTQUFRUUpxSVFBTUFRc0xBMEFnQlVIWUFHb1FCQ0FBSUFwUGNrVUVRQ0FHSUFWQjJBQnFJQWNRQWtFQmRHb2lDUzBBQUNFSUlBVkIyQUJxSUFrdEFBRVFBU0FBSUFnNkFBQWdBRUVCYWlFQURBRUxDd05BSUFBZ0Nra0VRQ0FHSUFWQjJBQnFJQWNRQWtFQmRHb2lDUzBBQUNFSUlBVkIyQUJxSUFrdEFBRVFBU0FBSUFnNkFBQWdBRUVCYWlFQURBRUxDeUFNUVgxcUlRQURRQ0FGUVVCckVBUWdBaUFBVDNKRkJFQWdCaUFGUVVCcklBY1FBa0VCZEdvaUNpMEFBQ0VKSUFWQlFHc2dDaTBBQVJBQklBSWdDVG9BQUNBR0lBVkJRR3NnQnhBQ1FRRjBhaUlLTFFBQUlRa2dCVUZBYXlBS0xRQUJFQUVnQWlBSk9nQUJJQUpCQW1vaEFnd0JDd3NEUUNBRlFVQnJFQVFnQWlBTVQzSkZCRUFnQmlBRlFVQnJJQWNRQWtFQmRHb2lBQzBBQUNFS0lBVkJRR3NnQUMwQUFSQUJJQUlnQ2pvQUFDQUNRUUZxSVFJTUFRc0xBMEFnQWlBTVNRUkFJQVlnQlVGQWF5QUhFQUpCQVhScUlnQXRBQUFoQ2lBRlFVQnJJQUF0QUFFUUFTQUNJQW82QUFBZ0FrRUJhaUVDREFFTEN5QU5RWDFxSVFBRFFDQUZRU2hxRUFRZ0JDQUFUM0pGQkVBZ0JpQUZRU2hxSUFjUUFrRUJkR29pQWkwQUFDRUtJQVZCS0dvZ0FpMEFBUkFCSUFRZ0Nqb0FBQ0FHSUFWQktHb2dCeEFDUVFGMGFpSUNMUUFBSVFvZ0JVRW9haUFDTFFBQkVBRWdCQ0FLT2dBQklBUkJBbW9oQkF3QkN3c0RRQ0FGUVNocUVBUWdCQ0FOVDNKRkJFQWdCaUFGUVNocUlBY1FBa0VCZEdvaUFDMEFBQ0VDSUFWQktHb2dBQzBBQVJBQklBUWdBam9BQUNBRVFRRnFJUVFNQVFzTEEwQWdCQ0FOU1FSQUlBWWdCVUVvYWlBSEVBSkJBWFJxSWdBdEFBQWhBaUFGUVNocUlBQXRBQUVRQVNBRUlBSTZBQUFnQkVFQmFpRUVEQUVMQ3dOQUlBVkJFR29RQkNBRElBOVBja1VFUUNBR0lBVkJFR29nQnhBQ1FRRjBhaUlBTFFBQUlRSWdCVUVRYWlBQUxRQUJFQUVnQXlBQ09nQUFJQVlnQlVFUWFpQUhFQUpCQVhScUlnQXRBQUFoQWlBRlFSQnFJQUF0QUFFUUFTQURJQUk2QUFFZ0EwRUNhaUVEREFFTEN3TkFJQVZCRUdvUUJDQURJQTVQY2tVRVFDQUdJQVZCRUdvZ0J4QUNRUUYwYWlJQUxRQUFJUUlnQlVFUWFpQUFMUUFCRUFFZ0F5QUNPZ0FBSUFOQkFXb2hBd3dCQ3dzRFFDQURJQTVKQkVBZ0JpQUZRUkJxSUFjUUFrRUJkR29pQUMwQUFDRUNJQVZCRUdvZ0FDMEFBUkFCSUFNZ0Fqb0FBQ0FEUVFGcUlRTU1BUXNMSUFGQmJDQUZRZGdBYWhBS0lBVkJRR3NRQ25FZ0JVRW9haEFLY1NBRlFSQnFFQXB4R3lFSkRBRUxRV3doQ1FzZ0JVSHdBR29rQUNBSkM4b0NBUVIvSXdCQklHc2lCU1FBSUFVZ0JCQU9JQVV0QUFJaEJ5QUZRUWhxSUFJZ0F4QUdJZ0lRQTBVRVFDQUVRUVJxSVFJZ0FDQUJhaUlEUVgxcUlRUURRQ0FGUVFocUVBUWdBQ0FFVDNKRkJFQWdBaUFGUVFocUlBY1FBa0VCZEdvaUJpMEFBQ0VJSUFWQkNHb2dCaTBBQVJBQklBQWdDRG9BQUNBQ0lBVkJDR29nQnhBQ1FRRjBhaUlHTFFBQUlRZ2dCVUVJYWlBR0xRQUJFQUVnQUNBSU9nQUJJQUJCQW1vaEFBd0JDd3NEUUNBRlFRaHFFQVFnQUNBRFQzSkZCRUFnQWlBRlFRaHFJQWNRQWtFQmRHb2lCQzBBQUNFR0lBVkJDR29nQkMwQUFSQUJJQUFnQmpvQUFDQUFRUUZxSVFBTUFRc0xBMEFnQUNBRFQwVUVRQ0FDSUFWQkNHb2dCeEFDUVFGMGFpSUVMUUFBSVFZZ0JVRUlhaUFFTFFBQkVBRWdBQ0FHT2dBQUlBQkJBV29oQUF3QkN3c2dBVUZzSUFWQkNHb1FDaHNoQWdzZ0JVRWdhaVFBSUFJTHRnTUJDWDhqQUVFUWF5SUdKQUFnQmtFQU5nSU1JQVpCQURZQ0NFRlVJUVFDUUFKQUlBTkJRR3NpRENBRElBWkJDR29nQmtFTWFpQUJJQUlRTVNJQ0VBTU5BQ0FHUVFScUlBQVFEaUFHS0FJTUlnY2dCaTBBQkVFQmFrc05BU0FBUVFScUlRb2dCa0VBT2dBRklBWWdCem9BQmlBQUlBWW9BZ1EyQWdBZ0IwRUJhaUVKUVFFaEJBTkFJQVFnQ1VrRVFDQURJQVJCQW5ScUlnRW9BZ0FoQUNBQklBVTJBZ0FnQUNBRVFYOXFkQ0FGYWlFRklBUkJBV29oQkF3QkN3c2dCMEVCYWlFSFFRQWhCU0FHS0FJSUlRa0RRQ0FGSUFsR0RRRWdBeUFGSUF4cUxRQUFJZ1JCQW5ScUlnQkJBU0FFZEVFQmRTSUxJQUFvQWdBaUFXb2lBRFlDQUNBSElBUnJJUWhCQUNFRUFrQWdDMEVEVFFSQUEwQWdCQ0FMUmcwQ0lBb2dBU0FFYWtFQmRHb2lBQ0FJT2dBQklBQWdCVG9BQUNBRVFRRnFJUVFNQUFBTEFBc0RRQ0FCSUFCUERRRWdDaUFCUVFGMGFpSUVJQWc2QUFFZ0JDQUZPZ0FBSUFRZ0NEb0FBeUFFSUFVNkFBSWdCQ0FJT2dBRklBUWdCVG9BQkNBRUlBZzZBQWNnQkNBRk9nQUdJQUZCQkdvaEFRd0FBQXNBQ3lBRlFRRnFJUVVNQUFBTEFBc2dBaUVFQ3lBR1FSQnFKQUFnQkF1dEFRRUNmd0pBUVlRZ0tBSUFJQUJISUFBb0FnQkJBWFlpQXlBQmEwRjRhaUlDUVhoeFFRaEhjZ1IvSUFJRklBTVFKMFVOQVNBQ1FRaHFDMEVRU1EwQUlBQWdBQ2dDQUNJQ1FRRnhJQUFnQVdwQkQycEJlSEVpQVNBQWEwRUJkSEkyQWdBZ0FTQUFOZ0lFSUFFZ0FTZ0NBRUVCY1NBQUlBSkJBWFpxSUFGcklnSkJBWFJ5TmdJQVFZUWdJQUVnQWtILy8vLy9CM0ZxUVFScVFZUWdLQUlBSUFCR0d5QUJOZ0lBSUFFUUpRc0x5Z0lCQlg4Q1FBSkFBa0FnQUVFSUlBQkJDRXNiWjBFZmN5QUFhVUVCUjJvaUFVRUVTU0FBSUFGMmNnMEFJQUZCQW5SQi9CNXFLQUlBSWdKRkRRQURRQ0FDUVhocUlnTW9BZ0JCQVhaQmVHb2lCU0FBVHdSQUlBSWdCVUVJSUFWQkNFc2JaMEVmYzBFQ2RFR0FIMm9pQVNnQ0FFWUVRQ0FCSUFJb0FnUTJBZ0FMREFNTElBUkJIa3NOQVNBRVFRRnFJUVFnQWlnQ0JDSUNEUUFMQzBFQUlRTWdBVUVnVHcwQkEwQWdBVUVDZEVHQUgyb29BZ0FpQWtVRVFDQUJRUjVMSVFJZ0FVRUJhaUVCSUFKRkRRRU1Bd3NMSUFJZ0FrRjRhaUlES0FJQVFRRjJRWGhxSWdGQkNDQUJRUWhMRzJkQkgzTkJBblJCZ0I5cUlnRW9BZ0JHQkVBZ0FTQUNLQUlFTmdJQUN3c2dBaWdDQUNJQkJFQWdBU0FDS0FJRU5nSUVDeUFDS0FJRUlnRUVRQ0FCSUFJb0FnQTJBZ0FMSUFNZ0F5Z0NBRUVCY2pZQ0FDQURJQUFRTndzZ0F3dmhDd0lOZndWK0l3QkI4QUJySWdja0FDQUhJQUFvQXZEaEFTSUlOZ0pjSUFFZ0Ftb2hEU0FJSUFBb0FvRGlBV29oRHdKQUFrQWdCVVVFUUNBQklRUU1BUXNnQUNnQ3hPQUJJUkFnQUNnQ3dPQUJJUkVnQUNnQ3ZPQUJJUTRnQUVFQk5nS000UUZCQUNFSUEwQWdDRUVEUndSQUlBY2dDRUVDZENJQ2FpQUFJQUpxUWF6UUFXb29BZ0EyQWtRZ0NFRUJhaUVJREFFTEMwRnNJUXdnQjBFWWFpQURJQVFRQmhBRERRRWdCMEVzYWlBSFFSaHFJQUFvQWdBUUV5QUhRVFJxSUFkQkdHb2dBQ2dDQ0JBVElBZEJQR29nQjBFWWFpQUFLQUlFRUJNZ0RVRmdhaUVTSUFFaEJFRUFJUXdEUUNBSEtBSXdJQWNvQWl4QkEzUnFLUUlBSWhSQ0VJaW5RZjhCY1NFSUlBY29Ba0FnQnlnQ1BFRURkR29wQWdBaUZVSVFpS2RCL3dGeElRc2dCeWdDT0NBSEtBSTBRUU4wYWlrQ0FDSVdRaUNJcHlFSklCVkNJSWdoRnlBVVFpQ0lweUVDQWtBZ0ZrSVFpS2RCL3dGeElnTkJBazhFUUFKQUlBWkZJQU5CR1VseVJRUkFJQWtnQjBFWWFpQURRU0FnQnlnQ0hHc2lDaUFLSUFOTEd5SUtFQVVnQXlBS2F5SURkR29oQ1NBSFFSaHFFQVFhSUFORkRRRWdCMEVZYWlBREVBVWdDV29oQ1F3QkN5QUhRUmhxSUFNUUJTQUphaUVKSUFkQkdHb1FCQm9MSUFjcEFrUWhHQ0FISUFrMkFrUWdCeUFZTndOSURBRUxBa0FnQTBVRVFDQUNCRUFnQnlnQ1JDRUpEQU1MSUFjb0FrZ2hDUXdCQ3dKQUFrQWdCMEVZYWtFQkVBVWdDU0FDUldwcUlnTkJBMFlFUUNBSEtBSkVRWDlxSWdNZ0EwVnFJUWtNQVFzZ0EwRUNkQ0FIYWlnQ1JDSUpJQWxGYWlFSklBTkJBVVlOQVFzZ0J5QUhLQUpJTmdKTUN3c2dCeUFIS0FKRU5nSklJQWNnQ1RZQ1JBc2dGNmNoQXlBTEJFQWdCMEVZYWlBTEVBVWdBMm9oQXdzZ0NDQUxha0VVVHdSQUlBZEJHR29RQkJvTElBZ0VRQ0FIUVJocUlBZ1FCU0FDYWlFQ0N5QUhRUmhxRUFRYUlBY2dCMEVZYWlBVVFoaUlwMEgvQVhFUUNDQVVwMEgvL3dOeGFqWUNMQ0FISUFkQkdHb2dGVUlZaUtkQi93RnhFQWdnRmFkQi8vOERjV28yQWp3Z0IwRVlhaEFFR2lBSElBZEJHR29nRmtJWWlLZEIvd0Z4RUFnZ0ZxZEIvLzhEY1dvMkFqUWdCeUFDTmdKZ0lBY29BbHdoQ2lBSElBazJBbWdnQnlBRE5nSmtBa0FDUUFKQUlBUWdBaUFEYWlJTGFpQVNTdzBBSUFJZ0Ntb2lFeUFQU3cwQUlBMGdCR3NnQzBFZ2FrOE5BUXNnQnlBSEtRTm9Od01RSUFjZ0J5a0RZRGNEQ0NBRUlBMGdCMEVJYWlBSFFkd0FhaUFQSUE0Z0VTQVFFQjRoQ3d3QkN5QUNJQVJxSVFnZ0JDQUtFQWNnQWtFUlR3UkFJQVJCRUdvaEFnTkFJQUlnQ2tFUWFpSUtFQWNnQWtFUWFpSUNJQWhKRFFBTEN5QUlJQWxySVFJZ0J5QVROZ0pjSUFrZ0NDQU9hMHNFUUNBSklBZ2dFV3RMQkVCQmJDRUxEQUlMSUJBZ0FpQU9heUlDYWlJS0lBTnFJQkJOQkVBZ0NDQUtJQU1RRHhvTUFnc2dDQ0FLUVFBZ0Ftc1FEeUVJSUFjZ0FpQURhaUlETmdKa0lBZ2dBbXNoQ0NBT0lRSUxJQWxCRUU4RVFDQURJQWhxSVFNRFFDQUlJQUlRQnlBQ1FSQnFJUUlnQ0VFUWFpSUlJQU5KRFFBTERBRUxBa0FnQ1VFSFRRUkFJQWdnQWkwQUFEb0FBQ0FJSUFJdEFBRTZBQUVnQ0NBQ0xRQUNPZ0FDSUFnZ0FpMEFBem9BQXlBSVFRUnFJQUlnQ1VFQ2RDSURRY0FlYWlnQ0FHb2lBaEFYSUFJZ0EwSGdIbW9vQWdCcklRSWdCeWdDWkNFRERBRUxJQWdnQWhBTUN5QURRUWxKRFFBZ0F5QUlhaUVESUFoQkNHb2lDQ0FDUVFocUlnSnJRUTlNQkVBRFFDQUlJQUlRRENBQ1FRaHFJUUlnQ0VFSWFpSUlJQU5KRFFBTUFnQUxBQXNEUUNBSUlBSVFCeUFDUVJCcUlRSWdDRUVRYWlJSUlBTkpEUUFMQ3lBSFFSaHFFQVFhSUFzZ0RDQUxFQU1pQWhzaERDQUVJQVFnQzJvZ0Foc2hCQ0FGUVg5cUlnVU5BQXNnREJBRERRRkJiQ0VNSUFkQkdHb1FCRUVDU1EwQlFRQWhDQU5BSUFoQkEwY0VRQ0FBSUFoQkFuUWlBbXBCck5BQmFpQUNJQWRxS0FKRU5nSUFJQWhCQVdvaENBd0JDd3NnQnlnQ1hDRUlDMEc2ZnlFTUlBOGdDR3NpQUNBTklBUnJTdzBBSUFRRWZ5QUVJQWdnQUJBTElBQnFCVUVBQ3lBQmF5RU1DeUFIUWZBQWFpUUFJQXdMa1JjQ0ZuOEZmaU1BUWRBQmF5SUhKQUFnQnlBQUtBTHc0UUVpQ0RZQ3ZBRWdBU0FDYWlFU0lBZ2dBQ2dDZ09JQmFpRVRBa0FDUUNBRlJRUkFJQUVoQXd3QkN5QUFLQUxFNEFFaEVTQUFLQUxBNEFFaEZTQUFLQUs4NEFFaER5QUFRUUUyQW96aEFVRUFJUWdEUUNBSVFRTkhCRUFnQnlBSVFRSjBJZ0pxSUFBZ0FtcEJyTkFCYWlnQ0FEWUNWQ0FJUVFGcUlRZ01BUXNMSUFjZ0VUWUNaQ0FISUE4MkFtQWdCeUFCSUE5ck5nSm9RV3doRUNBSFFTaHFJQU1nQkJBR0VBTU5BU0FGUVFRZ0JVRUVTQnNoRnlBSFFUeHFJQWRCS0dvZ0FDZ0NBQkFUSUFkQnhBQnFJQWRCS0dvZ0FDZ0NDQkFUSUFkQnpBQnFJQWRCS0dvZ0FDZ0NCQkFUUVFBaEJDQUhRZUFBYWlFTUlBZEI1QUJxSVFvRFFDQUhRU2hxRUFSQkFrc2dCQ0FYVG5KRkJFQWdCeWdDUUNBSEtBSThRUU4wYWlrQ0FDSWRRaENJcDBIL0FYRWhDeUFIS0FKUUlBY29Ba3hCQTNScUtRSUFJaDVDRUlpblFmOEJjU0VKSUFjb0FrZ2dCeWdDUkVFRGRHb3BBZ0FpSDBJZ2lLY2hDQ0FlUWlDSUlTQWdIVUlnaUtjaEFnSkFJQjlDRUlpblFmOEJjU0lEUVFKUEJFQUNRQ0FHUlNBRFFSbEpja1VFUUNBSUlBZEJLR29nQTBFZ0lBY29BaXhySWcwZ0RTQURTeHNpRFJBRklBTWdEV3NpQTNScUlRZ2dCMEVvYWhBRUdpQURSUTBCSUFkQktHb2dBeEFGSUFocUlRZ01BUXNnQjBFb2FpQURFQVVnQ0dvaENDQUhRU2hxRUFRYUN5QUhLUUpVSVNFZ0J5QUlOZ0pVSUFjZ0lUY0RXQXdCQ3dKQUlBTkZCRUFnQWdSQUlBY29BbFFoQ0F3REN5QUhLQUpZSVFnTUFRc0NRQUpBSUFkQktHcEJBUkFGSUFnZ0FrVnFhaUlEUVFOR0JFQWdCeWdDVkVGL2FpSURJQU5GYWlFSURBRUxJQU5CQW5RZ0Iyb29BbFFpQ0NBSVJXb2hDQ0FEUVFGR0RRRUxJQWNnQnlnQ1dEWUNYQXNMSUFjZ0J5Z0NWRFlDV0NBSElBZzJBbFFMSUNDbklRTWdDUVJBSUFkQktHb2dDUkFGSUFOcUlRTUxJQWtnQzJwQkZFOEVRQ0FIUVNocUVBUWFDeUFMQkVBZ0IwRW9haUFMRUFVZ0Ftb2hBZ3NnQjBFb2FoQUVHaUFISUFjb0FtZ2dBbW9pQ1NBRGFqWUNhQ0FLSUF3Z0NDQUpTeHNvQWdBaERTQUhJQWRCS0dvZ0hVSVlpS2RCL3dGeEVBZ2dIYWRCLy84RGNXbzJBandnQnlBSFFTaHFJQjVDR0lpblFmOEJjUkFJSUI2blFmLy9BM0ZxTmdKTUlBZEJLR29RQkJvZ0IwRW9haUFmUWhpSXAwSC9BWEVRQ0NFT0lBZEI4QUJxSUFSQkJIUnFJZ3NnQ1NBTmFpQUlhellDRENBTElBZzJBZ2dnQ3lBRE5nSUVJQXNnQWpZQ0FDQUhJQTRnSDZkQi8vOERjV28yQWtRZ0JFRUJhaUVFREFFTEN5QUVJQmRJRFFFZ0VrRmdhaUVZSUFkQjRBQnFJUm9nQjBIa0FHb2hHeUFCSVFNRFFDQUhRU2hxRUFSQkFrc2dCQ0FGVG5KRkJFQWdCeWdDUUNBSEtBSThRUU4wYWlrQ0FDSWRRaENJcDBIL0FYRWhDeUFIS0FKUUlBY29Ba3hCQTNScUtRSUFJaDVDRUlpblFmOEJjU0VJSUFjb0FrZ2dCeWdDUkVFRGRHb3BBZ0FpSDBJZ2lLY2hDU0FlUWlDSUlTQWdIVUlnaUtjaERBSkFJQjlDRUlpblFmOEJjU0lDUVFKUEJFQUNRQ0FHUlNBQ1FSbEpja1VFUUNBSklBZEJLR29nQWtFZ0lBY29BaXhySWdvZ0NpQUNTeHNpQ2hBRklBSWdDbXNpQW5ScUlRa2dCMEVvYWhBRUdpQUNSUTBCSUFkQktHb2dBaEFGSUFscUlRa01BUXNnQjBFb2FpQUNFQVVnQ1dvaENTQUhRU2hxRUFRYUN5QUhLUUpVSVNFZ0J5QUpOZ0pVSUFjZ0lUY0RXQXdCQ3dKQUlBSkZCRUFnREFSQUlBY29BbFFoQ1F3REN5QUhLQUpZSVFrTUFRc0NRQUpBSUFkQktHcEJBUkFGSUFrZ0RFVnFhaUlDUVFOR0JFQWdCeWdDVkVGL2FpSUNJQUpGYWlFSkRBRUxJQUpCQW5RZ0Iyb29BbFFpQ1NBSlJXb2hDU0FDUVFGR0RRRUxJQWNnQnlnQ1dEWUNYQXNMSUFjZ0J5Z0NWRFlDV0NBSElBazJBbFFMSUNDbklSUWdDQVJBSUFkQktHb2dDQkFGSUJScUlSUUxJQWdnQzJwQkZFOEVRQ0FIUVNocUVBUWFDeUFMQkVBZ0IwRW9haUFMRUFVZ0RHb2hEQXNnQjBFb2FoQUVHaUFISUFjb0FtZ2dER29pR1NBVWFqWUNhQ0FiSUJvZ0NTQVpTeHNvQWdBaEhDQUhJQWRCS0dvZ0hVSVlpS2RCL3dGeEVBZ2dIYWRCLy84RGNXbzJBandnQnlBSFFTaHFJQjVDR0lpblFmOEJjUkFJSUI2blFmLy9BM0ZxTmdKTUlBZEJLR29RQkJvZ0J5QUhRU2hxSUI5Q0dJaW5RZjhCY1JBSUlCK25RZi8vQTNGcU5nSkVJQWNnQjBId0FHb2dCRUVEY1VFRWRHb2lEU2tEQ0NJZE53UElBU0FISUEwcEF3QWlIamNEd0FFQ1FBSkFBa0FnQnlnQ3ZBRWlEaUFlcHlJQ2FpSVdJQk5MRFFBZ0F5QUhLQUxFQVNJS0lBSnFJZ3RxSUJoTERRQWdFaUFEYXlBTFFTQnFUdzBCQ3lBSElBY3BBOGdCTndNUUlBY2dCeWtEd0FFM0F3Z2dBeUFTSUFkQkNHb2dCMEc4QVdvZ0V5QVBJQlVnRVJBZUlRc01BUXNnQWlBRGFpRUlJQU1nRGhBSElBSkJFVThFUUNBRFFSQnFJUUlEUUNBQ0lBNUJFR29pRGhBSElBSkJFR29pQWlBSVNRMEFDd3NnQ0NBZHB5SU9heUVDSUFjZ0ZqWUN2QUVnRGlBSUlBOXJTd1JBSUE0Z0NDQVZhMHNFUUVGc0lRc01BZ3NnRVNBQ0lBOXJJZ0pxSWhZZ0Ntb2dFVTBFUUNBSUlCWWdDaEFQR2d3Q0N5QUlJQlpCQUNBQ2F4QVBJUWdnQnlBQ0lBcHFJZ28yQXNRQklBZ2dBbXNoQ0NBUElRSUxJQTVCRUU4RVFDQUlJQXBxSVFvRFFDQUlJQUlRQnlBQ1FSQnFJUUlnQ0VFUWFpSUlJQXBKRFFBTERBRUxBa0FnRGtFSFRRUkFJQWdnQWkwQUFEb0FBQ0FJSUFJdEFBRTZBQUVnQ0NBQ0xRQUNPZ0FDSUFnZ0FpMEFBem9BQXlBSVFRUnFJQUlnRGtFQ2RDSUtRY0FlYWlnQ0FHb2lBaEFYSUFJZ0NrSGdIbW9vQWdCcklRSWdCeWdDeEFFaENnd0JDeUFJSUFJUURBc2dDa0VKU1EwQUlBZ2dDbW9oQ2lBSVFRaHFJZ2dnQWtFSWFpSUNhMEVQVEFSQUEwQWdDQ0FDRUF3Z0FrRUlhaUVDSUFoQkNHb2lDQ0FLU1EwQURBSUFDd0FMQTBBZ0NDQUNFQWNnQWtFUWFpRUNJQWhCRUdvaUNDQUtTUTBBQ3dzZ0N4QURCRUFnQ3lFUURBUUZJQTBnRERZQ0FDQU5JQmtnSEdvZ0NXczJBZ3dnRFNBSk5nSUlJQTBnRkRZQ0JDQUVRUUZxSVFRZ0F5QUxhaUVEREFJTEFBc0xJQVFnQlVnTkFTQUVJQmRySVF0QkFDRUVBMEFnQ3lBRlNBUkFJQWNnQjBId0FHb2dDMEVEY1VFRWRHb2lBaWtEQ0NJZE53UElBU0FISUFJcEF3QWlIamNEd0FFQ1FBSkFBa0FnQnlnQ3ZBRWlEQ0FlcHlJQ2FpSUtJQk5MRFFBZ0F5QUhLQUxFQVNJSklBSnFJaEJxSUJoTERRQWdFaUFEYXlBUVFTQnFUdzBCQ3lBSElBY3BBOGdCTndNZ0lBY2dCeWtEd0FFM0F4Z2dBeUFTSUFkQkdHb2dCMEc4QVdvZ0V5QVBJQlVnRVJBZUlSQU1BUXNnQWlBRGFpRUlJQU1nREJBSElBSkJFVThFUUNBRFFSQnFJUUlEUUNBQ0lBeEJFR29pREJBSElBSkJFR29pQWlBSVNRMEFDd3NnQ0NBZHB5SUdheUVDSUFjZ0NqWUN2QUVnQmlBSUlBOXJTd1JBSUFZZ0NDQVZhMHNFUUVGc0lSQU1BZ3NnRVNBQ0lBOXJJZ0pxSWd3Z0NXb2dFVTBFUUNBSUlBd2dDUkFQR2d3Q0N5QUlJQXhCQUNBQ2F4QVBJUWdnQnlBQ0lBbHFJZ2syQXNRQklBZ2dBbXNoQ0NBUElRSUxJQVpCRUU4RVFDQUlJQWxxSVFZRFFDQUlJQUlRQnlBQ1FSQnFJUUlnQ0VFUWFpSUlJQVpKRFFBTERBRUxBa0FnQmtFSFRRUkFJQWdnQWkwQUFEb0FBQ0FJSUFJdEFBRTZBQUVnQ0NBQ0xRQUNPZ0FDSUFnZ0FpMEFBem9BQXlBSVFRUnFJQUlnQmtFQ2RDSUdRY0FlYWlnQ0FHb2lBaEFYSUFJZ0JrSGdIbW9vQWdCcklRSWdCeWdDeEFFaENRd0JDeUFJSUFJUURBc2dDVUVKU1EwQUlBZ2dDV29oQmlBSVFRaHFJZ2dnQWtFSWFpSUNhMEVQVEFSQUEwQWdDQ0FDRUF3Z0FrRUlhaUVDSUFoQkNHb2lDQ0FHU1EwQURBSUFDd0FMQTBBZ0NDQUNFQWNnQWtFUWFpRUNJQWhCRUdvaUNDQUdTUTBBQ3dzZ0VCQUREUU1nQzBFQmFpRUxJQU1nRUdvaEF3d0JDd3NEUUNBRVFRTkhCRUFnQUNBRVFRSjBJZ0pxUWF6UUFXb2dBaUFIYWlnQ1ZEWUNBQ0FFUVFGcUlRUU1BUXNMSUFjb0Fyd0JJUWdMUWJwL0lSQWdFeUFJYXlJQUlCSWdBMnRMRFFBZ0F3Ui9JQU1nQ0NBQUVBc2dBR29GUVFBTElBRnJJUkFMSUFkQjBBRnFKQUFnRUFzbEFDQUFRZ0EzQWdBZ0FFRUFPd0VJSUFCQkFEb0FDeUFBSUFFMkFnd2dBQ0FDT2dBS0M3UUZBUU4vSXdCQk1Hc2lCQ1FBSUFCQi93RnFJZ1ZCZldvaEJnSkFJQU12QVFJRVFDQUVRUmhxSUFFZ0FoQUdJZ0lRQXcwQklBUkJFR29nQkVFWWFpQURFQndnQkVFSWFpQUVRUmhxSUFNUUhDQUFJUU1EUUFKQUlBUkJHR29RQkNBRElBWlBja1VFUUNBRElBUkJFR29nQkVFWWFoQVNPZ0FBSUFNZ0JFRUlhaUFFUVJocUVCSTZBQUVnQkVFWWFoQUVSUTBCSUFOQkFtb2hBd3NnQlVGK2FpRUZBbjhEUUVHNmZ5RUNJQU1pQVNBRlN3MEZJQUVnQkVFUWFpQUVRUmhxRUJJNkFBQWdBVUVCYWlFRElBUkJHR29RQkVFRFJnUkFRUUloQWlBRVFRaHFEQUlMSUFNZ0JVc05CU0FCSUFSQkNHb2dCRUVZYWhBU09nQUJJQUZCQW1vaEEwRURJUUlnQkVFWWFoQUVRUU5IRFFBTElBUkJFR29MSVFVZ0F5QUZJQVJCR0dvUUVqb0FBQ0FCSUFKcUlBQnJJUUlNQXdzZ0F5QUVRUkJxSUFSQkdHb1FFam9BQWlBRElBUkJDR29nQkVFWWFoQVNPZ0FESUFOQkJHb2hBd3dBQUFzQUN5QUVRUmhxSUFFZ0FoQUdJZ0lRQXcwQUlBUkJFR29nQkVFWWFpQURFQndnQkVFSWFpQUVRUmhxSUFNUUhDQUFJUU1EUUFKQUlBUkJHR29RQkNBRElBWlBja1VFUUNBRElBUkJFR29nQkVFWWFoQVJPZ0FBSUFNZ0JFRUlhaUFFUVJocUVCRTZBQUVnQkVFWWFoQUVSUTBCSUFOQkFtb2hBd3NnQlVGK2FpRUZBbjhEUUVHNmZ5RUNJQU1pQVNBRlN3MEVJQUVnQkVFUWFpQUVRUmhxRUJFNkFBQWdBVUVCYWlFRElBUkJHR29RQkVFRFJnUkFRUUloQWlBRVFRaHFEQUlMSUFNZ0JVc05CQ0FCSUFSQkNHb2dCRUVZYWhBUk9nQUJJQUZCQW1vaEEwRURJUUlnQkVFWWFoQUVRUU5IRFFBTElBUkJFR29MSVFVZ0F5QUZJQVJCR0dvUUVUb0FBQ0FCSUFKcUlBQnJJUUlNQWdzZ0F5QUVRUkJxSUFSQkdHb1FFVG9BQWlBRElBUkJDR29nQkVFWWFoQVJPZ0FESUFOQkJHb2hBd3dBQUFzQUN5QUVRVEJxSkFBZ0FndHBBUUYvQW44Q1FBSkFJQUpCQjAwTkFDQUJLQUFBUWJmSXd1RitSdzBBSUFBZ0FTZ0FCRFlDbU9JQlFXSWdBRUVRYWlBQklBSVFQaUlERUFNTkFob2dBRUtCZ0lDQUVEY0RpT0VCSUFBZ0FTQURhaUFDSUFOckVDb01BUXNnQUNBQklBSVFLZ3RCQUFzTHJRTUJCbjhqQUVHQUFXc2lBeVFBUVdJaENBSkFJQUpCQ1VrTkFDQUFRWmpRQUdvZ0FVRUlhaUlFSUFKQmVHb2dBRUdZMEFBUU15SUZFQU1pQmcwQUlBTkJIellDZkNBRElBTkIvQUJxSUFOQitBQnFJQVFnQkNBRmFpQUdHeUlFSUFFZ0Ftb2lBaUFFYXhBVklnVVFBdzBBSUFNb0Fud2lCa0VmU3cwQUlBTW9BbmdpQjBFSlR3MEFJQUJCaUNCcUlBTWdCa0dBQzBHQURDQUhFQmdnQTBFME5nSjhJQU1nQTBIOEFHb2dBMEg0QUdvZ0JDQUZhaUlFSUFJZ0JHc1FGU0lGRUFNTkFDQURLQUo4SWdaQk5Fc05BQ0FES0FKNElnZEJDazhOQUNBQVFaQXdhaUFESUFaQmdBMUI0QTRnQnhBWUlBTkJJellDZkNBRElBTkIvQUJxSUFOQitBQnFJQVFnQldvaUJDQUNJQVJyRUJVaUJSQUREUUFnQXlnQ2ZDSUdRU05MRFFBZ0F5Z0NlQ0lIUVFwUERRQWdBQ0FESUFaQndCQkIwQkVnQnhBWUlBUWdCV29pQkVFTWFpSUZJQUpMRFFBZ0FpQUZheUVGUVFBaEFnTkFJQUpCQTBjRVFDQUVLQUFBSWdaQmYyb2dCVThOQWlBQUlBSkJBblJxUVp6UUFXb2dCallDQUNBQ1FRRnFJUUlnQkVFRWFpRUVEQUVMQ3lBRUlBRnJJUWdMSUFOQmdBRnFKQUFnQ0F0R0FRTi9JQUJCQ0dvaEF5QUFLQUlFSVFKQkFDRUFBMEFnQUNBQ2RrVUVRQ0FCSUFNZ0FFRURkR290QUFKQkZrdHFJUUVnQUVFQmFpRUFEQUVMQ3lBQlFRZ2dBbXQwQzRZREFRVi9RYmgvSVFjQ1FDQURSUTBBSUFJdEFBQWlCRVVFUUNBQlFRQTJBZ0JCQVVHNGZ5QURRUUZHR3c4TEFuOGdBa0VCYWlJRklBUkJHSFJCR0hVaUJrRi9TZzBBR2lBR1FYOUdCRUFnQTBFRFNBMENJQVV2QUFCQmdQNEJhaUVFSUFKQkEyb01BUXNnQTBFQ1NBMEJJQUl0QUFFZ0JFRUlkSEpCZ0lCK2FpRUVJQUpCQW1vTElRVWdBU0FFTmdJQUlBVkJBV29pQVNBQ0lBTnFJZ05MRFFCQmJDRUhJQUJCRUdvZ0FDQUZMUUFBSWdWQkJuWkJJMEVKSUFFZ0F5QUJhMEhBRUVIUUVVSHdFaUFBS0FLTTRRRWdBQ2dDbk9JQklBUVFIeUlHRUFNaUNBMEFJQUJCbUNCcUlBQkJDR29nQlVFRWRrRURjVUVmUVFnZ0FTQUJJQVpxSUFnYklnRWdBeUFCYTBHQUMwR0FERUdBRnlBQUtBS000UUVnQUNnQ25PSUJJQVFRSHlJR0VBTWlDQTBBSUFCQm9EQnFJQUJCQkdvZ0JVRUNka0VEY1VFMFFRa2dBU0FCSUFacUlBZ2JJZ0VnQXlBQmEwR0FEVUhnRGtHUUdTQUFLQUtNNFFFZ0FDZ0NuT0lCSUFRUUh5SUFFQU1OQUNBQUlBRnFJQUpySVFjTElBY0xyUU1CQ244akFFR0FCR3NpQ0NRQUFuOUJVaUFDUWY4QlN3MEFHa0ZVSUFOQkRFc05BQm9nQWtFQmFpRUxJQUJCQkdvaENVR0FnQVFnQTBGL2FuUkJFSFVoQ2tFQUlRSkJBU0VFUVFFZ0EzUWlCMEYvYWlJTUlRVURRQ0FDSUF0R1JRUkFBa0FnQVNBQ1FRRjBJZzFxTHdFQUlnWkIvLzhEUmdSQUlBa2dCVUVDZEdvZ0Fqb0FBaUFGUVg5cUlRVkJBU0VHREFFTElBUkJBQ0FLSUFaQkVIUkJFSFZLR3lFRUN5QUlJQTFxSUFZN0FRQWdBa0VCYWlFQ0RBRUxDeUFBSUFRN0FRSWdBQ0FET3dFQUlBZEJBM1lnQjBFQmRtcEJBMm9oQmtFQUlRUkJBQ0VDQTBBZ0JDQUxSa1VFUUNBQklBUkJBWFJxTGdFQUlRcEJBQ0VBQTBBZ0FDQUtUa1VFUUNBSklBSkJBblJxSUFRNkFBSURRQ0FDSUFacUlBeHhJZ0lnQlVzTkFBc2dBRUVCYWlFQURBRUxDeUFFUVFGcUlRUU1BUXNMUVg4Z0FnMEFHa0VBSVFJRGZ5QUNJQWRHQkg5QkFBVWdDQ0FKSUFKQkFuUnFJZ0F0QUFKQkFYUnFJZ0VnQVM4QkFDSUJRUUZxT3dFQUlBQWdBeUFCRUJScklnVTZBQU1nQUNBQklBVkIvd0Z4ZENBSGF6c0JBQ0FDUVFGcUlRSU1BUXNMQ3lFRklBaEJnQVJxSkFBZ0JRdmpCZ0VJZjBGc0lRY0NRQ0FDUVFOSkRRQUNRQUpBQWtBQ1FDQUJMUUFBSWdOQkEzRWlDVUVCYXc0REF3RUFBZ3NnQUNnQ2lPRUJEUUJCWWc4TElBSkJCVWtOQWtFRElRWWdBU2dBQUNFRkFuOENRQUpBSUFOQkFuWkJBM0VpQ0VGK2FpSUVRUUZOQkVBZ0JFRUJhdzBCREFJTElBVkJEblpCL3dkeElRUWdCVUVFZGtIL0IzRWhBeUFJUlF3Q0N5QUZRUkoySVFSQkJDRUdJQVZCQkhaQi8vOEFjU0VEUVFBTUFRc2dCVUVFZGtILy93OXhJZ05CZ0lBSVN3MERJQUV0QUFSQkNuUWdCVUVXZG5JaEJFRUZJUVpCQUFzaEJTQUVJQVpxSWdvZ0Frc05BZ0pBSUFOQmdRWkpEUUFnQUNnQ25PSUJSUTBBUVFBaEFnTkFJQUpCZzRBQlN3MEJJQUpCUUdzaEFnd0FBQXNBQ3dKL0lBbEJBMFlFUUNBQklBWnFJUUVnQUVIdzRnRnFJUUlnQUNnQ0RDRUdJQVVFUUNBQ0lBTWdBU0FFSUFZUVh3d0NDeUFDSUFNZ0FTQUVJQVlRWFF3QkN5QUFRYmpRQVdvaEFpQUJJQVpxSVFFZ0FFSHc0Z0ZxSVFZZ0FFR28wQUJxSVFnZ0JRUkFJQWdnQmlBRElBRWdCQ0FDRUY0TUFRc2dDQ0FHSUFNZ0FTQUVJQUlRWEFzUUF3MENJQUFnQXpZQ2dPSUJJQUJCQVRZQ2lPRUJJQUFnQUVIdzRnRnFOZ0x3NFFFZ0NVRUNSZ1JBSUFBZ0FFR28wQUJxTmdJTUN5QUFJQU5xSWdCQmlPTUJha0lBTndBQUlBQkJnT01CYWtJQU53QUFJQUJCK09JQmFrSUFOd0FBSUFCQjhPSUJha0lBTndBQUlBb1BDd0ovQWtBQ1FBSkFJQU5CQW5aQkEzRkJmMm9pQkVFQ1N3MEFJQVJCQVdzT0FnQUNBUXRCQVNFRUlBTkJBM1lNQWd0QkFpRUVJQUV2QUFCQkJIWU1BUXRCQXlFRUlBRVFJVUVFZGdzaUF5QUVhaUlGUVNCcUlBSkxCRUFnQlNBQ1N3MENJQUJCOE9JQmFpQUJJQVJxSUFNUUN5RUJJQUFnQXpZQ2dPSUJJQUFnQVRZQzhPRUJJQUVnQTJvaUFFSUFOd0FZSUFCQ0FEY0FFQ0FBUWdBM0FBZ2dBRUlBTndBQUlBVVBDeUFBSUFNMkFvRGlBU0FBSUFFZ0JHbzJBdkRoQVNBRkR3c0Nmd0pBQWtBQ1FDQURRUUoyUVFOeFFYOXFJZ1JCQWtzTkFDQUVRUUZyRGdJQUFnRUxRUUVoQnlBRFFRTjJEQUlMUVFJaEJ5QUJMd0FBUVFSMkRBRUxJQUpCQkVrZ0FSQWhJZ0pCajRDQUFVdHlEUUZCQXlFSElBSkJCSFlMSVFJZ0FFSHc0Z0ZxSUFFZ0Iyb3RBQUFnQWtFZ2FoQVFJUUVnQUNBQ05nS0E0Z0VnQUNBQk5nTHc0UUVnQjBFQmFpRUhDeUFIQzBzQUlBQkMrZXJRME9mSm9lVGhBRGNESUNBQVFnQTNBeGdnQUVMUDF0Tyswc2VyMlVJM0F4QWdBRUxXNjRMdTZ2Mko5ZUFBTndNSUlBQkNBRGNEQUNBQVFTaHFRUUJCS0JBUUdndmlBZ0lDZndWK0lBQkJLR29pQVNBQUtBSklhaUVDQW40Z0FDa0RBQ0lEUWlCYUJFQWdBQ2tERUNJRVFnZUpJQUFwQXdnaUJVSUJpWHdnQUNrREdDSUdRZ3lKZkNBQUtRTWdJZ2RDRW9sOElBVVFHU0FFRUJrZ0JoQVpJQWNRR1F3QkN5QUFLUU1ZUXNYUDJiTHg1YnJxSjN3TElBTjhJUU1EUUNBQlFRaHFJZ0FnQWswRVFFSUFJQUVwQUFBUUNTQURoVUliaVVLSGxhK3ZtTGJlbTU1L2ZrTGozTXFWL003eTlZVi9mQ0VESUFBaEFRd0JDd3NDUUNBQlFRUnFJZ0FnQWtzRVFDQUJJUUFNQVFzZ0FTZ0FBSzFDaDVXdnI1aTIzcHVlZjM0Z0E0VkNGNGxDejliVHZ0TEhxOWxDZmtMNTg5M3htZmFacXhaOElRTUxBMEFnQUNBQ1NRUkFJQUF4QUFCQ3hjL1pzdkhsdXVvbmZpQURoVUlMaVVLSGxhK3ZtTGJlbTU1L2ZpRURJQUJCQVdvaEFBd0JDd3NnQTBJaGlDQURoVUxQMXRPKzBzZXIyVUorSWdOQ0hZZ2dBNFZDK2ZQZDhabjJtYXNXZmlJRFFpQ0lJQU9GQys4Q0FnSi9CSDRnQUNBQUtRTUFJQUt0ZkRjREFBSkFBa0FnQUNnQ1NDSURJQUpxSWdSQkgwMEVRQ0FCUlEwQklBQWdBMnBCS0dvZ0FTQUNFQ0FnQUNnQ1NDQUNhaUVFREFFTElBRWdBbW9oQWdKL0lBTUVRQ0FBUVNocUlnUWdBMm9nQVVFZ0lBTnJFQ0FnQUNBQUtRTUlJQVFwQUFBUUNUY0RDQ0FBSUFBcEF4QWdBQ2tBTUJBSk53TVFJQUFnQUNrREdDQUFLUUE0RUFrM0F4Z2dBQ0FBS1FNZ0lBQkJRR3NwQUFBUUNUY0RJQ0FBS0FKSUlRTWdBRUVBTmdKSUlBRWdBMnRCSUdvaEFRc2dBVUVnYWlBQ1RRc0VRQ0FDUVdCcUlRTWdBQ2tESUNFRklBQXBBeGdoQmlBQUtRTVFJUWNnQUNrRENDRUlBMEFnQ0NBQktRQUFFQWtoQ0NBSElBRXBBQWdRQ1NFSElBWWdBU2tBRUJBSklRWWdCU0FCS1FBWUVBa2hCU0FCUVNCcUlnRWdBMDBOQUFzZ0FDQUZOd01nSUFBZ0JqY0RHQ0FBSUFjM0F4QWdBQ0FJTndNSUN5QUJJQUpQRFFFZ0FFRW9haUFCSUFJZ0FXc2lCQkFnQ3lBQUlBUTJBa2dMQ3k4QkFYOGdBRVVFUUVHMmYwRUFJQU1iRHd0QnVuOGhCQ0FESUFGTkJIOGdBQ0FDSUFNUUVCb2dBd1ZCdW44TEN5OEJBWDhnQUVVRVFFRzJmMEVBSUFNYkR3dEJ1bjhoQkNBRElBRk5CSDhnQUNBQ0lBTVFDeG9nQXdWQnVuOExDNmdDQVFaL0l3QkJFR3NpQnlRQUlBQkIyT0FCYWlrREFFS0FnSUFRVmlFSVFiaC9JUVVDUUNBRVFmLy9CMHNOQUNBQUlBTWdCQkJDSWdVUUF5SUdEUUFnQUNnQ25PSUJJUWtnQUNBSFFReHFJQU1nQXlBRmFpQUdHeUlLSUFSQkFDQUZJQVliYXlJR0VFQWlBeEFEQkVBZ0F5RUZEQUVMSUFjb0Fnd2hCQ0FCUlFSQVFicC9JUVVnQkVFQVNnMEJDeUFHSUFOcklRVWdBeUFLYWlFREFrQWdDUVJBSUFCQkFEWUNuT0lCREFFTEFrQUNRQUpBSUFSQkJVZ05BQ0FBUWRqZ0FXb3BBd0JDZ0lDQUNGZ05BQXdCQ3lBQVFRQTJBcHppQVF3QkN5QUFLQUlJRUQ4aEJpQUFRUUEyQXB6aUFTQUdRUlJQRFFFTElBQWdBU0FDSUFNZ0JTQUVJQWdRT1NFRkRBRUxJQUFnQVNBQ0lBTWdCU0FFSUFnUU9pRUZDeUFIUVJCcUpBQWdCUXRuQUNBQVFkRGdBV29nQVNBQ0lBQW9BdXpoQVJBdUlnRVFBd1JBSUFFUEMwRzRmeUVDQWtBZ0FRMEFJQUJCN09BQmFpZ0NBQ0lCQkVCQllDRUNJQUFvQXBqaUFTQUJSdzBCQzBFQUlRSWdBRUh3NEFGcUtBSUFSUTBBSUFCQmtPRUJhaEJEQ3lBQ0N5Y0JBWDhRVnlJRVJRUkFRVUFQQ3lBRUlBQWdBU0FDSUFNZ0JCQkxFRThoQUNBRUVGWWdBQXMvQVFGL0FrQUNRQUpBSUFBb0FxRGlBVUVCYWlJQlFRSkxEUUFnQVVFQmF3NENBQUVDQ3lBQUVEQkJBQThMSUFCQkFEWUNvT0lCQ3lBQUtBS1U0Z0VMdkFNQ0IzOEJmaU1BUVJCcklna2tBRUc0ZnlFR0FrQWdCQ2dDQUNJSVFRVkJDU0FBS0FMczRRRWlCUnRKRFFBZ0F5Z0NBQ0lIUVFGQkJTQUZHeUFGRUM4aUJSQURCRUFnQlNFR0RBRUxJQWdnQlVFRGFra05BQ0FBSUFjZ0JSQkpJZ1lRQXcwQUlBRWdBbW9oQ2lBQVFaRGhBV29oQ3lBSUlBVnJJUUlnQlNBSGFpRUhJQUVoQlFOQUlBY2dBaUFKRUN3aUJoQUREUUVnQWtGOWFpSUNJQVpKQkVCQnVIOGhCZ3dDQ3lBSktBSUFJZ2hCQWtzRVFFRnNJUVlNQWdzZ0IwRURhaUVIQW44Q1FBSkFBa0FnQ0VFQmF3NENBZ0FCQ3lBQUlBVWdDaUFGYXlBSElBWVFTQXdDQ3lBRklBb2dCV3NnQnlBR0VFY01BUXNnQlNBS0lBVnJJQWN0QUFBZ0NTZ0NDQkJHQ3lJSUVBTUVRQ0FJSVFZTUFnc2dBQ2dDOE9BQkJFQWdDeUFGSUFnUVJRc2dBaUFHYXlFQ0lBWWdCMm9oQnlBRklBaHFJUVVnQ1NnQ0JFVU5BQXNnQUNrRDBPQUJJZ3hDZjFJRVFFRnNJUVlnRENBRklBRnJyRklOQVFzZ0FDZ0M4T0FCQkVCQmFpRUdJQUpCQkVrTkFTQUxFRVFoRENBSEtBQUFJQXluUncwQklBZEJCR29oQnlBQ1FYeHFJUUlMSUFNZ0J6WUNBQ0FFSUFJMkFnQWdCU0FCYXlFR0N5QUpRUkJxSkFBZ0Jnc3VBQ0FBRUNzQ2YwRUFRUUFRQXcwQUdpQUJSU0FDUlhKRkJFQkJZaUFBSUFFZ0FoQTlFQU1OQVJvTFFRQUxDemNBSUFFRVFDQUFJQUFvQXNUZ0FTQUJLQUlFSUFFb0FnaHFSellDbk9JQkN5QUFFQ3RCQUJBRElBRkZja1VFUUNBQUlBRVFXd3NMMFFJQkIzOGpBRUVRYXlJR0pBQWdCaUFFTmdJSUlBWWdBellDRENBRkJFQWdCU2dDQkNFS0lBVW9BZ2doQ1FzZ0FTRUlBa0FDUUFOQUlBQW9BdXpoQVJBV0lRc0NRQU5BSUFRZ0Mwa05BU0FES0FBQVFYQnhRZERVdE1JQlJnUkFJQU1nQkJBaUlnY1FBdzBFSUFRZ0Iyc2hCQ0FESUFkcUlRTU1BUXNMSUFZZ0F6WUNEQ0FHSUFRMkFnZ0NRQ0FGQkVBZ0FDQUZFRTVCQUNFSFFRQVFBMFVOQVF3RkN5QUFJQW9nQ1JCTklnY1FBdzBFQ3lBQUlBZ1FVQ0FNUVFGSFFRQWdBQ0FJSUFJZ0JrRU1haUFHUVFocUVFd2lCeUlEYTBFQUlBTVFBeHRCQ2tkeVJRUkFRYmgvSVFjTUJBc2dCeEFERFFNZ0FpQUhheUVDSUFjZ0NHb2hDRUVCSVF3Z0JpZ0NEQ0VESUFZb0FnZ2hCQXdCQ3dzZ0JpQUROZ0lNSUFZZ0JEWUNDRUc0ZnlFSElBUU5BU0FJSUFGcklRY01BUXNnQmlBRE5nSU1JQVlnQkRZQ0NBc2dCa0VRYWlRQUlBY0xSZ0VDZnlBQklBQW9BcmpnQVNJQ1J3UkFJQUFnQWpZQ3hPQUJJQUFnQVRZQ3VPQUJJQUFvQXJ6Z0FTRURJQUFnQVRZQ3ZPQUJJQUFnQVNBRElBSnJhallDd09BQkN3dXRBZ0lFZndGK0l3QkJRR29pQkNRQUFrQUNRQ0FDUVFoSkRRQWdBU2dBQUVGd2NVSFExTFRDQVVjTkFDQUJJQUlRSWlFQklBQkNBRGNEQ0NBQVFRQTJBZ1FnQUNBQk5nSUFEQUVMSUFSQkdHb2dBU0FDRUMwaUF4QURCRUFnQUNBREVCb01BUXNnQXdSQUlBQkJ1SDhRR2d3QkN5QUNJQVFvQWpBaUEyc2hBaUFCSUFOcUlRTURRQUpBSUFBZ0F5QUNJQVJCQ0dvUUxDSUZFQU1FZnlBRkJTQUNJQVZCQTJvaUJVOE5BVUc0ZndzUUdnd0NDeUFHUVFGcUlRWWdBaUFGYXlFQ0lBTWdCV29oQXlBRUtBSU1SUTBBQ3lBRUtBSTRCRUFnQWtFRFRRUkFJQUJCdUg4UUdnd0NDeUFEUVFScUlRTUxJQVFvQWlnaEFpQUVLUU1ZSVFjZ0FFRUFOZ0lFSUFBZ0F5QUJhellDQUNBQUlBSWdCbXl0SUFjZ0IwSi9VUnMzQXdnTElBUkJRR3NrQUFzbEFRRi9Jd0JCRUdzaUFpUUFJQUlnQUNBQkVGRWdBaWdDQUNFQUlBSkJFR29rQUNBQUMzMEJCSDhqQUVHUUJHc2lCQ1FBSUFSQi93RTJBZ2dDUUNBRVFSQnFJQVJCQ0dvZ0JFRU1haUFCSUFJUUZTSUdFQU1FUUNBR0lRVU1BUXRCVkNFRklBUW9BZ3dpQjBFR1N3MEFJQU1nQkVFUWFpQUVLQUlJSUFjUVFTSUZFQU1OQUNBQUlBRWdCbW9nQWlBR2F5QURFRHdoQlFzZ0JFR1FCR29rQUNBRkM0Y0JBZ0ovQW41QkFCQVdJUU1DUUFOQUlBRWdBMDhFUUFKQUlBQW9BQUJCY0hGQjBOUzB3Z0ZHQkVBZ0FDQUJFQ0lpQWhBRFJRMEJRbjRQQ3lBQUlBRVFWU0lFUW4xV0RRTWdCQ0FGZkNJRklBUlVJUUpDZmlFRUlBSU5BeUFBSUFFUVVpSUNFQU1OQXdzZ0FTQUNheUVCSUFBZ0Ftb2hBQXdCQ3d0Q2ZpQUZJQUViSVFRTElBUUxQd0lCZndGK0l3QkJNR3NpQWlRQUFuNUNmaUFDUVFocUlBQWdBUkF0RFFBYVFnQWdBaWdDSEVFQlJnMEFHaUFDS1FNSUN5RURJQUpCTUdva0FDQURDNDBCQVFKL0l3QkJNR3NpQVNRQUFrQWdBRVVOQUNBQUtBS0k0Z0VOQUNBQklBQkIvT0VCYWlnQ0FEWUNLQ0FCSUFBcEF2VGhBVGNESUNBQUVEQWdBQ2dDcU9JQklRSWdBU0FCS0FJb05nSVlJQUVnQVNrRElEY0RFQ0FDSUFGQkVHb1FHeUFBUVFBMkFxamlBU0FCSUFFb0FpZzJBZ2dnQVNBQktRTWdOd01BSUFBZ0FSQWJDeUFCUVRCcUpBQUxLZ0VDZnlNQVFSQnJJZ0FrQUNBQVFRQTJBZ2dnQUVJQU53TUFJQUFRV0NFQklBQkJFR29rQUNBQkM0Y0JBUU4vSXdCQkVHc2lBaVFBQWtBZ0FDZ0NBRVVnQUNnQ0JFVnpEUUFnQWlBQUtBSUlOZ0lJSUFJZ0FDa0NBRGNEQUFKL0lBSW9BZ0FpQVFSQUlBSW9BZ2hCcU9NSklBRVJCUUFNQVF0QnFPTUpFQ2dMSWdGRkRRQWdBU0FBS1FJQU53TDA0UUVnQVVIODRRRnFJQUFvQWdnMkFnQWdBUkJaSUFFaEF3c2dBa0VRYWlRQUlBTUx5d0VCQW44akFFRWdheUlCSkFBZ0FFR0JnSURBQURZQ3RPSUJJQUJCQURZQ2lPSUJJQUJCQURZQzdPRUJJQUJDQURjRGtPSUJJQUJCQURZQ3BPTUpJQUJCQURZQzNPSUJJQUJDQURjQ3pPSUJJQUJCQURZQ3ZPSUJJQUJCQURZQ3hPQUJJQUJDQURjQ25PSUJJQUJCcE9JQmFrSUFOd0lBSUFCQnJPSUJha0VBTmdJQUlBRkNBRGNDRUNBQlFnQTNBaGdnQVNBQktRTVlOd01JSUFFZ0FTa0RFRGNEQUNBQktBSUlRUWgyUVFGeElRSWdBRUVBTmdMZzRnRWdBQ0FDTmdLTTRnRWdBVUVnYWlRQUMzWUJBMzhqQUVFd2F5SUJKQUFnQUFSQUlBRWdBRUhFMEFGcUlnSW9BZ0EyQWlnZ0FTQUFLUUs4MEFFM0F5QWdBQ2dDQUNFRElBRWdBaWdDQURZQ0dDQUJJQUFwQXJ6UUFUY0RFQ0FESUFGQkVHb1FHeUFCSUFFb0FpZzJBZ2dnQVNBQktRTWdOd01BSUFBZ0FSQWJDeUFCUVRCcUpBQUx6QUVCQVg4Z0FDQUJLQUswMEFFMkFwamlBU0FBSUFFb0FnUWlBallDd09BQklBQWdBallDdk9BQklBQWdBaUFCS0FJSWFpSUNOZ0s0NEFFZ0FDQUNOZ0xFNEFFZ0FTZ0N1TkFCQkVBZ0FFS0JnSUNBRURjRGlPRUJJQUFnQVVHazBBQnFOZ0lNSUFBZ0FVR1VJR28yQWdnZ0FDQUJRWnd3YWpZQ0JDQUFJQUZCREdvMkFnQWdBRUdzMEFGcUlBRkJxTkFCYWlnQ0FEWUNBQ0FBUWJEUUFXb2dBVUdzMEFGcUtBSUFOZ0lBSUFCQnROQUJhaUFCUWJEUUFXb29BZ0EyQWdBUEN5QUFRZ0EzQTRqaEFRczdBQ0FDUlFSQVFicC9Ed3NnQkVVRVFFRnNEd3NnQWlBRUVHQUVRQ0FBSUFFZ0FpQURJQVFnQlJCaER3c2dBQ0FCSUFJZ0F5QUVJQVVRWlF0R0FRRi9Jd0JCRUdzaUJTUUFJQVZCQ0dvZ0JCQU9BbjhnQlMwQUNRUkFJQUFnQVNBQ0lBTWdCQkF5REFFTElBQWdBU0FDSUFNZ0JCQTBDeUVBSUFWQkVHb2tBQ0FBQ3pRQUlBQWdBeUFFSUFVUU5pSUZFQU1FUUNBRkR3c2dCU0FFU1FSL0lBRWdBaUFESUFWcUlBUWdCV3NnQUJBMUJVRzRmd3NMUmdFQmZ5TUFRUkJySWdVa0FDQUZRUWhxSUFRUURnSi9JQVV0QUFrRVFDQUFJQUVnQWlBRElBUVFZZ3dCQ3lBQUlBRWdBaUFESUFRUU5Rc2hBQ0FGUVJCcUpBQWdBQXRaQVFGL1FROGhBaUFCSUFCSkJFQWdBVUVFZENBQWJpRUNDeUFBUVFoMklnRWdBa0VZYkNJQVFZd0lhaWdDQUd3Z0FFR0lDR29vQWdCcUlnSkJBM1lnQW1vZ0FFR0FDR29vQWdBZ0FFR0VDR29vQWdBZ0FXeHFTUXMzQUNBQUlBTWdCQ0FGUVlBUUVETWlCUkFEQkVBZ0JROExJQVVnQkVrRWZ5QUJJQUlnQXlBRmFpQUVJQVZySUFBUU1nVkJ1SDhMQzc4REFRTi9Jd0JCSUdzaUJTUUFJQVZCQ0dvZ0FpQURFQVlpQWhBRFJRUkFJQUFnQVdvaUIwRjlhaUVHSUFVZ0JCQU9JQVJCQkdvaEFpQUZMUUFDSVFNRFFFRUFJQUFnQmtrZ0JVRUlhaEFFR3dSQUlBQWdBaUFGUVFocUlBTVFBa0VDZEdvaUJDOEJBRHNBQUNBRlFRaHFJQVF0QUFJUUFTQUFJQVF0QUFOcUlnUWdBaUFGUVFocUlBTVFBa0VDZEdvaUFDOEJBRHNBQUNBRlFRaHFJQUF0QUFJUUFTQUVJQUF0QUFOcUlRQU1BUVVnQjBGK2FpRUVBMEFnQlVFSWFoQUVJQUFnQkV0eVJRUkFJQUFnQWlBRlFRaHFJQU1RQWtFQ2RHb2lCaThCQURzQUFDQUZRUWhxSUFZdEFBSVFBU0FBSUFZdEFBTnFJUUFNQVFzTEEwQWdBQ0FFUzBVRVFDQUFJQUlnQlVFSWFpQURFQUpCQW5ScUlnWXZBUUE3QUFBZ0JVRUlhaUFHTFFBQ0VBRWdBQ0FHTFFBRGFpRUFEQUVMQ3dKQUlBQWdCMDhOQUNBQUlBSWdCVUVJYWlBREVBSWlBMEVDZEdvaUFDMEFBRG9BQUNBQUxRQURRUUZHQkVBZ0JVRUlhaUFBTFFBQ0VBRU1BUXNnQlNnQ0RFRWZTdzBBSUFWQkNHb2dBaUFEUVFKMGFpMEFBaEFCSUFVb0FneEJJVWtOQUNBRlFTQTJBZ3dMSUFGQmJDQUZRUWhxRUFvYklRSUxDd3NnQlVFZ2FpUUFJQUlMa2dJQkJIOGpBRUZBYWlJSkpBQWdDU0FEUVRRUUN5RURBa0FnQkVFQ1NBMEFJQU1nQkVFQ2RHb29BZ0FoQ1NBRFFUeHFJQWdRSXlBRFFRRTZBRDhnQXlBQ09nQStRUUFoQkNBREtBSThJUW9EUUNBRUlBbEdEUUVnQUNBRVFRSjBhaUFLTmdFQUlBUkJBV29oQkF3QUFBc0FDMEVBSVFrRFFDQUdJQWxHUlFSQUlBTWdCU0FKUVFGMGFpSUtMUUFCSWd0QkFuUnFJZ3dvQWdBaEJDQURRVHhxSUFvdEFBQkJDSFFnQ0dwQi8vOERjUkFqSUFOQkFqb0FQeUFESUFjZ0Myc2lDaUFDYWpvQVBpQUVRUUVnQVNBS2EzUnFJUW9nQXlnQ1BDRUxBMEFnQUNBRVFRSjBhaUFMTmdFQUlBUkJBV29pQkNBS1NRMEFDeUFNSUFvMkFnQWdDVUVCYWlFSkRBRUxDeUFEUVVCckpBQUxvd0lCQ1g4akFFSFFBR3NpQ1NRQUlBbEJFR29nQlVFMEVBc2FJQWNnQm1zaER5QUhJQUZySVJBRFFBSkFJQU1nQ2tjRVFFRUJJQUVnQnlBQ0lBcEJBWFJxSWdZdEFBRWlER3NpQ0dzaUMzUWhEU0FHTFFBQUlRNGdDVUVRYWlBTVFRSjBhaUlNS0FJQUlRWWdDeUFQVHdSQUlBQWdCa0VDZEdvZ0N5QUlJQVVnQ0VFMGJHb2dDQ0FRYWlJSVFRRWdDRUVCU2hzaUNDQUNJQVFnQ0VFQ2RHb29BZ0FpQ0VFQmRHb2dBeUFJYXlBSElBNFFZeUFHSUExcUlRZ01BZ3NnQ1VFTWFpQU9FQ01nQ1VFQk9nQVBJQWtnQ0RvQURpQUdJQTFxSVFnZ0NTZ0NEQ0VMQTBBZ0JpQUlUdzBDSUFBZ0JrRUNkR29nQ3pZQkFDQUdRUUZxSVFZTUFBQUxBQXNnQ1VIUUFHb2tBQThMSUF3Z0NEWUNBQ0FLUVFGcUlRb01BQUFMQUFzMEFDQUFJQU1nQkNBRkVEWWlCUkFEQkVBZ0JROExJQVVnQkVrRWZ5QUJJQUlnQXlBRmFpQUVJQVZySUFBUU5BVkJ1SDhMQ3lNQUlBQS9BRUVRZEd0Qi8vOERha0VRZGtBQVFYOUdCRUJCQUE4TFFRQVFBRUVCQ3pzQkFYOGdBZ1JBQTBBZ0FDQUJJQUpCZ0NBZ0FrR0FJRWtiSWdNUUN5RUFJQUZCZ0NCcUlRRWdBRUdBSUdvaEFDQUNJQU5ySWdJTkFBc0xDd1lBSUFBUUF3c0xxQlVKQUVHSUNBc05BUUFBQUFFQUFBQUNBQUFBQWdCQm9BZ0xzd1lCQUFBQUFRQUFBQUlBQUFBQ0FBQUFKZ0FBQUlJQUFBQWhCUUFBU2dBQUFHY0lBQUFtQUFBQXdBRUFBSUFBQUFCSkJRQUFTZ0FBQUw0SUFBQXBBQUFBTEFJQUFJQUFBQUJKQlFBQVNnQUFBTDRJQUFBdkFBQUF5Z0lBQUlBQUFBQ0tCUUFBU2dBQUFJUUpBQUExQUFBQWN3TUFBSUFBQUFDZEJRQUFTZ0FBQUtBSkFBQTlBQUFBZ1FNQUFJQUFBQURyQlFBQVN3QUFBRDRLQUFCRUFBQUFuZ01BQUlBQUFBQk5CZ0FBU3dBQUFLb0tBQUJMQUFBQXN3TUFBSUFBQUFEQkJnQUFUUUFBQUI4TkFBQk5BQUFBVXdRQUFJQUFBQUFqQ0FBQVVRQUFBS1lQQUFCVUFBQUFtUVFBQUlBQUFBQkxDUUFBVndBQUFMRVNBQUJZQUFBQTJnUUFBSUFBQUFCdkNRQUFYUUFBQUNNVUFBQlVBQUFBUlFVQUFJQUFBQUJVQ2dBQWFnQUFBSXdVQUFCcUFBQUFyd1VBQUlBQUFBQjJDUUFBZkFBQUFFNFFBQUI4QUFBQTBnSUFBSUFBQUFCakJ3QUFrUUFBQUpBSEFBQ1NBQUFBQUFBQUFBRUFBQUFCQUFBQUJRQUFBQTBBQUFBZEFBQUFQUUFBQUgwQUFBRDlBQUFBL1FFQUFQMERBQUQ5QndBQS9ROEFBUDBmQUFEOVB3QUEvWDhBQVAzL0FBRDkvd0VBL2Y4REFQMy9Cd0Q5L3c4QS9mOGZBUDMvUHdEOS8zOEEvZi8vQVAzLy93SDkvLzhEL2YvL0IvMy8vdy85Ly84Zi9mLy9QLzMvLzM4QUFBQUFBUUFBQUFJQUFBQURBQUFBQkFBQUFBVUFBQUFHQUFBQUJ3QUFBQWdBQUFBSkFBQUFDZ0FBQUFzQUFBQU1BQUFBRFFBQUFBNEFBQUFQQUFBQUVBQUFBQkVBQUFBU0FBQUFFd0FBQUJRQUFBQVZBQUFBRmdBQUFCY0FBQUFZQUFBQUdRQUFBQm9BQUFBYkFBQUFIQUFBQUIwQUFBQWVBQUFBSHdBQUFBTUFBQUFFQUFBQUJRQUFBQVlBQUFBSEFBQUFDQUFBQUFrQUFBQUtBQUFBQ3dBQUFBd0FBQUFOQUFBQURnQUFBQThBQUFBUUFBQUFFUUFBQUJJQUFBQVRBQUFBRkFBQUFCVUFBQUFXQUFBQUZ3QUFBQmdBQUFBWkFBQUFHZ0FBQUJzQUFBQWNBQUFBSFFBQUFCNEFBQUFmQUFBQUlBQUFBQ0VBQUFBaUFBQUFJd0FBQUNVQUFBQW5BQUFBS1FBQUFDc0FBQUF2QUFBQU13QUFBRHNBQUFCREFBQUFVd0FBQUdNQUFBQ0RBQUFBQXdFQUFBTUNBQUFEQkFBQUF3Z0FBQU1RQUFBRElBQUFBMEFBQUFPQUFBQURBQUVBUWVBUEMxRUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFnQUFBQUlBQUFBREFBQUFBd0FBQUFRQUFBQUVBQUFBQlFBQUFBY0FBQUFJQUFBQUNRQUFBQW9BQUFBTEFBQUFEQUFBQUEwQUFBQU9BQUFBRHdBQUFCQUFRY1FRQzRzQkFRQUFBQUlBQUFBREFBQUFCQUFBQUFVQUFBQUdBQUFBQndBQUFBZ0FBQUFKQUFBQUNnQUFBQXNBQUFBTUFBQUFEUUFBQUE0QUFBQVBBQUFBRUFBQUFCSUFBQUFVQUFBQUZnQUFBQmdBQUFBY0FBQUFJQUFBQUNnQUFBQXdBQUFBUUFBQUFJQUFBQUFBQVFBQUFBSUFBQUFFQUFBQUNBQUFBQkFBQUFBZ0FBQUFRQUFBQUlBQUFBQUFBUUJCa0JJTDVnUUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFnQUFBQUlBQUFBREFBQUFBd0FBQUFRQUFBQUdBQUFBQndBQUFBZ0FBQUFKQUFBQUNnQUFBQXNBQUFBTUFBQUFEUUFBQUE0QUFBQVBBQUFBRUFBQUFBRUFBQUFFQUFBQUNBQUFBQUFBQUFBQkFBRUJCZ0FBQUFBQUFBUUFBQUFBRUFBQUJBQUFBQUFnQUFBRkFRQUFBQUFBQUFVREFBQUFBQUFBQlFRQUFBQUFBQUFGQmdBQUFBQUFBQVVIQUFBQUFBQUFCUWtBQUFBQUFBQUZDZ0FBQUFBQUFBVU1BQUFBQUFBQUJnNEFBQUFBQUFFRkVBQUFBQUFBQVFVVUFBQUFBQUFCQlJZQUFBQUFBQUlGSEFBQUFBQUFBd1VnQUFBQUFBQUVCVEFBQUFBZ0FBWUZRQUFBQUFBQUJ3V0FBQUFBQUFBSUJnQUJBQUFBQUFvR0FBUUFBQUFBREFZQUVBQUFJQUFBQkFBQUFBQUFBQUFFQVFBQUFBQUFBQVVDQUFBQUlBQUFCUVFBQUFBQUFBQUZCUUFBQUNBQUFBVUhBQUFBQUFBQUJRZ0FBQUFnQUFBRkNnQUFBQUFBQUFVTEFBQUFBQUFBQmcwQUFBQWdBQUVGRUFBQUFBQUFBUVVTQUFBQUlBQUJCUllBQUFBQUFBSUZHQUFBQUNBQUF3VWdBQUFBQUFBREJTZ0FBQUFBQUFZRVFBQUFBQkFBQmdSQUFBQUFJQUFIQllBQUFBQUFBQWtHQUFJQUFBQUFDd1lBQ0FBQU1BQUFCQUFBQUFBUUFBQUVBUUFBQUNBQUFBVUNBQUFBSUFBQUJRTUFBQUFnQUFBRkJRQUFBQ0FBQUFVR0FBQUFJQUFBQlFnQUFBQWdBQUFGQ1FBQUFDQUFBQVVMQUFBQUlBQUFCUXdBQUFBQUFBQUdEd0FBQUNBQUFRVVNBQUFBSUFBQkJSUUFBQUFnQUFJRkdBQUFBQ0FBQWdVY0FBQUFJQUFEQlNnQUFBQWdBQVFGTUFBQUFBQUFFQVlBQUFFQUFBQVBCZ0NBQUFBQUFBNEdBRUFBQUFBQURRWUFJQUJCZ0JjTGh3SUJBQUVCQlFBQUFBQUFBQVVBQUFBQUFBQUdCRDBBQUFBQUFBa0YvUUVBQUFBQUR3WDlmd0FBQUFBVkJmMy9Id0FBQUFNRkJRQUFBQUFBQndSOUFBQUFBQUFNQmYwUEFBQUFBQklGL2Y4REFBQUFGd1g5LzM4QUFBQUZCUjBBQUFBQUFBZ0UvUUFBQUFBQURnWDlQd0FBQUFBVUJmMy9Ed0FBQUFJRkFRQUFBQkFBQndSOUFBQUFBQUFMQmYwSEFBQUFBQkVGL2Y4QkFBQUFGZ1g5L3o4QUFBQUVCUTBBQUFBUUFBZ0UvUUFBQUFBQURRWDlId0FBQUFBVEJmMy9Cd0FBQUFFRkFRQUFBQkFBQmdROUFBQUFBQUFLQmYwREFBQUFBQkFGL2Y4QUFBQUFIQVg5Ly84UEFBQWJCZjMvL3djQUFCb0YvZi8vQXdBQUdRWDkvLzhCQUFBWUJmMy8vd0JCa0JrTGhnUUJBQUVCQmdBQUFBQUFBQVlEQUFBQUFBQUFCQVFBQUFBZ0FBQUZCUUFBQUFBQUFBVUdBQUFBQUFBQUJRZ0FBQUFBQUFBRkNRQUFBQUFBQUFVTEFBQUFBQUFBQmcwQUFBQUFBQUFHRUFBQUFBQUFBQVlUQUFBQUFBQUFCaFlBQUFBQUFBQUdHUUFBQUFBQUFBWWNBQUFBQUFBQUJoOEFBQUFBQUFBR0lnQUFBQUFBQVFZbEFBQUFBQUFCQmlrQUFBQUFBQUlHTHdBQUFBQUFBd1k3QUFBQUFBQUVCbE1BQUFBQUFBY0dnd0FBQUFBQUNRWURBZ0FBRUFBQUJBUUFBQUFBQUFBRUJRQUFBQ0FBQUFVR0FBQUFBQUFBQlFjQUFBQWdBQUFGQ1FBQUFBQUFBQVVLQUFBQUFBQUFCZ3dBQUFBQUFBQUdEd0FBQUFBQUFBWVNBQUFBQUFBQUJoVUFBQUFBQUFBR0dBQUFBQUFBQUFZYkFBQUFBQUFBQmg0QUFBQUFBQUFHSVFBQUFBQUFBUVlqQUFBQUFBQUJCaWNBQUFBQUFBSUdLd0FBQUFBQUF3WXpBQUFBQUFBRUJrTUFBQUFBQUFVR1l3QUFBQUFBQ0FZREFRQUFJQUFBQkFRQUFBQXdBQUFFQkFBQUFCQUFBQVFGQUFBQUlBQUFCUWNBQUFBZ0FBQUZDQUFBQUNBQUFBVUtBQUFBSUFBQUJRc0FBQUFBQUFBR0RnQUFBQUFBQUFZUkFBQUFBQUFBQmhRQUFBQUFBQUFHRndBQUFBQUFBQVlhQUFBQUFBQUFCaDBBQUFBQUFBQUdJQUFBQUFBQUVBWURBQUVBQUFBUEJnT0FBQUFBQUE0R0EwQUFBQUFBRFFZRElBQUFBQUFNQmdNUUFBQUFBQXNHQXdnQUFBQUFDZ1lEQkFCQnBCMEwyUUVCQUFBQUF3QUFBQWNBQUFBUEFBQUFId0FBQUQ4QUFBQi9BQUFBL3dBQUFQOEJBQUQvQXdBQS93Y0FBUDhQQUFEL0h3QUEvejhBQVA5L0FBRC8vd0FBLy84QkFQLy9Bd0QvL3djQS8vOFBBUC8vSHdELy96OEEvLzkvQVAvLy93RC8vLzhCLy8vL0EvLy8vd2YvLy84UC8vLy9ILy8vL3ovLy8vOS9BQUFBQUFFQUFBQUNBQUFBQkFBQUFBQUFBQUFDQUFBQUJBQUFBQWdBQUFBQUFBQUFBUUFBQUFJQUFBQUJBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQWdBQUFBSUFBQUFDQUFBQUFjQUFBQUlBQUFBQ1FBQUFBb0FBQUFMQUVHZ0lBc0R3QkJRXFxcIix0ZT17MzE1OlxcXCJBcnRpc3RcXFwiLDI1ODpcXFwiQml0c1BlclNhbXBsZVxcXCIsMjY1OlxcXCJDZWxsTGVuZ3RoXFxcIiwyNjQ6XFxcIkNlbGxXaWR0aFxcXCIsMzIwOlxcXCJDb2xvck1hcFxcXCIsMjU5OlxcXCJDb21wcmVzc2lvblxcXCIsMzM0MzI6XFxcIkNvcHlyaWdodFxcXCIsMzA2OlxcXCJEYXRlVGltZVxcXCIsMzM4OlxcXCJFeHRyYVNhbXBsZXNcXFwiLDI2NjpcXFwiRmlsbE9yZGVyXFxcIiwyODk6XFxcIkZyZWVCeXRlQ291bnRzXFxcIiwyODg6XFxcIkZyZWVPZmZzZXRzXFxcIiwyOTE6XFxcIkdyYXlSZXNwb25zZUN1cnZlXFxcIiwyOTA6XFxcIkdyYXlSZXNwb25zZVVuaXRcXFwiLDMxNjpcXFwiSG9zdENvbXB1dGVyXFxcIiwyNzA6XFxcIkltYWdlRGVzY3JpcHRpb25cXFwiLDI1NzpcXFwiSW1hZ2VMZW5ndGhcXFwiLDI1NjpcXFwiSW1hZ2VXaWR0aFxcXCIsMjcxOlxcXCJNYWtlXFxcIiwyODE6XFxcIk1heFNhbXBsZVZhbHVlXFxcIiwyODA6XFxcIk1pblNhbXBsZVZhbHVlXFxcIiwyNzI6XFxcIk1vZGVsXFxcIiwyNTQ6XFxcIk5ld1N1YmZpbGVUeXBlXFxcIiwyNzQ6XFxcIk9yaWVudGF0aW9uXFxcIiwyNjI6XFxcIlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25cXFwiLDI4NDpcXFwiUGxhbmFyQ29uZmlndXJhdGlvblxcXCIsMjk2OlxcXCJSZXNvbHV0aW9uVW5pdFxcXCIsMjc4OlxcXCJSb3dzUGVyU3RyaXBcXFwiLDI3NzpcXFwiU2FtcGxlc1BlclBpeGVsXFxcIiwzMDU6XFxcIlNvZnR3YXJlXFxcIiwyNzk6XFxcIlN0cmlwQnl0ZUNvdW50c1xcXCIsMjczOlxcXCJTdHJpcE9mZnNldHNcXFwiLDI1NTpcXFwiU3ViZmlsZVR5cGVcXFwiLDI2MzpcXFwiVGhyZXNoaG9sZGluZ1xcXCIsMjgyOlxcXCJYUmVzb2x1dGlvblxcXCIsMjgzOlxcXCJZUmVzb2x1dGlvblxcXCIsMzI2OlxcXCJCYWRGYXhMaW5lc1xcXCIsMzI3OlxcXCJDbGVhbkZheERhdGFcXFwiLDM0MzpcXFwiQ2xpcFBhdGhcXFwiLDMyODpcXFwiQ29uc2VjdXRpdmVCYWRGYXhMaW5lc1xcXCIsNDMzOlxcXCJEZWNvZGVcXFwiLDQzNDpcXFwiRGVmYXVsdEltYWdlQ29sb3JcXFwiLDI2OTpcXFwiRG9jdW1lbnROYW1lXFxcIiwzMzY6XFxcIkRvdFJhbmdlXFxcIiwzMjE6XFxcIkhhbGZ0b25lSGludHNcXFwiLDM0NjpcXFwiSW5kZXhlZFxcXCIsMzQ3OlxcXCJKUEVHVGFibGVzXFxcIiwyODU6XFxcIlBhZ2VOYW1lXFxcIiwyOTc6XFxcIlBhZ2VOdW1iZXJcXFwiLDMxNzpcXFwiUHJlZGljdG9yXFxcIiwzMTk6XFxcIlByaW1hcnlDaHJvbWF0aWNpdGllc1xcXCIsNTMyOlxcXCJSZWZlcmVuY2VCbGFja1doaXRlXFxcIiwzMzk6XFxcIlNhbXBsZUZvcm1hdFxcXCIsMzQwOlxcXCJTTWluU2FtcGxlVmFsdWVcXFwiLDM0MTpcXFwiU01heFNhbXBsZVZhbHVlXFxcIiw1NTk6XFxcIlN0cmlwUm93Q291bnRzXFxcIiwzMzA6XFxcIlN1YklGRHNcXFwiLDI5MjpcXFwiVDRPcHRpb25zXFxcIiwyOTM6XFxcIlQ2T3B0aW9uc1xcXCIsMzI1OlxcXCJUaWxlQnl0ZUNvdW50c1xcXCIsMzIzOlxcXCJUaWxlTGVuZ3RoXFxcIiwzMjQ6XFxcIlRpbGVPZmZzZXRzXFxcIiwzMjI6XFxcIlRpbGVXaWR0aFxcXCIsMzAxOlxcXCJUcmFuc2ZlckZ1bmN0aW9uXFxcIiwzMTg6XFxcIldoaXRlUG9pbnRcXFwiLDM0NDpcXFwiWENsaXBQYXRoVW5pdHNcXFwiLDI4NjpcXFwiWFBvc2l0aW9uXFxcIiw1Mjk6XFxcIllDYkNyQ29lZmZpY2llbnRzXFxcIiw1MzE6XFxcIllDYkNyUG9zaXRpb25pbmdcXFwiLDUzMDpcXFwiWUNiQ3JTdWJTYW1wbGluZ1xcXCIsMzQ1OlxcXCJZQ2xpcFBhdGhVbml0c1xcXCIsMjg3OlxcXCJZUG9zaXRpb25cXFwiLDM3Mzc4OlxcXCJBcGVydHVyZVZhbHVlXFxcIiw0MDk2MTpcXFwiQ29sb3JTcGFjZVxcXCIsMzY4Njg6XFxcIkRhdGVUaW1lRGlnaXRpemVkXFxcIiwzNjg2NzpcXFwiRGF0ZVRpbWVPcmlnaW5hbFxcXCIsMzQ2NjU6XFxcIkV4aWYgSUZEXFxcIiwzNjg2NDpcXFwiRXhpZlZlcnNpb25cXFwiLDMzNDM0OlxcXCJFeHBvc3VyZVRpbWVcXFwiLDQxNzI4OlxcXCJGaWxlU291cmNlXFxcIiwzNzM4NTpcXFwiRmxhc2hcXFwiLDQwOTYwOlxcXCJGbGFzaHBpeFZlcnNpb25cXFwiLDMzNDM3OlxcXCJGTnVtYmVyXFxcIiw0MjAxNjpcXFwiSW1hZ2VVbmlxdWVJRFxcXCIsMzczODQ6XFxcIkxpZ2h0U291cmNlXFxcIiwzNzUwMDpcXFwiTWFrZXJOb3RlXFxcIiwzNzM3NzpcXFwiU2h1dHRlclNwZWVkVmFsdWVcXFwiLDM3NTEwOlxcXCJVc2VyQ29tbWVudFxcXCIsMzM3MjM6XFxcIklQVENcXFwiLDM0Njc1OlxcXCJJQ0MgUHJvZmlsZVxcXCIsNzAwOlxcXCJYTVBcXFwiLDQyMTEyOlxcXCJHREFMX01FVEFEQVRBXFxcIiw0MjExMzpcXFwiR0RBTF9OT0RBVEFcXFwiLDM0Mzc3OlxcXCJQaG90b3Nob3BcXFwiLDMzNTUwOlxcXCJNb2RlbFBpeGVsU2NhbGVcXFwiLDMzOTIyOlxcXCJNb2RlbFRpZXBvaW50XFxcIiwzNDI2NDpcXFwiTW9kZWxUcmFuc2Zvcm1hdGlvblxcXCIsMzQ3MzU6XFxcIkdlb0tleURpcmVjdG9yeVxcXCIsMzQ3MzY6XFxcIkdlb0RvdWJsZVBhcmFtc1xcXCIsMzQ3Mzc6XFxcIkdlb0FzY2lpUGFyYW1zXFxcIiw1MDY3NDpcXFwiTGVyY1BhcmFtZXRlcnNcXFwifSxpZT17fTtmb3IodmFyIHJlIGluIHRlKXRlLmhhc093blByb3BlcnR5KHJlKSYmKGllW3RlW3JlXV09cGFyc2VJbnQocmUsMTApKTtpZS5CaXRzUGVyU2FtcGxlLGllLkV4dHJhU2FtcGxlcyxpZS5TYW1wbGVGb3JtYXQsaWUuU3RyaXBCeXRlQ291bnRzLGllLlN0cmlwT2Zmc2V0cyxpZS5TdHJpcFJvd0NvdW50cyxpZS5UaWxlQnl0ZUNvdW50cyxpZS5UaWxlT2Zmc2V0cyxpZS5TdWJJRkRzO3ZhciBJZT17MTpcXFwiQllURVxcXCIsMjpcXFwiQVNDSUlcXFwiLDM6XFxcIlNIT1JUXFxcIiw0OlxcXCJMT05HXFxcIiw1OlxcXCJSQVRJT05BTFxcXCIsNjpcXFwiU0JZVEVcXFwiLDc6XFxcIlVOREVGSU5FRFxcXCIsODpcXFwiU1NIT1JUXFxcIiw5OlxcXCJTTE9OR1xcXCIsMTA6XFxcIlNSQVRJT05BTFxcXCIsMTE6XFxcIkZMT0FUXFxcIiwxMjpcXFwiRE9VQkxFXFxcIiwxMzpcXFwiSUZEXFxcIiwxNjpcXFwiTE9ORzhcXFwiLDE3OlxcXCJTTE9ORzhcXFwiLDE4OlxcXCJJRkQ4XFxcIn0sZ2U9e307Zm9yKHZhciBuZSBpbiBJZSlJZS5oYXNPd25Qcm9wZXJ0eShuZSkmJihnZVtJZVtuZV1dPXBhcnNlSW50KG5lLDEwKSk7dmFyIGFlPTEsb2U9MCxCZT0xLENlPTIsUWU9ezEwMjQ6XFxcIkdUTW9kZWxUeXBlR2VvS2V5XFxcIiwxMDI1OlxcXCJHVFJhc3RlclR5cGVHZW9LZXlcXFwiLDEwMjY6XFxcIkdUQ2l0YXRpb25HZW9LZXlcXFwiLDIwNDg6XFxcIkdlb2dyYXBoaWNUeXBlR2VvS2V5XFxcIiwyMDQ5OlxcXCJHZW9nQ2l0YXRpb25HZW9LZXlcXFwiLDIwNTA6XFxcIkdlb2dHZW9kZXRpY0RhdHVtR2VvS2V5XFxcIiwyMDUxOlxcXCJHZW9nUHJpbWVNZXJpZGlhbkdlb0tleVxcXCIsMjA1MjpcXFwiR2VvZ0xpbmVhclVuaXRzR2VvS2V5XFxcIiwyMDUzOlxcXCJHZW9nTGluZWFyVW5pdFNpemVHZW9LZXlcXFwiLDIwNTQ6XFxcIkdlb2dBbmd1bGFyVW5pdHNHZW9LZXlcXFwiLDIwNTU6XFxcIkdlb2dBbmd1bGFyVW5pdFNpemVHZW9LZXlcXFwiLDIwNTY6XFxcIkdlb2dFbGxpcHNvaWRHZW9LZXlcXFwiLDIwNTc6XFxcIkdlb2dTZW1pTWFqb3JBeGlzR2VvS2V5XFxcIiwyMDU4OlxcXCJHZW9nU2VtaU1pbm9yQXhpc0dlb0tleVxcXCIsMjA1OTpcXFwiR2VvZ0ludkZsYXR0ZW5pbmdHZW9LZXlcXFwiLDIwNjA6XFxcIkdlb2dBemltdXRoVW5pdHNHZW9LZXlcXFwiLDIwNjE6XFxcIkdlb2dQcmltZU1lcmlkaWFuTG9uZ0dlb0tleVxcXCIsMjA2MjpcXFwiR2VvZ1RPV0dTODRHZW9LZXlcXFwiLDMwNzI6XFxcIlByb2plY3RlZENTVHlwZUdlb0tleVxcXCIsMzA3MzpcXFwiUENTQ2l0YXRpb25HZW9LZXlcXFwiLDMwNzQ6XFxcIlByb2plY3Rpb25HZW9LZXlcXFwiLDMwNzU6XFxcIlByb2pDb29yZFRyYW5zR2VvS2V5XFxcIiwzMDc2OlxcXCJQcm9qTGluZWFyVW5pdHNHZW9LZXlcXFwiLDMwNzc6XFxcIlByb2pMaW5lYXJVbml0U2l6ZUdlb0tleVxcXCIsMzA3ODpcXFwiUHJvalN0ZFBhcmFsbGVsMUdlb0tleVxcXCIsMzA3OTpcXFwiUHJvalN0ZFBhcmFsbGVsMkdlb0tleVxcXCIsMzA4MDpcXFwiUHJvak5hdE9yaWdpbkxvbmdHZW9LZXlcXFwiLDMwODE6XFxcIlByb2pOYXRPcmlnaW5MYXRHZW9LZXlcXFwiLDMwODI6XFxcIlByb2pGYWxzZUVhc3RpbmdHZW9LZXlcXFwiLDMwODM6XFxcIlByb2pGYWxzZU5vcnRoaW5nR2VvS2V5XFxcIiwzMDg0OlxcXCJQcm9qRmFsc2VPcmlnaW5Mb25nR2VvS2V5XFxcIiwzMDg1OlxcXCJQcm9qRmFsc2VPcmlnaW5MYXRHZW9LZXlcXFwiLDMwODY6XFxcIlByb2pGYWxzZU9yaWdpbkVhc3RpbmdHZW9LZXlcXFwiLDMwODc6XFxcIlByb2pGYWxzZU9yaWdpbk5vcnRoaW5nR2VvS2V5XFxcIiwzMDg4OlxcXCJQcm9qQ2VudGVyTG9uZ0dlb0tleVxcXCIsMzA4OTpcXFwiUHJvakNlbnRlckxhdEdlb0tleVxcXCIsMzA5MDpcXFwiUHJvakNlbnRlckVhc3RpbmdHZW9LZXlcXFwiLDMwOTE6XFxcIlByb2pDZW50ZXJOb3J0aGluZ0dlb0tleVxcXCIsMzA5MjpcXFwiUHJvalNjYWxlQXROYXRPcmlnaW5HZW9LZXlcXFwiLDMwOTM6XFxcIlByb2pTY2FsZUF0Q2VudGVyR2VvS2V5XFxcIiwzMDk0OlxcXCJQcm9qQXppbXV0aEFuZ2xlR2VvS2V5XFxcIiwzMDk1OlxcXCJQcm9qU3RyYWlnaHRWZXJ0UG9sZUxvbmdHZW9LZXlcXFwiLDMwOTY6XFxcIlByb2pSZWN0aWZpZWRHcmlkQW5nbGVHZW9LZXlcXFwiLDQwOTY6XFxcIlZlcnRpY2FsQ1NUeXBlR2VvS2V5XFxcIiw0MDk3OlxcXCJWZXJ0aWNhbENpdGF0aW9uR2VvS2V5XFxcIiw0MDk4OlxcXCJWZXJ0aWNhbERhdHVtR2VvS2V5XFxcIiw0MDk5OlxcXCJWZXJ0aWNhbFVuaXRzR2VvS2V5XFxcIn0sRWU9e307Zm9yKHZhciBzZSBpbiBRZSlRZS5oYXNPd25Qcm9wZXJ0eShzZSkmJihFZVtRZVtzZV1dPXBhcnNlSW50KHNlLDEwKSk7ZnVuY3Rpb24gZmUoQSl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goQSl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciB0LGk9YyhBKTtpZihlKXt2YXIgcj1jKHRoaXMpLmNvbnN0cnVjdG9yO3Q9UmVmbGVjdC5jb25zdHJ1Y3QoaSxhcmd1bWVudHMscil9ZWxzZSB0PWkuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBmKHRoaXMsdCl9fXZhciBjZT1uZXcgQWUsaGU9ZnVuY3Rpb24oQSl7cyh0LHcpO3ZhciBlPWZlKHQpO2Z1bmN0aW9uIHQoQSl7dmFyIGk7cmV0dXJuIEIodGhpcyx0KSwoaT1lLmNhbGwodGhpcykpLnBsYW5hckNvbmZpZ3VyYXRpb249dm9pZCAwIT09QS5QbGFuYXJDb25maWd1cmF0aW9uP0EuUGxhbmFyQ29uZmlndXJhdGlvbjoxLGkuc2FtcGxlc1BlclBpeGVsPXZvaWQgMCE9PUEuU2FtcGxlc1BlclBpeGVsP0EuU2FtcGxlc1BlclBpeGVsOjEsaS5hZGRDb21wcmVzc2lvbj1BLkxlcmNQYXJhbWV0ZXJzW2FlXSxpfXJldHVybiBRKHQsW3trZXk6XFxcImRlY29kZUJsb2NrXFxcIix2YWx1ZTpmdW5jdGlvbihBKXtzd2l0Y2godGhpcy5hZGRDb21wcmVzc2lvbil7Y2FzZSBvZTpicmVhaztjYXNlIEJlOkE9WUEobmV3IFVpbnQ4QXJyYXkoQSkpLmJ1ZmZlcjticmVhaztjYXNlIENlOkE9Y2UuZGVjb2RlKG5ldyBVaW50OEFycmF5KEEpKS5idWZmZXI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXFxcIlVuc3VwcG9ydGVkIExFUkMgYWRkaXRpb25hbCBjb21wcmVzc2lvbiBtZXRob2QgaWRlbnRpZmllcjogXFxcIi5jb25jYXQodGhpcy5hZGRDb21wcmVzc2lvbikpfXJldHVybiB6QS5kZWNvZGUoQSx7cmV0dXJuUGl4ZWxJbnRlcmxlYXZlZERpbXM6MT09PXRoaXMucGxhbmFyQ29uZmlndXJhdGlvbn0pLnBpeGVsc1swXS5idWZmZXJ9fV0pLHR9KCksbGU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsenN0ZDpjZSxkZWZhdWx0OmhlfSk7ZnVuY3Rpb24gdWUoQSl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goQSl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciB0LGk9YyhBKTtpZihlKXt2YXIgcj1jKHRoaXMpLmNvbnN0cnVjdG9yO3Q9UmVmbGVjdC5jb25zdHJ1Y3QoaSxhcmd1bWVudHMscil9ZWxzZSB0PWkuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBmKHRoaXMsdCl9fXZhciB3ZT1mdW5jdGlvbihBKXtzKEksdyk7dmFyIHQsaT11ZShJKTtmdW5jdGlvbiBJKCl7dmFyIEE7aWYoQih0aGlzLEkpLEE9aS5jYWxsKHRoaXMpLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXApdGhyb3cgbmV3IEVycm9yKFxcXCJDYW5ub3QgZGVjb2RlIFdlYkltYWdlIGFzIGBjcmVhdGVJbWFnZUJpdG1hcGAgaXMgbm90IGF2YWlsYWJsZVxcXCIpO2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZG9jdW1lbnQmJlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgT2Zmc2NyZWVuQ2FudmFzKXRocm93IG5ldyBFcnJvcihcXFwiQ2Fubm90IGRlY29kZSBXZWJJbWFnZSBhcyBuZWl0aGVyIGBkb2N1bWVudGAgbm9yIGBPZmZzY3JlZW5DYW52YXNgIGlzIG5vdCBhdmFpbGFibGVcXFwiKTtyZXR1cm4gQX1yZXR1cm4gUShJLFt7a2V5OlxcXCJkZWNvZGVcXFwiLHZhbHVlOih0PWUoci5tYXJrKChmdW5jdGlvbiBBKGUsdCl7dmFyIGksSSxnLG47cmV0dXJuIHIud3JhcCgoZnVuY3Rpb24oQSl7Zm9yKDs7KXN3aXRjaChBLnByZXY9QS5uZXh0KXtjYXNlIDA6cmV0dXJuIGk9bmV3IEJsb2IoW3RdKSxBLm5leHQ9MyxjcmVhdGVJbWFnZUJpdG1hcChpKTtjYXNlIDM6cmV0dXJuIEk9QS5zZW50LFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZG9jdW1lbnQ/KChnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImNhbnZhc1xcXCIpKS53aWR0aD1JLndpZHRoLGcuaGVpZ2h0PUkuaGVpZ2h0KTpnPW5ldyBPZmZzY3JlZW5DYW52YXMoSS53aWR0aCxJLmhlaWdodCksKG49Zy5nZXRDb250ZXh0KFxcXCIyZFxcXCIpKS5kcmF3SW1hZ2UoSSwwLDApLEEuYWJydXB0KFxcXCJyZXR1cm5cXFwiLG4uZ2V0SW1hZ2VEYXRhKDAsMCxJLndpZHRoLEkuaGVpZ2h0KS5kYXRhLmJ1ZmZlcik7Y2FzZSA4OmNhc2VcXFwiZW5kXFxcIjpyZXR1cm4gQS5zdG9wKCl9fSksQSl9KSkpLGZ1bmN0aW9uKEEsZSl7cmV0dXJuIHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9XSksSX0oKSxkZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxkZWZhdWx0OndlfSk7XCI7XG4gICAgICAgICAgcmV0dXJuIG5ldyBXb3JrZXIodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgXG4gICAgICAgICAgICA/ICdkYXRhOmFwcGxpY2F0aW9uL2phdmFzY3JpcHQ7YmFzZTY0LCcgKyBCdWZmZXIuZnJvbShzb3VyY2UsICdiaW5hcnknKS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAgIDogVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbc291cmNlXSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J30pKSk7XG4gICAgICAgIH1cbiAgICAgIFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/worker/decoder.js\n");

/***/ })

};
;